#pragma once

#include <glad/glad.h>
#include <ogl/enums.hpp>

namespace ogl {
namespace funcs {

	inline void accum(enums::AccumOp op, GLfloat value) {
		#if defined(glAccum)
			return glAccum(static_cast<GLenum>(op), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAccum" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void accumxOES(GLenum op, GLfixed value) {
		#if defined(glAccumxOES)
			return glAccumxOES(op, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAccumxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void activeProgramEXT(GLuint program) {
		#if defined(glActiveProgramEXT)
			return glActiveProgramEXT(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glActiveProgramEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void activeShaderProgram(GLuint pipeline, GLuint program) {
		#if defined(glActiveShaderProgram)
			return glActiveShaderProgram(pipeline, program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glActiveShaderProgram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void activeShaderProgramEXT(GLuint pipeline, GLuint program) {
		#if defined(glActiveShaderProgramEXT)
			return glActiveShaderProgramEXT(pipeline, program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glActiveShaderProgramEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void activeStencilFaceEXT(enums::TriangleFace face) {
		#if defined(glActiveStencilFaceEXT)
			return glActiveStencilFaceEXT(static_cast<GLenum>(face));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glActiveStencilFaceEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void activeTexture(enums::TextureUnit texture) {
		#if defined(glActiveTexture)
			return glActiveTexture(static_cast<GLenum>(texture));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glActiveTexture" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void activeTextureARB(enums::TextureUnit texture) {
		#if defined(glActiveTextureARB)
			return glActiveTextureARB(static_cast<GLenum>(texture));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glActiveTextureARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void activeVaryingNV(GLuint program, const GLchar* name) {
		#if defined(glActiveVaryingNV)
			return glActiveVaryingNV(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glActiveVaryingNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaFragmentOp1ATI(enums::FragmentOp1ATI op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
		#if defined(glAlphaFragmentOp1ATI)
			return glAlphaFragmentOp1ATI(static_cast<GLenum>(op), dst, dstMod, arg1, arg1Rep, arg1Mod);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaFragmentOp1ATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaFragmentOp2ATI(enums::FragmentOp2ATI op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
		#if defined(glAlphaFragmentOp2ATI)
			return glAlphaFragmentOp2ATI(static_cast<GLenum>(op), dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaFragmentOp2ATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaFragmentOp3ATI(enums::FragmentOp3ATI op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
		#if defined(glAlphaFragmentOp3ATI)
			return glAlphaFragmentOp3ATI(static_cast<GLenum>(op), dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaFragmentOp3ATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaFunc(enums::AlphaFunction func, GLfloat ref) {
		#if defined(glAlphaFunc)
			return glAlphaFunc(static_cast<GLenum>(func), ref);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaFunc" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaFuncQCOM(GLenum func, GLclampf ref) {
		#if defined(glAlphaFuncQCOM)
			return glAlphaFuncQCOM(func, ref);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaFuncQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaFuncx(enums::AlphaFunction func, GLfixed ref) {
		#if defined(glAlphaFuncx)
			return glAlphaFuncx(static_cast<GLenum>(func), ref);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaFuncx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaFuncxOES(enums::AlphaFunction func, GLfixed ref) {
		#if defined(glAlphaFuncxOES)
			return glAlphaFuncxOES(static_cast<GLenum>(func), ref);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaFuncxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void alphaToCoverageDitherControlNV(GLenum mode) {
		#if defined(glAlphaToCoverageDitherControlNV)
			return glAlphaToCoverageDitherControlNV(mode);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAlphaToCoverageDitherControlNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void applyFramebufferAttachmentCMAAINTEL() {
		#if defined(glApplyFramebufferAttachmentCMAAINTEL)
			return glApplyFramebufferAttachmentCMAAINTEL();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glApplyFramebufferAttachmentCMAAINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void applyTextureEXT(enums::LightTextureModeEXT mode) {
		#if defined(glApplyTextureEXT)
			return glApplyTextureEXT(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glApplyTextureEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean acquireKeyedMutexWin32EXT(GLuint memory, GLuint64 key, GLuint timeout) {
		#if defined(glAcquireKeyedMutexWin32EXT)
			return glAcquireKeyedMutexWin32EXT(memory, key, timeout);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAcquireKeyedMutexWin32EXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean areProgramsResidentNV(GLsizei n, const GLuint* programs, GLboolean* residences) {
		#if defined(glAreProgramsResidentNV)
			return glAreProgramsResidentNV(n, programs, residences);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAreProgramsResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean areTexturesResident(GLsizei n, const GLuint* textures, GLboolean* residences) {
		#if defined(glAreTexturesResident)
			return glAreTexturesResident(n, textures, residences);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAreTexturesResident" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean areTexturesResidentEXT(GLsizei n, const GLuint* textures, GLboolean* residences) {
		#if defined(glAreTexturesResidentEXT)
			return glAreTexturesResidentEXT(n, textures, residences);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAreTexturesResidentEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void arrayElement(GLint i) {
		#if defined(glArrayElement)
			return glArrayElement(i);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glArrayElement" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void arrayElementEXT(GLint i) {
		#if defined(glArrayElementEXT)
			return glArrayElementEXT(i);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glArrayElementEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void arrayObjectATI(enums::EnableCap array, GLint size, enums::ScalarType type, GLsizei stride, GLuint buffer, GLuint offset) {
		#if defined(glArrayObjectATI)
			return glArrayObjectATI(static_cast<GLenum>(array), size, static_cast<GLenum>(type), stride, buffer, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glArrayObjectATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint asyncCopyBufferSubDataNVX(GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray, const GLuint64* fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint* signalSemaphoreArray, const GLuint64* signalValueArray) {
		#if defined(glAsyncCopyBufferSubDataNVX)
			return glAsyncCopyBufferSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAsyncCopyBufferSubDataNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint asyncCopyImageSubDataNVX(GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray, const GLuint64* waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint* signalSemaphoreArray, const GLuint64* signalValueArray) {
		#if defined(glAsyncCopyImageSubDataNVX)
			return glAsyncCopyImageSubDataNVX(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAsyncCopyImageSubDataNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void asyncMarkerSGIX(GLuint marker) {
		#if defined(glAsyncMarkerSGIX)
			return glAsyncMarkerSGIX(marker);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAsyncMarkerSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void attachObjectARB(GLhandleARB containerObj, GLhandleARB obj) {
		#if defined(glAttachObjectARB)
			return glAttachObjectARB(containerObj, obj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAttachObjectARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void attachShader(GLuint program, GLuint shader) {
		#if defined(glAttachShader)
			return glAttachShader(program, shader);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glAttachShader" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void begin(enums::PrimitiveType mode) {
		#if defined(glBegin)
			return glBegin(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBegin" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginConditionalRender(GLuint id, enums::ConditionalRenderMode mode) {
		#if defined(glBeginConditionalRender)
			return glBeginConditionalRender(id, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginConditionalRender" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginConditionalRenderNV(GLuint id, enums::ConditionalRenderMode mode) {
		#if defined(glBeginConditionalRenderNV)
			return glBeginConditionalRenderNV(id, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginConditionalRenderNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginConditionalRenderNVX(GLuint id) {
		#if defined(glBeginConditionalRenderNVX)
			return glBeginConditionalRenderNVX(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginConditionalRenderNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginFragmentShaderATI() {
		#if defined(glBeginFragmentShaderATI)
			return glBeginFragmentShaderATI();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginFragmentShaderATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginOcclusionQueryNV(GLuint id) {
		#if defined(glBeginOcclusionQueryNV)
			return glBeginOcclusionQueryNV(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginOcclusionQueryNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginPerfMonitorAMD(GLuint monitor) {
		#if defined(glBeginPerfMonitorAMD)
			return glBeginPerfMonitorAMD(monitor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginPerfMonitorAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginPerfQueryINTEL(GLuint queryHandle) {
		#if defined(glBeginPerfQueryINTEL)
			return glBeginPerfQueryINTEL(queryHandle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginPerfQueryINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginQuery(enums::QueryTarget target, GLuint id) {
		#if defined(glBeginQuery)
			return glBeginQuery(static_cast<GLenum>(target), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginQuery" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginQueryARB(enums::QueryTarget target, GLuint id) {
		#if defined(glBeginQueryARB)
			return glBeginQueryARB(static_cast<GLenum>(target), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginQueryARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginQueryEXT(enums::QueryTarget target, GLuint id) {
		#if defined(glBeginQueryEXT)
			return glBeginQueryEXT(static_cast<GLenum>(target), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginQueryEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginQueryIndexed(enums::QueryTarget target, GLuint index, GLuint id) {
		#if defined(glBeginQueryIndexed)
			return glBeginQueryIndexed(static_cast<GLenum>(target), index, id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginQueryIndexed" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginTransformFeedback(enums::PrimitiveType primitiveMode) {
		#if defined(glBeginTransformFeedback)
			return glBeginTransformFeedback(static_cast<GLenum>(primitiveMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginTransformFeedback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginTransformFeedbackEXT(enums::PrimitiveType primitiveMode) {
		#if defined(glBeginTransformFeedbackEXT)
			return glBeginTransformFeedbackEXT(static_cast<GLenum>(primitiveMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginTransformFeedbackEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginTransformFeedbackNV(enums::PrimitiveType primitiveMode) {
		#if defined(glBeginTransformFeedbackNV)
			return glBeginTransformFeedbackNV(static_cast<GLenum>(primitiveMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginTransformFeedbackNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginVertexShaderEXT() {
		#if defined(glBeginVertexShaderEXT)
			return glBeginVertexShaderEXT();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginVertexShaderEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void beginVideoCaptureNV(GLuint video_capture_slot) {
		#if defined(glBeginVideoCaptureNV)
			return glBeginVideoCaptureNV(video_capture_slot);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBeginVideoCaptureNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindAttribLocation(GLuint program, GLuint index, const GLchar* name) {
		#if defined(glBindAttribLocation)
			return glBindAttribLocation(program, index, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindAttribLocation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB* name) {
		#if defined(glBindAttribLocationARB)
			return glBindAttribLocationARB(programObj, index, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindAttribLocationARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBuffer(enums::BufferTargetARB target, GLuint buffer) {
		#if defined(glBindBuffer)
			return glBindBuffer(static_cast<GLenum>(target), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferARB(enums::BufferTargetARB target, GLuint buffer) {
		#if defined(glBindBufferARB)
			return glBindBufferARB(static_cast<GLenum>(target), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferBase(enums::BufferTargetARB target, GLuint index, GLuint buffer) {
		#if defined(glBindBufferBase)
			return glBindBufferBase(static_cast<GLenum>(target), index, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferBase" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferBaseEXT(enums::BufferTargetARB target, GLuint index, GLuint buffer) {
		#if defined(glBindBufferBaseEXT)
			return glBindBufferBaseEXT(static_cast<GLenum>(target), index, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferBaseEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferBaseNV(enums::BufferTargetARB target, GLuint index, GLuint buffer) {
		#if defined(glBindBufferBaseNV)
			return glBindBufferBaseNV(static_cast<GLenum>(target), index, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferBaseNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferOffsetEXT(enums::BufferTargetARB target, GLuint index, GLuint buffer, GLintptr offset) {
		#if defined(glBindBufferOffsetEXT)
			return glBindBufferOffsetEXT(static_cast<GLenum>(target), index, buffer, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferOffsetNV(enums::BufferTargetARB target, GLuint index, GLuint buffer, GLintptr offset) {
		#if defined(glBindBufferOffsetNV)
			return glBindBufferOffsetNV(static_cast<GLenum>(target), index, buffer, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferOffsetNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferRange(enums::BufferTargetARB target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glBindBufferRange)
			return glBindBufferRange(static_cast<GLenum>(target), index, buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferRangeEXT(enums::BufferTargetARB target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glBindBufferRangeEXT)
			return glBindBufferRangeEXT(static_cast<GLenum>(target), index, buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferRangeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBufferRangeNV(enums::BufferTargetARB target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glBindBufferRangeNV)
			return glBindBufferRangeNV(static_cast<GLenum>(target), index, buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBufferRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBuffersBase(enums::BufferTargetARB target, GLuint first, GLsizei count, const GLuint* buffers) {
		#if defined(glBindBuffersBase)
			return glBindBuffersBase(static_cast<GLenum>(target), first, count, buffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBuffersBase" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindBuffersRange(enums::BufferTargetARB target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizeiptr* sizes) {
		#if defined(glBindBuffersRange)
			return glBindBuffersRange(static_cast<GLenum>(target), first, count, buffers, offsets, sizes);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindBuffersRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFragDataLocation(GLuint program, GLuint color, const GLchar* name) {
		#if defined(glBindFragDataLocation)
			return glBindFragDataLocation(program, color, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFragDataLocation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFragDataLocationEXT(GLuint program, GLuint color, const GLchar* name) {
		#if defined(glBindFragDataLocationEXT)
			return glBindFragDataLocationEXT(program, color, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFragDataLocationEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar* name) {
		#if defined(glBindFragDataLocationIndexed)
			return glBindFragDataLocationIndexed(program, colorNumber, index, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFragDataLocationIndexed" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFragDataLocationIndexedEXT(GLuint program, GLuint colorNumber, GLuint index, const GLchar* name) {
		#if defined(glBindFragDataLocationIndexedEXT)
			return glBindFragDataLocationIndexedEXT(program, colorNumber, index, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFragDataLocationIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFragmentShaderATI(GLuint id) {
		#if defined(glBindFragmentShaderATI)
			return glBindFragmentShaderATI(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFragmentShaderATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFramebuffer(enums::FramebufferTarget target, GLuint framebuffer) {
		#if defined(glBindFramebuffer)
			return glBindFramebuffer(static_cast<GLenum>(target), framebuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFramebuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFramebufferEXT(enums::FramebufferTarget target, GLuint framebuffer) {
		#if defined(glBindFramebufferEXT)
			return glBindFramebufferEXT(static_cast<GLenum>(target), framebuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFramebufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindFramebufferOES(enums::FramebufferTarget target, GLuint framebuffer) {
		#if defined(glBindFramebufferOES)
			return glBindFramebufferOES(static_cast<GLenum>(target), framebuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindFramebufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, enums::BufferAccessARB access, enums::InternalFormat format) {
		#if defined(glBindImageTexture)
			return glBindImageTexture(unit, texture, level, layered, layer, static_cast<GLenum>(access), static_cast<GLenum>(format));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindImageTexture" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, enums::BufferAccessARB access, GLint format) {
		#if defined(glBindImageTextureEXT)
			return glBindImageTextureEXT(index, texture, level, layered, layer, static_cast<GLenum>(access), format);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindImageTextureEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindImageTextures(GLuint first, GLsizei count, const GLuint* textures) {
		#if defined(glBindImageTextures)
			return glBindImageTextures(first, count, textures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindImageTextures" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint bindLightParameterEXT(enums::LightName light, enums::LightParameter value) {
		#if defined(glBindLightParameterEXT)
			return glBindLightParameterEXT(static_cast<GLenum>(light), static_cast<GLenum>(value));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindLightParameterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint bindMaterialParameterEXT(enums::TriangleFace face, enums::MaterialParameter value) {
		#if defined(glBindMaterialParameterEXT)
			return glBindMaterialParameterEXT(static_cast<GLenum>(face), static_cast<GLenum>(value));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindMaterialParameterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void bindMultiTextureEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLuint texture) {
		#if defined(glBindMultiTextureEXT)
			return glBindMultiTextureEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindMultiTextureEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint bindParameterEXT(enums::VertexShaderParameterEXT value) {
		#if defined(glBindParameterEXT)
			return glBindParameterEXT(static_cast<GLenum>(value));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindParameterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void bindProgramARB(enums::ProgramTarget target, GLuint program) {
		#if defined(glBindProgramARB)
			return glBindProgramARB(static_cast<GLenum>(target), program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindProgramARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindProgramNV(enums::VertexAttribEnumNV target, GLuint id) {
		#if defined(glBindProgramNV)
			return glBindProgramNV(static_cast<GLenum>(target), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindProgramNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindProgramPipeline(GLuint pipeline) {
		#if defined(glBindProgramPipeline)
			return glBindProgramPipeline(pipeline);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindProgramPipeline" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindProgramPipelineEXT(GLuint pipeline) {
		#if defined(glBindProgramPipelineEXT)
			return glBindProgramPipelineEXT(pipeline);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindProgramPipelineEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindRenderbuffer(enums::RenderbufferTarget target, GLuint renderbuffer) {
		#if defined(glBindRenderbuffer)
			return glBindRenderbuffer(static_cast<GLenum>(target), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindRenderbuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindRenderbufferEXT(enums::RenderbufferTarget target, GLuint renderbuffer) {
		#if defined(glBindRenderbufferEXT)
			return glBindRenderbufferEXT(static_cast<GLenum>(target), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindRenderbufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindRenderbufferOES(enums::RenderbufferTarget target, GLuint renderbuffer) {
		#if defined(glBindRenderbufferOES)
			return glBindRenderbufferOES(static_cast<GLenum>(target), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindRenderbufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindSampler(GLuint unit, GLuint sampler) {
		#if defined(glBindSampler)
			return glBindSampler(unit, sampler);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindSampler" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindSamplers(GLuint first, GLsizei count, const GLuint* samplers) {
		#if defined(glBindSamplers)
			return glBindSamplers(first, count, samplers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindSamplers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindShadingRateImageNV(GLuint texture) {
		#if defined(glBindShadingRateImageNV)
			return glBindShadingRateImageNV(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindShadingRateImageNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint bindTexGenParameterEXT(enums::TextureUnit unit, enums::TextureCoordName coord, enums::TextureGenParameter value) {
		#if defined(glBindTexGenParameterEXT)
			return glBindTexGenParameterEXT(static_cast<GLenum>(unit), static_cast<GLenum>(coord), static_cast<GLenum>(value));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTexGenParameterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void bindTexture(enums::TextureTarget target, GLuint texture) {
		#if defined(glBindTexture)
			return glBindTexture(static_cast<GLenum>(target), texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTexture" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindTextureEXT(enums::TextureTarget target, GLuint texture) {
		#if defined(glBindTextureEXT)
			return glBindTextureEXT(static_cast<GLenum>(target), texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTextureEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindTextureUnit(GLuint unit, GLuint texture) {
		#if defined(glBindTextureUnit)
			return glBindTextureUnit(unit, texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTextureUnit" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint bindTextureUnitParameterEXT(enums::TextureUnit unit, enums::VertexShaderTextureUnitParameter value) {
		#if defined(glBindTextureUnitParameterEXT)
			return glBindTextureUnitParameterEXT(static_cast<GLenum>(unit), static_cast<GLenum>(value));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTextureUnitParameterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void bindTextures(GLuint first, GLsizei count, const GLuint* textures) {
		#if defined(glBindTextures)
			return glBindTextures(first, count, textures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTextures" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindTransformFeedback(enums::BindTransformFeedbackTarget target, GLuint id) {
		#if defined(glBindTransformFeedback)
			return glBindTransformFeedback(static_cast<GLenum>(target), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTransformFeedback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindTransformFeedbackNV(enums::BufferTargetARB target, GLuint id) {
		#if defined(glBindTransformFeedbackNV)
			return glBindTransformFeedbackNV(static_cast<GLenum>(target), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindTransformFeedbackNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVertexArray(GLuint array) {
		#if defined(glBindVertexArray)
			return glBindVertexArray(array);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVertexArray" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVertexArrayAPPLE(GLuint array) {
		#if defined(glBindVertexArrayAPPLE)
			return glBindVertexArrayAPPLE(array);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVertexArrayAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVertexArrayOES(GLuint array) {
		#if defined(glBindVertexArrayOES)
			return glBindVertexArrayOES(array);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVertexArrayOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
		#if defined(glBindVertexBuffer)
			return glBindVertexBuffer(bindingindex, buffer, offset, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVertexBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVertexBuffers(GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides) {
		#if defined(glBindVertexBuffers)
			return glBindVertexBuffers(first, count, buffers, offsets, strides);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVertexBuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVertexShaderEXT(GLuint id) {
		#if defined(glBindVertexShaderEXT)
			return glBindVertexShaderEXT(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVertexShaderEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset) {
		#if defined(glBindVideoCaptureStreamBufferNV)
			return glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVideoCaptureStreamBufferNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture) {
		#if defined(glBindVideoCaptureStreamTextureNV)
			return glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBindVideoCaptureStreamTextureNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz) {
		#if defined(glBinormal3bEXT)
			return glBinormal3bEXT(bx, by, bz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3bEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3bvEXT(const GLbyte* v) {
		#if defined(glBinormal3bvEXT)
			return glBinormal3bvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3bvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz) {
		#if defined(glBinormal3dEXT)
			return glBinormal3dEXT(bx, by, bz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3dvEXT(const GLdouble* v) {
		#if defined(glBinormal3dvEXT)
			return glBinormal3dvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz) {
		#if defined(glBinormal3fEXT)
			return glBinormal3fEXT(bx, by, bz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3fvEXT(const GLfloat* v) {
		#if defined(glBinormal3fvEXT)
			return glBinormal3fvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3iEXT(GLint bx, GLint by, GLint bz) {
		#if defined(glBinormal3iEXT)
			return glBinormal3iEXT(bx, by, bz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3ivEXT(const GLint* v) {
		#if defined(glBinormal3ivEXT)
			return glBinormal3ivEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3sEXT(GLshort bx, GLshort by, GLshort bz) {
		#if defined(glBinormal3sEXT)
			return glBinormal3sEXT(bx, by, bz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3sEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormal3svEXT(const GLshort* v) {
		#if defined(glBinormal3svEXT)
			return glBinormal3svEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormal3svEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void binormalPointerEXT(enums::BinormalPointerTypeEXT type, GLsizei stride, const void * pointer) {
		#if defined(glBinormalPointerEXT)
			return glBinormalPointerEXT(static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBinormalPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte* bitmap) {
		#if defined(glBitmap)
			return glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBitmap" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bitmapxOES(GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte* bitmap) {
		#if defined(glBitmapxOES)
			return glBitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBitmapxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendBarrier() {
		#if defined(glBlendBarrier)
			return glBlendBarrier();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendBarrier" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendBarrierKHR() {
		#if defined(glBlendBarrierKHR)
			return glBlendBarrierKHR();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendBarrierKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendBarrierNV() {
		#if defined(glBlendBarrierNV)
			return glBlendBarrierNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendBarrierNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
		#if defined(glBlendColor)
			return glBlendColor(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendColor" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendColorEXT(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
		#if defined(glBlendColorEXT)
			return glBlendColorEXT(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendColorEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
		#if defined(glBlendColorxOES)
			return glBlendColorxOES(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendColorxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquation(enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquation)
			return glBlendEquation(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationEXT(enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquationEXT)
			return glBlendEquationEXT(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationIndexedAMD(GLuint buf, enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquationIndexedAMD)
			return glBlendEquationIndexedAMD(buf, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationIndexedAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationOES(enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquationOES)
			return glBlendEquationOES(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparate(enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparate)
			return glBlendEquationSeparate(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparate" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparateEXT(enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparateEXT)
			return glBlendEquationSeparateEXT(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparateEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparateIndexedAMD(GLuint buf, enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparateIndexedAMD)
			return glBlendEquationSeparateIndexedAMD(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparateIndexedAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparateOES(enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparateOES)
			return glBlendEquationSeparateOES(static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparateOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparatei(GLuint buf, enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparatei)
			return glBlendEquationSeparatei(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparatei" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparateiARB(GLuint buf, enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparateiARB)
			return glBlendEquationSeparateiARB(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparateiARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparateiEXT(GLuint buf, enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparateiEXT)
			return glBlendEquationSeparateiEXT(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparateiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationSeparateiOES(GLuint buf, enums::BlendEquationModeEXT modeRGB, enums::BlendEquationModeEXT modeAlpha) {
		#if defined(glBlendEquationSeparateiOES)
			return glBlendEquationSeparateiOES(buf, static_cast<GLenum>(modeRGB), static_cast<GLenum>(modeAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationSeparateiOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationi(GLuint buf, enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquationi)
			return glBlendEquationi(buf, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationiARB(GLuint buf, enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquationiARB)
			return glBlendEquationiARB(buf, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationiARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationiEXT(GLuint buf, enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquationiEXT)
			return glBlendEquationiEXT(buf, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendEquationiOES(GLuint buf, enums::BlendEquationModeEXT mode) {
		#if defined(glBlendEquationiOES)
			return glBlendEquationiOES(buf, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendEquationiOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFunc(enums::BlendingFactor sfactor, enums::BlendingFactor dfactor) {
		#if defined(glBlendFunc)
			return glBlendFunc(static_cast<GLenum>(sfactor), static_cast<GLenum>(dfactor));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFunc" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst) {
		#if defined(glBlendFuncIndexedAMD)
			return glBlendFuncIndexedAMD(buf, src, dst);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncIndexedAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparate(enums::BlendingFactor sfactorRGB, enums::BlendingFactor dfactorRGB, enums::BlendingFactor sfactorAlpha, enums::BlendingFactor dfactorAlpha) {
		#if defined(glBlendFuncSeparate)
			return glBlendFuncSeparate(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparate" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparateEXT(enums::BlendingFactor sfactorRGB, enums::BlendingFactor dfactorRGB, enums::BlendingFactor sfactorAlpha, enums::BlendingFactor dfactorAlpha) {
		#if defined(glBlendFuncSeparateEXT)
			return glBlendFuncSeparateEXT(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparateEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparateINGR(enums::BlendingFactor sfactorRGB, enums::BlendingFactor dfactorRGB, enums::BlendingFactor sfactorAlpha, enums::BlendingFactor dfactorAlpha) {
		#if defined(glBlendFuncSeparateINGR)
			return glBlendFuncSeparateINGR(static_cast<GLenum>(sfactorRGB), static_cast<GLenum>(dfactorRGB), static_cast<GLenum>(sfactorAlpha), static_cast<GLenum>(dfactorAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparateINGR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparateIndexedAMD(GLuint buf, enums::BlendingFactor srcRGB, enums::BlendingFactor dstRGB, enums::BlendingFactor srcAlpha, enums::BlendingFactor dstAlpha) {
		#if defined(glBlendFuncSeparateIndexedAMD)
			return glBlendFuncSeparateIndexedAMD(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparateIndexedAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparateOES(enums::BlendingFactor srcRGB, enums::BlendingFactor dstRGB, enums::BlendingFactor srcAlpha, enums::BlendingFactor dstAlpha) {
		#if defined(glBlendFuncSeparateOES)
			return glBlendFuncSeparateOES(static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparateOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparatei(GLuint buf, enums::BlendingFactor srcRGB, enums::BlendingFactor dstRGB, enums::BlendingFactor srcAlpha, enums::BlendingFactor dstAlpha) {
		#if defined(glBlendFuncSeparatei)
			return glBlendFuncSeparatei(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparatei" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparateiARB(GLuint buf, enums::BlendingFactor srcRGB, enums::BlendingFactor dstRGB, enums::BlendingFactor srcAlpha, enums::BlendingFactor dstAlpha) {
		#if defined(glBlendFuncSeparateiARB)
			return glBlendFuncSeparateiARB(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparateiARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparateiEXT(GLuint buf, enums::BlendingFactor srcRGB, enums::BlendingFactor dstRGB, enums::BlendingFactor srcAlpha, enums::BlendingFactor dstAlpha) {
		#if defined(glBlendFuncSeparateiEXT)
			return glBlendFuncSeparateiEXT(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparateiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFuncSeparateiOES(GLuint buf, enums::BlendingFactor srcRGB, enums::BlendingFactor dstRGB, enums::BlendingFactor srcAlpha, enums::BlendingFactor dstAlpha) {
		#if defined(glBlendFuncSeparateiOES)
			return glBlendFuncSeparateiOES(buf, static_cast<GLenum>(srcRGB), static_cast<GLenum>(dstRGB), static_cast<GLenum>(srcAlpha), static_cast<GLenum>(dstAlpha));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFuncSeparateiOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFunci(GLuint buf, enums::BlendingFactor src, enums::BlendingFactor dst) {
		#if defined(glBlendFunci)
			return glBlendFunci(buf, static_cast<GLenum>(src), static_cast<GLenum>(dst));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFunci" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFunciARB(GLuint buf, enums::BlendingFactor src, enums::BlendingFactor dst) {
		#if defined(glBlendFunciARB)
			return glBlendFunciARB(buf, static_cast<GLenum>(src), static_cast<GLenum>(dst));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFunciARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFunciEXT(GLuint buf, enums::BlendingFactor src, enums::BlendingFactor dst) {
		#if defined(glBlendFunciEXT)
			return glBlendFunciEXT(buf, static_cast<GLenum>(src), static_cast<GLenum>(dst));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFunciEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendFunciOES(GLuint buf, enums::BlendingFactor src, enums::BlendingFactor dst) {
		#if defined(glBlendFunciOES)
			return glBlendFunciOES(buf, static_cast<GLenum>(src), static_cast<GLenum>(dst));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendFunciOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blendParameteriNV(GLenum pname, GLint value) {
		#if defined(glBlendParameteriNV)
			return glBlendParameteriNV(pname, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlendParameteriNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, enums::BlitFramebufferFilter filter) {
		#if defined(glBlitFramebuffer)
			return glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, static_cast<GLenum>(filter));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlitFramebuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, enums::BlitFramebufferFilter filter) {
		#if defined(glBlitFramebufferANGLE)
			return glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, static_cast<GLenum>(filter));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlitFramebufferANGLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, enums::BlitFramebufferFilter filter) {
		#if defined(glBlitFramebufferEXT)
			return glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, static_cast<GLenum>(filter));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlitFramebufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blitFramebufferLayerEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint srcLayer, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLint dstLayer, GLbitfield mask, enums::BlitFramebufferFilter filter) {
		#if defined(glBlitFramebufferLayerEXT)
			return glBlitFramebufferLayerEXT(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, static_cast<GLenum>(filter));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlitFramebufferLayerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blitFramebufferLayersEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, enums::BlitFramebufferFilter filter) {
		#if defined(glBlitFramebufferLayersEXT)
			return glBlitFramebufferLayersEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, static_cast<GLenum>(filter));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlitFramebufferLayersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blitFramebufferNV(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, enums::BlitFramebufferFilter filter) {
		#if defined(glBlitFramebufferNV)
			return glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, static_cast<GLenum>(filter));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlitFramebufferNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void blitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, enums::BlitFramebufferFilter filter) {
		#if defined(glBlitNamedFramebuffer)
			return glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, static_cast<GLenum>(filter));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBlitNamedFramebuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length) {
		#if defined(glBufferAddressRangeNV)
			return glBufferAddressRangeNV(pname, index, address, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferAddressRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferAttachMemoryNV(enums::BufferTargetARB target, GLuint memory, GLuint64 offset) {
		#if defined(glBufferAttachMemoryNV)
			return glBufferAttachMemoryNV(static_cast<GLenum>(target), memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferAttachMemoryNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferData(enums::BufferTargetARB target, GLsizeiptr size, const void * data, enums::BufferUsageARB usage) {
		#if defined(glBufferData)
			return glBufferData(static_cast<GLenum>(target), size, data, static_cast<GLenum>(usage));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferDataARB(enums::BufferTargetARB target, GLsizeiptrARB size, const void * data, enums::BufferUsageARB usage) {
		#if defined(glBufferDataARB)
			return glBufferDataARB(static_cast<GLenum>(target), size, data, static_cast<GLenum>(usage));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferDataARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit) {
		#if defined(glBufferPageCommitmentARB)
			return glBufferPageCommitmentARB(target, offset, size, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferPageCommitmentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferPageCommitmentMemNV(enums::BufferStorageTarget target, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit) {
		#if defined(glBufferPageCommitmentMemNV)
			return glBufferPageCommitmentMemNV(static_cast<GLenum>(target), offset, size, memory, memOffset, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferPageCommitmentMemNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferParameteriAPPLE(GLenum target, GLenum pname, GLint param) {
		#if defined(glBufferParameteriAPPLE)
			return glBufferParameteriAPPLE(target, pname, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferParameteriAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferStorage(enums::BufferStorageTarget target, GLsizeiptr size, const void * data, GLbitfield flags) {
		#if defined(glBufferStorage)
			return glBufferStorage(static_cast<GLenum>(target), size, data, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferStorage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferStorageEXT(enums::BufferStorageTarget target, GLsizeiptr size, const void * data, GLbitfield flags) {
		#if defined(glBufferStorageEXT)
			return glBufferStorageEXT(static_cast<GLenum>(target), size, data, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferStorageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferStorageExternalEXT(GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags) {
		#if defined(glBufferStorageExternalEXT)
			return glBufferStorageExternalEXT(target, offset, size, clientBuffer, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferStorageExternalEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferStorageMemEXT(enums::BufferTargetARB target, GLsizeiptr size, GLuint memory, GLuint64 offset) {
		#if defined(glBufferStorageMemEXT)
			return glBufferStorageMemEXT(static_cast<GLenum>(target), size, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferStorageMemEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferSubData(enums::BufferTargetARB target, GLintptr offset, GLsizeiptr size, const void * data) {
		#if defined(glBufferSubData)
			return glBufferSubData(static_cast<GLenum>(target), offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void bufferSubDataARB(enums::BufferTargetARB target, GLintptrARB offset, GLsizeiptrARB size, const void * data) {
		#if defined(glBufferSubDataARB)
			return glBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glBufferSubDataARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void callCommandListNV(GLuint list) {
		#if defined(glCallCommandListNV)
			return glCallCommandListNV(list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCallCommandListNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void callList(GLuint list) {
		#if defined(glCallList)
			return glCallList(list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCallList" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void callLists(GLsizei n, enums::ListNameType type, const void * lists) {
		#if defined(glCallLists)
			return glCallLists(n, static_cast<GLenum>(type), lists);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCallLists" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLenum checkFramebufferStatus(enums::FramebufferTarget target) {
		#if defined(glCheckFramebufferStatus)
			return glCheckFramebufferStatus(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCheckFramebufferStatus" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum checkFramebufferStatusEXT(enums::FramebufferTarget target) {
		#if defined(glCheckFramebufferStatusEXT)
			return glCheckFramebufferStatusEXT(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCheckFramebufferStatusEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum checkFramebufferStatusOES(enums::FramebufferTarget target) {
		#if defined(glCheckFramebufferStatusOES)
			return glCheckFramebufferStatusOES(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCheckFramebufferStatusOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum checkNamedFramebufferStatus(GLuint framebuffer, enums::FramebufferTarget target) {
		#if defined(glCheckNamedFramebufferStatus)
			return glCheckNamedFramebufferStatus(framebuffer, static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCheckNamedFramebufferStatus" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum checkNamedFramebufferStatusEXT(GLuint framebuffer, enums::FramebufferTarget target) {
		#if defined(glCheckNamedFramebufferStatusEXT)
			return glCheckNamedFramebufferStatusEXT(framebuffer, static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCheckNamedFramebufferStatusEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void clampColor(enums::ClampColorTargetARB target, enums::ClampColorModeARB clamp) {
		#if defined(glClampColor)
			return glClampColor(static_cast<GLenum>(target), static_cast<GLenum>(clamp));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClampColor" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clampColorARB(enums::ClampColorTargetARB target, enums::ClampColorModeARB clamp) {
		#if defined(glClampColorARB)
			return glClampColorARB(static_cast<GLenum>(target), static_cast<GLenum>(clamp));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClampColorARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clear(GLbitfield mask) {
		#if defined(glClear)
			return glClear(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClear" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
		#if defined(glClearAccum)
			return glClearAccum(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearAccum" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearAccumxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
		#if defined(glClearAccumxOES)
			return glClearAccumxOES(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearAccumxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearBufferData(enums::BufferStorageTarget target, enums::SizedInternalFormat internalformat, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearBufferData)
			return glClearBufferData(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearBufferData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearBufferSubData(enums::BufferTargetARB target, enums::SizedInternalFormat internalformat, GLintptr offset, GLsizeiptr size, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearBufferSubData)
			return glClearBufferSubData(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), offset, size, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearBufferfi(enums::Buffer buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
		#if defined(glClearBufferfi)
			return glClearBufferfi(static_cast<GLenum>(buffer), drawbuffer, depth, stencil);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearBufferfi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearBufferfv(enums::Buffer buffer, GLint drawbuffer, const GLfloat* value) {
		#if defined(glClearBufferfv)
			return glClearBufferfv(static_cast<GLenum>(buffer), drawbuffer, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearBufferfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearBufferiv(enums::Buffer buffer, GLint drawbuffer, const GLint* value) {
		#if defined(glClearBufferiv)
			return glClearBufferiv(static_cast<GLenum>(buffer), drawbuffer, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearBufferiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearBufferuiv(enums::Buffer buffer, GLint drawbuffer, const GLuint* value) {
		#if defined(glClearBufferuiv)
			return glClearBufferuiv(static_cast<GLenum>(buffer), drawbuffer, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearBufferuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
		#if defined(glClearColor)
			return glClearColor(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearColor" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha) {
		#if defined(glClearColorIiEXT)
			return glClearColorIiEXT(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearColorIiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
		#if defined(glClearColorIuiEXT)
			return glClearColorIuiEXT(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearColorIuiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearColorx(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
		#if defined(glClearColorx)
			return glClearColorx(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearColorx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearColorxOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
		#if defined(glClearColorxOES)
			return glClearColorxOES(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearColorxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearDepth(GLdouble depth) {
		#if defined(glClearDepth)
			return glClearDepth(depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearDepth" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearDepthdNV(GLdouble depth) {
		#if defined(glClearDepthdNV)
			return glClearDepthdNV(depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearDepthdNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearDepthf(GLfloat d) {
		#if defined(glClearDepthf)
			return glClearDepthf(d);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearDepthf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearDepthfOES(GLclampf depth) {
		#if defined(glClearDepthfOES)
			return glClearDepthfOES(depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearDepthfOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearDepthx(GLfixed depth) {
		#if defined(glClearDepthx)
			return glClearDepthx(depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearDepthx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearDepthxOES(GLfixed depth) {
		#if defined(glClearDepthxOES)
			return glClearDepthxOES(depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearDepthxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearIndex(GLfloat c) {
		#if defined(glClearIndex)
			return glClearIndex(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearIndex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedBufferData(GLuint buffer, enums::SizedInternalFormat internalformat, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearNamedBufferData)
			return glClearNamedBufferData(buffer, static_cast<GLenum>(internalformat), static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedBufferData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedBufferDataEXT(GLuint buffer, enums::SizedInternalFormat internalformat, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearNamedBufferDataEXT)
			return glClearNamedBufferDataEXT(buffer, static_cast<GLenum>(internalformat), static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedBufferDataEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedBufferSubData(GLuint buffer, enums::SizedInternalFormat internalformat, GLintptr offset, GLsizeiptr size, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearNamedBufferSubData)
			return glClearNamedBufferSubData(buffer, static_cast<GLenum>(internalformat), offset, size, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedBufferSubDataEXT(GLuint buffer, enums::SizedInternalFormat internalformat, GLsizeiptr offset, GLsizeiptr size, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearNamedBufferSubDataEXT)
			return glClearNamedBufferSubDataEXT(buffer, static_cast<GLenum>(internalformat), offset, size, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedBufferSubDataEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedFramebufferfi(GLuint framebuffer, enums::Buffer buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
		#if defined(glClearNamedFramebufferfi)
			return glClearNamedFramebufferfi(framebuffer, static_cast<GLenum>(buffer), drawbuffer, depth, stencil);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedFramebufferfi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedFramebufferfv(GLuint framebuffer, enums::Buffer buffer, GLint drawbuffer, const GLfloat* value) {
		#if defined(glClearNamedFramebufferfv)
			return glClearNamedFramebufferfv(framebuffer, static_cast<GLenum>(buffer), drawbuffer, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedFramebufferfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedFramebufferiv(GLuint framebuffer, enums::Buffer buffer, GLint drawbuffer, const GLint* value) {
		#if defined(glClearNamedFramebufferiv)
			return glClearNamedFramebufferiv(framebuffer, static_cast<GLenum>(buffer), drawbuffer, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedFramebufferiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearNamedFramebufferuiv(GLuint framebuffer, enums::Buffer buffer, GLint drawbuffer, const GLuint* value) {
		#if defined(glClearNamedFramebufferuiv)
			return glClearNamedFramebufferuiv(framebuffer, static_cast<GLenum>(buffer), drawbuffer, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearNamedFramebufferuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearPixelLocalStorageuiEXT(GLsizei offset, GLsizei n, const GLuint* values) {
		#if defined(glClearPixelLocalStorageuiEXT)
			return glClearPixelLocalStorageuiEXT(offset, n, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearPixelLocalStorageuiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearStencil(GLint s) {
		#if defined(glClearStencil)
			return glClearStencil(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearStencil" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearTexImage(GLuint texture, GLint level, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearTexImage)
			return glClearTexImage(texture, level, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearTexImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearTexImageEXT(GLuint texture, GLint level, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearTexImageEXT)
			return glClearTexImageEXT(texture, level, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearTexImageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearTexSubImage)
			return glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearTexSubImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clearTexSubImageEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glClearTexSubImageEXT)
			return glClearTexSubImageEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClearTexSubImageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clientActiveTexture(enums::TextureUnit texture) {
		#if defined(glClientActiveTexture)
			return glClientActiveTexture(static_cast<GLenum>(texture));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClientActiveTexture" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clientActiveTextureARB(enums::TextureUnit texture) {
		#if defined(glClientActiveTextureARB)
			return glClientActiveTextureARB(static_cast<GLenum>(texture));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClientActiveTextureARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clientActiveVertexStreamATI(enums::VertexStreamATI stream) {
		#if defined(glClientActiveVertexStreamATI)
			return glClientActiveVertexStreamATI(static_cast<GLenum>(stream));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClientActiveVertexStreamATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clientAttribDefaultEXT(GLbitfield mask) {
		#if defined(glClientAttribDefaultEXT)
			return glClientAttribDefaultEXT(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClientAttribDefaultEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clientWaitSemaphoreui64NVX(GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64* fenceValueArray) {
		#if defined(glClientWaitSemaphoreui64NVX)
			return glClientWaitSemaphoreui64NVX(fenceObjectCount, semaphoreArray, fenceValueArray);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClientWaitSemaphoreui64NVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLenum clientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
		#if defined(glClientWaitSync)
			return glClientWaitSync(sync, flags, timeout);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClientWaitSync" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum clientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) {
		#if defined(glClientWaitSyncAPPLE)
			return glClientWaitSyncAPPLE(sync, flags, timeout);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClientWaitSyncAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void clipControl(enums::ClipControlOrigin origin, enums::ClipControlDepth depth) {
		#if defined(glClipControl)
			return glClipControl(static_cast<GLenum>(origin), static_cast<GLenum>(depth));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipControl" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipControlEXT(GLenum origin, GLenum depth) {
		#if defined(glClipControlEXT)
			return glClipControlEXT(origin, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipControlEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipPlane(enums::ClipPlaneName plane, const GLdouble* equation) {
		#if defined(glClipPlane)
			return glClipPlane(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipPlane" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipPlanef(enums::ClipPlaneName p, const GLfloat* eqn) {
		#if defined(glClipPlanef)
			return glClipPlanef(static_cast<GLenum>(p), eqn);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipPlanef" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipPlanefIMG(enums::ClipPlaneName p, const GLfloat* eqn) {
		#if defined(glClipPlanefIMG)
			return glClipPlanefIMG(static_cast<GLenum>(p), eqn);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipPlanefIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipPlanefOES(enums::ClipPlaneName plane, const GLfloat* equation) {
		#if defined(glClipPlanefOES)
			return glClipPlanefOES(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipPlanefOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipPlanex(enums::ClipPlaneName plane, const GLfixed* equation) {
		#if defined(glClipPlanex)
			return glClipPlanex(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipPlanex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipPlanexIMG(enums::ClipPlaneName p, const GLfixed* eqn) {
		#if defined(glClipPlanexIMG)
			return glClipPlanexIMG(static_cast<GLenum>(p), eqn);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipPlanexIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void clipPlanexOES(enums::ClipPlaneName plane, const GLfixed* equation) {
		#if defined(glClipPlanexOES)
			return glClipPlanexOES(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glClipPlanexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3b(GLbyte red, GLbyte green, GLbyte blue) {
		#if defined(glColor3b)
			return glColor3b(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3b" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3bv(const GLbyte* v) {
		#if defined(glColor3bv)
			return glColor3bv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3bv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3d(GLdouble red, GLdouble green, GLdouble blue) {
		#if defined(glColor3d)
			return glColor3d(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3dv(const GLdouble* v) {
		#if defined(glColor3dv)
			return glColor3dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3f(GLfloat red, GLfloat green, GLfloat blue) {
		#if defined(glColor3f)
			return glColor3f(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glColor3fVertex3fSUN)
			return glColor3fVertex3fSUN(r, g, b, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3fVertex3fvSUN(const GLfloat* c, const GLfloat* v) {
		#if defined(glColor3fVertex3fvSUN)
			return glColor3fVertex3fvSUN(c, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3fv(const GLfloat* v) {
		#if defined(glColor3fv)
			return glColor3fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
		#if defined(glColor3hNV)
			return glColor3hNV(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3hvNV(const GLhalfNV* v) {
		#if defined(glColor3hvNV)
			return glColor3hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3i(GLint red, GLint green, GLint blue) {
		#if defined(glColor3i)
			return glColor3i(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3iv(const GLint* v) {
		#if defined(glColor3iv)
			return glColor3iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3s(GLshort red, GLshort green, GLshort blue) {
		#if defined(glColor3s)
			return glColor3s(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3sv(const GLshort* v) {
		#if defined(glColor3sv)
			return glColor3sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3ub(GLubyte red, GLubyte green, GLubyte blue) {
		#if defined(glColor3ub)
			return glColor3ub(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3ub" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3ubv(const GLubyte* v) {
		#if defined(glColor3ubv)
			return glColor3ubv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3ubv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3ui(GLuint red, GLuint green, GLuint blue) {
		#if defined(glColor3ui)
			return glColor3ui(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3uiv(const GLuint* v) {
		#if defined(glColor3uiv)
			return glColor3uiv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3us(GLushort red, GLushort green, GLushort blue) {
		#if defined(glColor3us)
			return glColor3us(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3us" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3usv(const GLushort* v) {
		#if defined(glColor3usv)
			return glColor3usv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3usv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3xOES(GLfixed red, GLfixed green, GLfixed blue) {
		#if defined(glColor3xOES)
			return glColor3xOES(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color3xvOES(const GLfixed* components) {
		#if defined(glColor3xvOES)
			return glColor3xvOES(components);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor3xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) {
		#if defined(glColor4b)
			return glColor4b(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4b" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4bv(const GLbyte* v) {
		#if defined(glColor4bv)
			return glColor4bv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4bv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) {
		#if defined(glColor4d)
			return glColor4d(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4dv(const GLdouble* v) {
		#if defined(glColor4dv)
			return glColor4dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
		#if defined(glColor4f)
			return glColor4f(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glColor4fNormal3fVertex3fSUN)
			return glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4fNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4fNormal3fVertex3fvSUN(const GLfloat* c, const GLfloat* n, const GLfloat* v) {
		#if defined(glColor4fNormal3fVertex3fvSUN)
			return glColor4fNormal3fVertex3fvSUN(c, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4fNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4fv(const GLfloat* v) {
		#if defined(glColor4fv)
			return glColor4fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha) {
		#if defined(glColor4hNV)
			return glColor4hNV(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4hvNV(const GLhalfNV* v) {
		#if defined(glColor4hvNV)
			return glColor4hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4i(GLint red, GLint green, GLint blue, GLint alpha) {
		#if defined(glColor4i)
			return glColor4i(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4iv(const GLint* v) {
		#if defined(glColor4iv)
			return glColor4iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4s(GLshort red, GLshort green, GLshort blue, GLshort alpha) {
		#if defined(glColor4s)
			return glColor4s(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4sv(const GLshort* v) {
		#if defined(glColor4sv)
			return glColor4sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) {
		#if defined(glColor4ub)
			return glColor4ub(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4ub" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y) {
		#if defined(glColor4ubVertex2fSUN)
			return glColor4ubVertex2fSUN(r, g, b, a, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4ubVertex2fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4ubVertex2fvSUN(const GLubyte* c, const GLfloat* v) {
		#if defined(glColor4ubVertex2fvSUN)
			return glColor4ubVertex2fvSUN(c, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4ubVertex2fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glColor4ubVertex3fSUN)
			return glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4ubVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4ubVertex3fvSUN(const GLubyte* c, const GLfloat* v) {
		#if defined(glColor4ubVertex3fvSUN)
			return glColor4ubVertex3fvSUN(c, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4ubVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4ubv(const GLubyte* v) {
		#if defined(glColor4ubv)
			return glColor4ubv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4ubv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha) {
		#if defined(glColor4ui)
			return glColor4ui(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4uiv(const GLuint* v) {
		#if defined(glColor4uiv)
			return glColor4uiv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4us(GLushort red, GLushort green, GLushort blue, GLushort alpha) {
		#if defined(glColor4us)
			return glColor4us(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4us" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4usv(const GLushort* v) {
		#if defined(glColor4usv)
			return glColor4usv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4usv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
		#if defined(glColor4x)
			return glColor4x(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4x" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4xOES(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha) {
		#if defined(glColor4xOES)
			return glColor4xOES(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void color4xvOES(const GLfixed* components) {
		#if defined(glColor4xvOES)
			return glColor4xvOES(components);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColor4xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorFormatNV(GLint size, enums::ColorPointerType type, GLsizei stride) {
		#if defined(glColorFormatNV)
			return glColorFormatNV(size, static_cast<GLenum>(type), stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorFragmentOp1ATI(enums::FragmentOp1ATI op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod) {
		#if defined(glColorFragmentOp1ATI)
			return glColorFragmentOp1ATI(static_cast<GLenum>(op), dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorFragmentOp1ATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorFragmentOp2ATI(enums::FragmentOp2ATI op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod) {
		#if defined(glColorFragmentOp2ATI)
			return glColorFragmentOp2ATI(static_cast<GLenum>(op), dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorFragmentOp2ATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorFragmentOp3ATI(enums::FragmentOp3ATI op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod) {
		#if defined(glColorFragmentOp3ATI)
			return glColorFragmentOp3ATI(static_cast<GLenum>(op), dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorFragmentOp3ATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
		#if defined(glColorMask)
			return glColorMask(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorMask" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorMaskIndexedEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
		#if defined(glColorMaskIndexedEXT)
			return glColorMaskIndexedEXT(index, r, g, b, a);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorMaskIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
		#if defined(glColorMaski)
			return glColorMaski(index, r, g, b, a);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorMaski" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorMaskiEXT(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
		#if defined(glColorMaskiEXT)
			return glColorMaskiEXT(index, r, g, b, a);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorMaskiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorMaskiOES(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
		#if defined(glColorMaskiOES)
			return glColorMaskiOES(index, r, g, b, a);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorMaskiOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorMaterial(enums::TriangleFace face, enums::ColorMaterialParameter mode) {
		#if defined(glColorMaterial)
			return glColorMaterial(static_cast<GLenum>(face), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorMaterial" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorP3ui(enums::ColorPointerType type, GLuint color) {
		#if defined(glColorP3ui)
			return glColorP3ui(static_cast<GLenum>(type), color);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorP3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorP3uiv(enums::ColorPointerType type, const GLuint* color) {
		#if defined(glColorP3uiv)
			return glColorP3uiv(static_cast<GLenum>(type), color);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorP3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorP4ui(enums::ColorPointerType type, GLuint color) {
		#if defined(glColorP4ui)
			return glColorP4ui(static_cast<GLenum>(type), color);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorP4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorP4uiv(enums::ColorPointerType type, const GLuint* color) {
		#if defined(glColorP4uiv)
			return glColorP4uiv(static_cast<GLenum>(type), color);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorP4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorPointer(GLint size, enums::ColorPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glColorPointer)
			return glColorPointer(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorPointerEXT(GLint size, enums::ColorPointerType type, GLsizei stride, GLsizei count, const void * pointer) {
		#if defined(glColorPointerEXT)
			return glColorPointerEXT(size, static_cast<GLenum>(type), stride, count, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorPointerListIBM(GLint size, enums::ColorPointerType type, GLint stride, const void ** pointer, GLint ptrstride) {
		#if defined(glColorPointerListIBM)
			return glColorPointerListIBM(size, static_cast<GLenum>(type), stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorPointervINTEL(GLint size, enums::VertexPointerType type, const void ** pointer) {
		#if defined(glColorPointervINTEL)
			return glColorPointervINTEL(size, static_cast<GLenum>(type), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorPointervINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorSubTable(enums::ColorTableTarget target, GLsizei start, GLsizei count, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glColorSubTable)
			return glColorSubTable(static_cast<GLenum>(target), start, count, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorSubTable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorSubTableEXT(enums::ColorTableTarget target, GLsizei start, GLsizei count, enums::PixelFormat format, enums::PixelType type, const void * data) {
		#if defined(glColorSubTableEXT)
			return glColorSubTableEXT(static_cast<GLenum>(target), start, count, static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorSubTableEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorTable(enums::ColorTableTarget target, enums::InternalFormat internalformat, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * table) {
		#if defined(glColorTable)
			return glColorTable(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorTable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorTableEXT(enums::ColorTableTarget target, enums::InternalFormat internalFormat, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * table) {
		#if defined(glColorTableEXT)
			return glColorTableEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalFormat), width, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorTableEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorTableParameterfv(enums::ColorTableTarget target, enums::ColorTableParameterPName pname, const GLfloat* params) {
		#if defined(glColorTableParameterfv)
			return glColorTableParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorTableParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorTableParameterfvSGI(enums::ColorTableTargetSGI target, enums::ColorTableParameterPName pname, const GLfloat* params) {
		#if defined(glColorTableParameterfvSGI)
			return glColorTableParameterfvSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorTableParameterfvSGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorTableParameteriv(enums::ColorTableTarget target, enums::ColorTableParameterPName pname, const GLint* params) {
		#if defined(glColorTableParameteriv)
			return glColorTableParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorTableParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorTableParameterivSGI(enums::ColorTableTargetSGI target, enums::ColorTableParameterPName pname, const GLint* params) {
		#if defined(glColorTableParameterivSGI)
			return glColorTableParameterivSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorTableParameterivSGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void colorTableSGI(enums::ColorTableTargetSGI target, enums::InternalFormat internalformat, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * table) {
		#if defined(glColorTableSGI)
			return glColorTableSGI(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, static_cast<GLenum>(format), static_cast<GLenum>(type), table);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glColorTableSGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void combinerInputNV(enums::CombinerStageNV stage, enums::CombinerPortionNV portion, enums::CombinerVariableNV variable, enums::CombinerRegisterNV input, enums::CombinerMappingNV mapping, enums::CombinerComponentUsageNV componentUsage) {
		#if defined(glCombinerInputNV)
			return glCombinerInputNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(variable), static_cast<GLenum>(input), static_cast<GLenum>(mapping), static_cast<GLenum>(componentUsage));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCombinerInputNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void combinerOutputNV(enums::CombinerStageNV stage, enums::CombinerPortionNV portion, enums::CombinerRegisterNV abOutput, enums::CombinerRegisterNV cdOutput, enums::CombinerRegisterNV sumOutput, enums::CombinerScaleNV scale, enums::CombinerBiasNV bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum) {
		#if defined(glCombinerOutputNV)
			return glCombinerOutputNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(abOutput), static_cast<GLenum>(cdOutput), static_cast<GLenum>(sumOutput), static_cast<GLenum>(scale), static_cast<GLenum>(bias), abDotProduct, cdDotProduct, muxSum);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCombinerOutputNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void combinerParameterfNV(enums::CombinerParameterNV pname, GLfloat param) {
		#if defined(glCombinerParameterfNV)
			return glCombinerParameterfNV(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCombinerParameterfNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void combinerParameterfvNV(enums::CombinerParameterNV pname, const GLfloat* params) {
		#if defined(glCombinerParameterfvNV)
			return glCombinerParameterfvNV(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCombinerParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void combinerParameteriNV(enums::CombinerParameterNV pname, GLint param) {
		#if defined(glCombinerParameteriNV)
			return glCombinerParameteriNV(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCombinerParameteriNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void combinerParameterivNV(enums::CombinerParameterNV pname, const GLint* params) {
		#if defined(glCombinerParameterivNV)
			return glCombinerParameterivNV(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCombinerParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void combinerStageParameterfvNV(enums::CombinerStageNV stage, enums::CombinerParameterNV pname, const GLfloat* params) {
		#if defined(glCombinerStageParameterfvNV)
			return glCombinerStageParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCombinerStageParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void commandListSegmentsNV(GLuint list, GLuint segments) {
		#if defined(glCommandListSegmentsNV)
			return glCommandListSegmentsNV(list, segments);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCommandListSegmentsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compileCommandListNV(GLuint list) {
		#if defined(glCompileCommandListNV)
			return glCompileCommandListNV(list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompileCommandListNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compileShader(GLuint shader) {
		#if defined(glCompileShader)
			return glCompileShader(shader);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompileShader" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compileShaderARB(GLhandleARB shaderObj) {
		#if defined(glCompileShaderARB)
			return glCompileShaderARB(shaderObj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompileShaderARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar*const* path, const GLint* length) {
		#if defined(glCompileShaderIncludeARB)
			return glCompileShaderIncludeARB(shader, count, path, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompileShaderIncludeARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedMultiTexImage1DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedMultiTexImage1DEXT)
			return glCompressedMultiTexImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, border, imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedMultiTexImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedMultiTexImage2DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedMultiTexImage2DEXT)
			return glCompressedMultiTexImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, border, imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedMultiTexImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedMultiTexImage3DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedMultiTexImage3DEXT)
			return glCompressedMultiTexImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedMultiTexImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedMultiTexSubImage1DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::InternalFormat format, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedMultiTexSubImage1DEXT)
			return glCompressedMultiTexSubImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedMultiTexSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedMultiTexSubImage2DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::InternalFormat format, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedMultiTexSubImage2DEXT)
			return glCompressedMultiTexSubImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedMultiTexSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedMultiTexSubImage3DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::InternalFormat format, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedMultiTexSubImage3DEXT)
			return glCompressedMultiTexSubImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedMultiTexSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexImage1D(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexImage1D)
			return glCompressedTexImage1D(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, border, imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexImage1DARB(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexImage1DARB)
			return glCompressedTexImage1DARB(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, border, imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexImage1DARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexImage2D(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexImage2D)
			return glCompressedTexImage2D(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, border, imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexImage2DARB(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexImage2DARB)
			return glCompressedTexImage2DARB(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, border, imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexImage2DARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexImage3D(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexImage3D)
			return glCompressedTexImage3D(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexImage3DARB(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexImage3DARB)
			return glCompressedTexImage3DARB(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexImage3DARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexImage3DOES(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexImage3DOES)
			return glCompressedTexImage3DOES(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexImage3DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexSubImage1D(enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexSubImage1D)
			return glCompressedTexSubImage1D(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexSubImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexSubImage1DARB(enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexSubImage1DARB)
			return glCompressedTexSubImage1DARB(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexSubImage1DARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexSubImage2D(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexSubImage2D)
			return glCompressedTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexSubImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexSubImage2DARB(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexSubImage2DARB)
			return glCompressedTexSubImage2DARB(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexSubImage2DARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexSubImage3D(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexSubImage3D)
			return glCompressedTexSubImage3D(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexSubImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexSubImage3DARB(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexSubImage3DARB)
			return glCompressedTexSubImage3DARB(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexSubImage3DARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTexSubImage3DOES(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTexSubImage3DOES)
			return glCompressedTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTexSubImage3DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureImage1DEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLint border, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedTextureImage1DEXT)
			return glCompressedTextureImage1DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, border, imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureImage2DEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedTextureImage2DEXT)
			return glCompressedTextureImage2DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, border, imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureImage3DEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedTextureImage3DEXT)
			return glCompressedTextureImage3DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTextureSubImage1D)
			return glCompressedTextureSubImage1D(texture, level, xoffset, width, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureSubImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureSubImage1DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::InternalFormat format, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedTextureSubImage1DEXT)
			return glCompressedTextureSubImage1DEXT(texture, static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTextureSubImage2D)
			return glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureSubImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureSubImage2DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::InternalFormat format, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedTextureSubImage2DEXT)
			return glCompressedTextureSubImage2DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::InternalFormat format, GLsizei imageSize, const void * data) {
		#if defined(glCompressedTextureSubImage3D)
			return glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureSubImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void compressedTextureSubImage3DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::InternalFormat format, GLsizei imageSize, const void * bits) {
		#if defined(glCompressedTextureSubImage3DEXT)
			return glCompressedTextureSubImage3DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), imageSize, bits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCompressedTextureSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void conservativeRasterParameterfNV(GLenum pname, GLfloat value) {
		#if defined(glConservativeRasterParameterfNV)
			return glConservativeRasterParameterfNV(pname, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConservativeRasterParameterfNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void conservativeRasterParameteriNV(GLenum pname, GLint param) {
		#if defined(glConservativeRasterParameteriNV)
			return glConservativeRasterParameteriNV(pname, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConservativeRasterParameteriNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionFilter1D(enums::ConvolutionTarget target, enums::InternalFormat internalformat, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * image) {
		#if defined(glConvolutionFilter1D)
			return glConvolutionFilter1D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionFilter1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionFilter1DEXT(enums::ConvolutionTargetEXT target, enums::InternalFormat internalformat, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * image) {
		#if defined(glConvolutionFilter1DEXT)
			return glConvolutionFilter1DEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionFilter1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionFilter2D(enums::ConvolutionTarget target, enums::InternalFormat internalformat, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * image) {
		#if defined(glConvolutionFilter2D)
			return glConvolutionFilter2D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionFilter2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionFilter2DEXT(enums::ConvolutionTargetEXT target, enums::InternalFormat internalformat, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * image) {
		#if defined(glConvolutionFilter2DEXT)
			return glConvolutionFilter2DEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionFilter2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameterf(enums::ConvolutionTarget target, enums::ConvolutionParameter pname, GLfloat params) {
		#if defined(glConvolutionParameterf)
			return glConvolutionParameterf(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameterf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameterfEXT(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, GLfloat params) {
		#if defined(glConvolutionParameterfEXT)
			return glConvolutionParameterfEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameterfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameterfv(enums::ConvolutionTarget target, enums::ConvolutionParameter pname, const GLfloat* params) {
		#if defined(glConvolutionParameterfv)
			return glConvolutionParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameterfvEXT(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, const GLfloat* params) {
		#if defined(glConvolutionParameterfvEXT)
			return glConvolutionParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameteri(enums::ConvolutionTarget target, enums::ConvolutionParameter pname, GLint params) {
		#if defined(glConvolutionParameteri)
			return glConvolutionParameteri(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameteriEXT(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, GLint params) {
		#if defined(glConvolutionParameteriEXT)
			return glConvolutionParameteriEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameteriEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameteriv(enums::ConvolutionTarget target, enums::ConvolutionParameter pname, const GLint* params) {
		#if defined(glConvolutionParameteriv)
			return glConvolutionParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameterivEXT(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, const GLint* params) {
		#if defined(glConvolutionParameterivEXT)
			return glConvolutionParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameterxOES(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, GLfixed param) {
		#if defined(glConvolutionParameterxOES)
			return glConvolutionParameterxOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameterxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void convolutionParameterxvOES(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, const GLfixed* params) {
		#if defined(glConvolutionParameterxvOES)
			return glConvolutionParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glConvolutionParameterxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyBufferSubData(enums::CopyBufferSubDataTarget readTarget, enums::CopyBufferSubDataTarget writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
		#if defined(glCopyBufferSubData)
			return glCopyBufferSubData(static_cast<GLenum>(readTarget), static_cast<GLenum>(writeTarget), readOffset, writeOffset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyBufferSubDataNV(enums::CopyBufferSubDataTarget readTarget, enums::CopyBufferSubDataTarget writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
		#if defined(glCopyBufferSubDataNV)
			return glCopyBufferSubDataNV(static_cast<GLenum>(readTarget), static_cast<GLenum>(writeTarget), readOffset, writeOffset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyBufferSubDataNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyColorSubTable(enums::ColorTableTarget target, GLsizei start, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyColorSubTable)
			return glCopyColorSubTable(static_cast<GLenum>(target), start, x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyColorSubTable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyColorSubTableEXT(enums::ColorTableTarget target, GLsizei start, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyColorSubTableEXT)
			return glCopyColorSubTableEXT(static_cast<GLenum>(target), start, x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyColorSubTableEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyColorTable(enums::ColorTableTarget target, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyColorTable)
			return glCopyColorTable(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyColorTable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyColorTableSGI(enums::ColorTableTargetSGI target, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyColorTableSGI)
			return glCopyColorTableSGI(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyColorTableSGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyConvolutionFilter1D(enums::ConvolutionTarget target, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyConvolutionFilter1D)
			return glCopyConvolutionFilter1D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyConvolutionFilter1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyConvolutionFilter1DEXT(enums::ConvolutionTargetEXT target, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyConvolutionFilter1DEXT)
			return glCopyConvolutionFilter1DEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyConvolutionFilter1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyConvolutionFilter2D(enums::ConvolutionTarget target, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyConvolutionFilter2D)
			return glCopyConvolutionFilter2D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyConvolutionFilter2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyConvolutionFilter2DEXT(enums::ConvolutionTargetEXT target, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyConvolutionFilter2DEXT)
			return glCopyConvolutionFilter2DEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyConvolutionFilter2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyImageSubData(GLuint srcName, enums::CopyImageSubDataTarget srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, enums::CopyImageSubDataTarget dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
		#if defined(glCopyImageSubData)
			return glCopyImageSubData(srcName, static_cast<GLenum>(srcTarget), srcLevel, srcX, srcY, srcZ, dstName, static_cast<GLenum>(dstTarget), dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyImageSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyImageSubDataEXT(GLuint srcName, enums::CopyBufferSubDataTarget srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, enums::CopyBufferSubDataTarget dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
		#if defined(glCopyImageSubDataEXT)
			return glCopyImageSubDataEXT(srcName, static_cast<GLenum>(srcTarget), srcLevel, srcX, srcY, srcZ, dstName, static_cast<GLenum>(dstTarget), dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyImageSubDataEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyImageSubDataNV(GLuint srcName, enums::CopyBufferSubDataTarget srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, enums::CopyBufferSubDataTarget dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
		#if defined(glCopyImageSubDataNV)
			return glCopyImageSubDataNV(srcName, static_cast<GLenum>(srcTarget), srcLevel, srcX, srcY, srcZ, dstName, static_cast<GLenum>(dstTarget), dstLevel, dstX, dstY, dstZ, width, height, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyImageSubDataNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyImageSubDataOES(GLuint srcName, enums::CopyBufferSubDataTarget srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, enums::CopyBufferSubDataTarget dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
		#if defined(glCopyImageSubDataOES)
			return glCopyImageSubDataOES(srcName, static_cast<GLenum>(srcTarget), srcLevel, srcX, srcY, srcZ, dstName, static_cast<GLenum>(dstTarget), dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyImageSubDataOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyMultiTexImage1DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLint border) {
		#if defined(glCopyMultiTexImage1DEXT)
			return glCopyMultiTexImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyMultiTexImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyMultiTexImage2DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
		#if defined(glCopyMultiTexImage2DEXT)
			return glCopyMultiTexImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, height, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyMultiTexImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyMultiTexSubImage1DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyMultiTexSubImage1DEXT)
			return glCopyMultiTexSubImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyMultiTexSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyMultiTexSubImage2DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyMultiTexSubImage2DEXT)
			return glCopyMultiTexSubImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyMultiTexSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyMultiTexSubImage3DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyMultiTexSubImage3DEXT)
			return glCopyMultiTexSubImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyMultiTexSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
		#if defined(glCopyNamedBufferSubData)
			return glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyNamedBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyPathNV(GLuint resultPath, GLuint srcPath) {
		#if defined(glCopyPathNV)
			return glCopyPathNV(resultPath, srcPath);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyPixels(GLint x, GLint y, GLsizei width, GLsizei height, enums::PixelCopyType type) {
		#if defined(glCopyPixels)
			return glCopyPixels(x, y, width, height, static_cast<GLenum>(type));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyPixels" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexImage1D(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLint border) {
		#if defined(glCopyTexImage1D)
			return glCopyTexImage1D(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexImage1DEXT(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLint border) {
		#if defined(glCopyTexImage1DEXT)
			return glCopyTexImage1DEXT(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexImage2D(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
		#if defined(glCopyTexImage2D)
			return glCopyTexImage2D(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, height, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexImage2DEXT(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
		#if defined(glCopyTexImage2DEXT)
			return glCopyTexImage2DEXT(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, height, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexSubImage1D(enums::TextureTarget target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyTexSubImage1D)
			return glCopyTexSubImage1D(static_cast<GLenum>(target), level, xoffset, x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexSubImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexSubImage1DEXT(enums::TextureTarget target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyTexSubImage1DEXT)
			return glCopyTexSubImage1DEXT(static_cast<GLenum>(target), level, xoffset, x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexSubImage2D(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTexSubImage2D)
			return glCopyTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexSubImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexSubImage2DEXT(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTexSubImage2DEXT)
			return glCopyTexSubImage2DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexSubImage3D(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTexSubImage3D)
			return glCopyTexSubImage3D(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexSubImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexSubImage3DEXT(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTexSubImage3DEXT)
			return glCopyTexSubImage3DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTexSubImage3DOES)
			return glCopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTexSubImage3DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureImage1DEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLint border) {
		#if defined(glCopyTextureImage1DEXT)
			return glCopyTextureImage1DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureImage2DEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
		#if defined(glCopyTextureImage2DEXT)
			return glCopyTextureImage2DEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), x, y, width, height, border);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount) {
		#if defined(glCopyTextureLevelsAPPLE)
			return glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureLevelsAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyTextureSubImage1D)
			return glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureSubImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureSubImage1DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
		#if defined(glCopyTextureSubImage1DEXT)
			return glCopyTextureSubImage1DEXT(texture, static_cast<GLenum>(target), level, xoffset, x, y, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTextureSubImage2D)
			return glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureSubImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureSubImage2DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTextureSubImage2DEXT)
			return glCopyTextureSubImage2DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTextureSubImage3D)
			return glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureSubImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void copyTextureSubImage3DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glCopyTextureSubImage3DEXT)
			return glCopyTextureSubImage3DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCopyTextureSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverFillPathInstancedNV(GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, enums::InstancedPathCoverMode coverMode, enums::PathTransformType transformType, const GLfloat* transformValues) {
		#if defined(glCoverFillPathInstancedNV)
			return glCoverFillPathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, static_cast<GLenum>(coverMode), static_cast<GLenum>(transformType), transformValues);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverFillPathInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverFillPathNV(GLuint path, enums::PathCoverMode coverMode) {
		#if defined(glCoverFillPathNV)
			return glCoverFillPathNV(path, static_cast<GLenum>(coverMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverFillPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverStrokePathInstancedNV(GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, enums::InstancedPathCoverMode coverMode, enums::PathTransformType transformType, const GLfloat* transformValues) {
		#if defined(glCoverStrokePathInstancedNV)
			return glCoverStrokePathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, static_cast<GLenum>(coverMode), static_cast<GLenum>(transformType), transformValues);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverStrokePathInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverStrokePathNV(GLuint path, enums::PathCoverMode coverMode) {
		#if defined(glCoverStrokePathNV)
			return glCoverStrokePathNV(path, static_cast<GLenum>(coverMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverStrokePathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverageMaskNV(GLboolean mask) {
		#if defined(glCoverageMaskNV)
			return glCoverageMaskNV(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverageMaskNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverageModulationNV(GLenum components) {
		#if defined(glCoverageModulationNV)
			return glCoverageModulationNV(components);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverageModulationNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverageModulationTableNV(GLsizei n, const GLfloat* v) {
		#if defined(glCoverageModulationTableNV)
			return glCoverageModulationTableNV(n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverageModulationTableNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void coverageOperationNV(GLenum operation) {
		#if defined(glCoverageOperationNV)
			return glCoverageOperationNV(operation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCoverageOperationNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createBuffers(GLsizei n, GLuint* buffers) {
		#if defined(glCreateBuffers)
			return glCreateBuffers(n, buffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateBuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createCommandListsNV(GLsizei n, GLuint* lists) {
		#if defined(glCreateCommandListsNV)
			return glCreateCommandListsNV(n, lists);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateCommandListsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createFramebuffers(GLsizei n, GLuint* framebuffers) {
		#if defined(glCreateFramebuffers)
			return glCreateFramebuffers(n, framebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateFramebuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createMemoryObjectsEXT(GLsizei n, GLuint* memoryObjects) {
		#if defined(glCreateMemoryObjectsEXT)
			return glCreateMemoryObjectsEXT(n, memoryObjects);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateMemoryObjectsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createPerfQueryINTEL(GLuint queryId, GLuint* queryHandle) {
		#if defined(glCreatePerfQueryINTEL)
			return glCreatePerfQueryINTEL(queryId, queryHandle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreatePerfQueryINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint createProgram() {
		#if defined(glCreateProgram)
			return glCreateProgram();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateProgram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLhandleARB createProgramObjectARB() {
		#if defined(glCreateProgramObjectARB)
			return glCreateProgramObjectARB();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateProgramObjectARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void createProgramPipelines(GLsizei n, GLuint* pipelines) {
		#if defined(glCreateProgramPipelines)
			return glCreateProgramPipelines(n, pipelines);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateProgramPipelines" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint createProgressFenceNVX() {
		#if defined(glCreateProgressFenceNVX)
			return glCreateProgressFenceNVX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateProgressFenceNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void createQueries(enums::QueryTarget target, GLsizei n, GLuint* ids) {
		#if defined(glCreateQueries)
			return glCreateQueries(static_cast<GLenum>(target), n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateQueries" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createRenderbuffers(GLsizei n, GLuint* renderbuffers) {
		#if defined(glCreateRenderbuffers)
			return glCreateRenderbuffers(n, renderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateRenderbuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createSamplers(GLsizei n, GLuint* samplers) {
		#if defined(glCreateSamplers)
			return glCreateSamplers(n, samplers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateSamplers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createSemaphoresNV(GLsizei n, GLuint* semaphores) {
		#if defined(glCreateSemaphoresNV)
			return glCreateSemaphoresNV(n, semaphores);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateSemaphoresNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint createShader(enums::ShaderType type) {
		#if defined(glCreateShader)
			return glCreateShader(static_cast<GLenum>(type));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateShader" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLhandleARB createShaderObjectARB(enums::ShaderType shaderType) {
		#if defined(glCreateShaderObjectARB)
			return glCreateShaderObjectARB(static_cast<GLenum>(shaderType));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateShaderObjectARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint createShaderProgramEXT(enums::ShaderType type, const GLchar* string) {
		#if defined(glCreateShaderProgramEXT)
			return glCreateShaderProgramEXT(static_cast<GLenum>(type), string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateShaderProgramEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint createShaderProgramv(enums::ShaderType type, GLsizei count, const GLchar*const* strings) {
		#if defined(glCreateShaderProgramv)
			return glCreateShaderProgramv(static_cast<GLenum>(type), count, strings);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateShaderProgramv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint createShaderProgramvEXT(enums::ShaderType type, GLsizei count, const GLchar*const* strings) {
		#if defined(glCreateShaderProgramvEXT)
			return glCreateShaderProgramvEXT(static_cast<GLenum>(type), count, strings);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateShaderProgramvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void createStatesNV(GLsizei n, GLuint* states) {
		#if defined(glCreateStatesNV)
			return glCreateStatesNV(n, states);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateStatesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLsync createSyncFromCLeventARB(struct _cl_context* context, struct _cl_event* event, GLbitfield flags) {
		#if defined(glCreateSyncFromCLeventARB)
			return glCreateSyncFromCLeventARB(context, event, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateSyncFromCLeventARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void createTextures(enums::TextureTarget target, GLsizei n, GLuint* textures) {
		#if defined(glCreateTextures)
			return glCreateTextures(static_cast<GLenum>(target), n, textures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateTextures" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createTransformFeedbacks(GLsizei n, GLuint* ids) {
		#if defined(glCreateTransformFeedbacks)
			return glCreateTransformFeedbacks(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateTransformFeedbacks" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void createVertexArrays(GLsizei n, GLuint* arrays) {
		#if defined(glCreateVertexArrays)
			return glCreateVertexArrays(n, arrays);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCreateVertexArrays" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void cullFace(enums::TriangleFace mode) {
		#if defined(glCullFace)
			return glCullFace(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCullFace" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void cullParameterdvEXT(enums::CullParameterEXT pname, GLdouble* params) {
		#if defined(glCullParameterdvEXT)
			return glCullParameterdvEXT(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCullParameterdvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void cullParameterfvEXT(enums::CullParameterEXT pname, GLfloat* params) {
		#if defined(glCullParameterfvEXT)
			return glCullParameterfvEXT(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCullParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void currentPaletteMatrixARB(GLint index) {
		#if defined(glCurrentPaletteMatrixARB)
			return glCurrentPaletteMatrixARB(index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCurrentPaletteMatrixARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void currentPaletteMatrixOES(GLuint matrixpaletteindex) {
		#if defined(glCurrentPaletteMatrixOES)
			return glCurrentPaletteMatrixOES(matrixpaletteindex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glCurrentPaletteMatrixOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageCallback(GLDEBUGPROC callback, const void * userParam) {
		#if defined(glDebugMessageCallback)
			return glDebugMessageCallback(callback, userParam);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageCallback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageCallbackAMD(GLDEBUGPROCAMD callback, void * userParam) {
		#if defined(glDebugMessageCallbackAMD)
			return glDebugMessageCallbackAMD(callback, userParam);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageCallbackAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageCallbackARB(GLDEBUGPROCARB callback, const void * userParam) {
		#if defined(glDebugMessageCallbackARB)
			return glDebugMessageCallbackARB(callback, userParam);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageCallbackARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageCallbackKHR(GLDEBUGPROCKHR callback, const void * userParam) {
		#if defined(glDebugMessageCallbackKHR)
			return glDebugMessageCallbackKHR(callback, userParam);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageCallbackKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageControl(enums::DebugSource source, enums::DebugType type, enums::DebugSeverity severity, GLsizei count, const GLuint* ids, GLboolean enabled) {
		#if defined(glDebugMessageControl)
			return glDebugMessageControl(static_cast<GLenum>(source), static_cast<GLenum>(type), static_cast<GLenum>(severity), count, ids, enabled);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageControl" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageControlARB(enums::DebugSource source, enums::DebugType type, enums::DebugSeverity severity, GLsizei count, const GLuint* ids, GLboolean enabled) {
		#if defined(glDebugMessageControlARB)
			return glDebugMessageControlARB(static_cast<GLenum>(source), static_cast<GLenum>(type), static_cast<GLenum>(severity), count, ids, enabled);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageControlARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageControlKHR(enums::DebugSource source, enums::DebugType type, enums::DebugSeverity severity, GLsizei count, const GLuint* ids, GLboolean enabled) {
		#if defined(glDebugMessageControlKHR)
			return glDebugMessageControlKHR(static_cast<GLenum>(source), static_cast<GLenum>(type), static_cast<GLenum>(severity), count, ids, enabled);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageControlKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageEnableAMD(GLenum category, enums::DebugSeverity severity, GLsizei count, const GLuint* ids, GLboolean enabled) {
		#if defined(glDebugMessageEnableAMD)
			return glDebugMessageEnableAMD(category, static_cast<GLenum>(severity), count, ids, enabled);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageEnableAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageInsert(enums::DebugSource source, enums::DebugType type, GLuint id, enums::DebugSeverity severity, GLsizei length, const GLchar* buf) {
		#if defined(glDebugMessageInsert)
			return glDebugMessageInsert(static_cast<GLenum>(source), static_cast<GLenum>(type), id, static_cast<GLenum>(severity), length, buf);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageInsert" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageInsertAMD(GLenum category, enums::DebugSeverity severity, GLuint id, GLsizei length, const GLchar* buf) {
		#if defined(glDebugMessageInsertAMD)
			return glDebugMessageInsertAMD(category, static_cast<GLenum>(severity), id, length, buf);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageInsertAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageInsertARB(enums::DebugSource source, enums::DebugType type, GLuint id, enums::DebugSeverity severity, GLsizei length, const GLchar* buf) {
		#if defined(glDebugMessageInsertARB)
			return glDebugMessageInsertARB(static_cast<GLenum>(source), static_cast<GLenum>(type), id, static_cast<GLenum>(severity), length, buf);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageInsertARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void debugMessageInsertKHR(enums::DebugSource source, enums::DebugType type, GLuint id, enums::DebugSeverity severity, GLsizei length, const GLchar* buf) {
		#if defined(glDebugMessageInsertKHR)
			return glDebugMessageInsertKHR(static_cast<GLenum>(source), static_cast<GLenum>(type), id, static_cast<GLenum>(severity), length, buf);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDebugMessageInsertKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deformSGIX(GLbitfield mask) {
		#if defined(glDeformSGIX)
			return glDeformSGIX(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeformSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deformationMap3dSGIX(enums::FfdTargetSGIX target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble* points) {
		#if defined(glDeformationMap3dSGIX)
			return glDeformationMap3dSGIX(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeformationMap3dSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deformationMap3fSGIX(enums::FfdTargetSGIX target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat* points) {
		#if defined(glDeformationMap3fSGIX)
			return glDeformationMap3fSGIX(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeformationMap3fSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteAsyncMarkersSGIX(GLuint marker, GLsizei range) {
		#if defined(glDeleteAsyncMarkersSGIX)
			return glDeleteAsyncMarkersSGIX(marker, range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteAsyncMarkersSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteBuffers(GLsizei n, const GLuint* buffers) {
		#if defined(glDeleteBuffers)
			return glDeleteBuffers(n, buffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteBuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteBuffersARB(GLsizei n, const GLuint* buffers) {
		#if defined(glDeleteBuffersARB)
			return glDeleteBuffersARB(n, buffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteBuffersARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteCommandListsNV(GLsizei n, const GLuint* lists) {
		#if defined(glDeleteCommandListsNV)
			return glDeleteCommandListsNV(n, lists);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteCommandListsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteFencesAPPLE(GLsizei n, const GLuint* fences) {
		#if defined(glDeleteFencesAPPLE)
			return glDeleteFencesAPPLE(n, fences);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteFencesAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteFencesNV(GLsizei n, const GLuint* fences) {
		#if defined(glDeleteFencesNV)
			return glDeleteFencesNV(n, fences);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteFencesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteFragmentShaderATI(GLuint id) {
		#if defined(glDeleteFragmentShaderATI)
			return glDeleteFragmentShaderATI(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteFragmentShaderATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteFramebuffers(GLsizei n, const GLuint* framebuffers) {
		#if defined(glDeleteFramebuffers)
			return glDeleteFramebuffers(n, framebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteFramebuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteFramebuffersEXT(GLsizei n, const GLuint* framebuffers) {
		#if defined(glDeleteFramebuffersEXT)
			return glDeleteFramebuffersEXT(n, framebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteFramebuffersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteFramebuffersOES(GLsizei n, const GLuint* framebuffers) {
		#if defined(glDeleteFramebuffersOES)
			return glDeleteFramebuffersOES(n, framebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteFramebuffersOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteLists(GLuint list, GLsizei range) {
		#if defined(glDeleteLists)
			return glDeleteLists(list, range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteLists" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteMemoryObjectsEXT(GLsizei n, const GLuint* memoryObjects) {
		#if defined(glDeleteMemoryObjectsEXT)
			return glDeleteMemoryObjectsEXT(n, memoryObjects);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteMemoryObjectsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteNamedStringARB(GLint namelen, const GLchar* name) {
		#if defined(glDeleteNamedStringARB)
			return glDeleteNamedStringARB(namelen, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteNamedStringARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteNamesAMD(GLenum identifier, GLuint num, const GLuint* names) {
		#if defined(glDeleteNamesAMD)
			return glDeleteNamesAMD(identifier, num, names);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteNamesAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteObjectARB(GLhandleARB obj) {
		#if defined(glDeleteObjectARB)
			return glDeleteObjectARB(obj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteObjectARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteOcclusionQueriesNV(GLsizei n, const GLuint* ids) {
		#if defined(glDeleteOcclusionQueriesNV)
			return glDeleteOcclusionQueriesNV(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteOcclusionQueriesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deletePathsNV(GLuint path, GLsizei range) {
		#if defined(glDeletePathsNV)
			return glDeletePathsNV(path, range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeletePathsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deletePerfMonitorsAMD(GLsizei n, GLuint* monitors) {
		#if defined(glDeletePerfMonitorsAMD)
			return glDeletePerfMonitorsAMD(n, monitors);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeletePerfMonitorsAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deletePerfQueryINTEL(GLuint queryHandle) {
		#if defined(glDeletePerfQueryINTEL)
			return glDeletePerfQueryINTEL(queryHandle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeletePerfQueryINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteProgram(GLuint program) {
		#if defined(glDeleteProgram)
			return glDeleteProgram(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteProgram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteProgramPipelines(GLsizei n, const GLuint* pipelines) {
		#if defined(glDeleteProgramPipelines)
			return glDeleteProgramPipelines(n, pipelines);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteProgramPipelines" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteProgramPipelinesEXT(GLsizei n, const GLuint* pipelines) {
		#if defined(glDeleteProgramPipelinesEXT)
			return glDeleteProgramPipelinesEXT(n, pipelines);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteProgramPipelinesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteProgramsARB(GLsizei n, const GLuint* programs) {
		#if defined(glDeleteProgramsARB)
			return glDeleteProgramsARB(n, programs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteProgramsARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteProgramsNV(GLsizei n, const GLuint* programs) {
		#if defined(glDeleteProgramsNV)
			return glDeleteProgramsNV(n, programs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteProgramsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteQueries(GLsizei n, const GLuint* ids) {
		#if defined(glDeleteQueries)
			return glDeleteQueries(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteQueries" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteQueriesARB(GLsizei n, const GLuint* ids) {
		#if defined(glDeleteQueriesARB)
			return glDeleteQueriesARB(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteQueriesARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteQueriesEXT(GLsizei n, const GLuint* ids) {
		#if defined(glDeleteQueriesEXT)
			return glDeleteQueriesEXT(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteQueriesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteQueryResourceTagNV(GLsizei n, const GLint* tagIds) {
		#if defined(glDeleteQueryResourceTagNV)
			return glDeleteQueryResourceTagNV(n, tagIds);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteQueryResourceTagNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteRenderbuffers(GLsizei n, const GLuint* renderbuffers) {
		#if defined(glDeleteRenderbuffers)
			return glDeleteRenderbuffers(n, renderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteRenderbuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteRenderbuffersEXT(GLsizei n, const GLuint* renderbuffers) {
		#if defined(glDeleteRenderbuffersEXT)
			return glDeleteRenderbuffersEXT(n, renderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteRenderbuffersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteRenderbuffersOES(GLsizei n, const GLuint* renderbuffers) {
		#if defined(glDeleteRenderbuffersOES)
			return glDeleteRenderbuffersOES(n, renderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteRenderbuffersOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteSamplers(GLsizei count, const GLuint* samplers) {
		#if defined(glDeleteSamplers)
			return glDeleteSamplers(count, samplers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteSamplers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteSemaphoresEXT(GLsizei n, const GLuint* semaphores) {
		#if defined(glDeleteSemaphoresEXT)
			return glDeleteSemaphoresEXT(n, semaphores);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteSemaphoresEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteShader(GLuint shader) {
		#if defined(glDeleteShader)
			return glDeleteShader(shader);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteShader" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteStatesNV(GLsizei n, const GLuint* states) {
		#if defined(glDeleteStatesNV)
			return glDeleteStatesNV(n, states);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteStatesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteSync(GLsync sync) {
		#if defined(glDeleteSync)
			return glDeleteSync(sync);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteSync" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteSyncAPPLE(GLsync sync) {
		#if defined(glDeleteSyncAPPLE)
			return glDeleteSyncAPPLE(sync);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteSyncAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteTextures(GLsizei n, const GLuint* textures) {
		#if defined(glDeleteTextures)
			return glDeleteTextures(n, textures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteTextures" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteTexturesEXT(GLsizei n, const GLuint* textures) {
		#if defined(glDeleteTexturesEXT)
			return glDeleteTexturesEXT(n, textures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteTexturesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteTransformFeedbacks(GLsizei n, const GLuint* ids) {
		#if defined(glDeleteTransformFeedbacks)
			return glDeleteTransformFeedbacks(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteTransformFeedbacks" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteTransformFeedbacksNV(GLsizei n, const GLuint* ids) {
		#if defined(glDeleteTransformFeedbacksNV)
			return glDeleteTransformFeedbacksNV(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteTransformFeedbacksNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteVertexArrays(GLsizei n, const GLuint* arrays) {
		#if defined(glDeleteVertexArrays)
			return glDeleteVertexArrays(n, arrays);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteVertexArrays" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteVertexArraysAPPLE(GLsizei n, const GLuint* arrays) {
		#if defined(glDeleteVertexArraysAPPLE)
			return glDeleteVertexArraysAPPLE(n, arrays);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteVertexArraysAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteVertexArraysOES(GLsizei n, const GLuint* arrays) {
		#if defined(glDeleteVertexArraysOES)
			return glDeleteVertexArraysOES(n, arrays);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteVertexArraysOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void deleteVertexShaderEXT(GLuint id) {
		#if defined(glDeleteVertexShaderEXT)
			return glDeleteVertexShaderEXT(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDeleteVertexShaderEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthBoundsEXT(GLclampd zmin, GLclampd zmax) {
		#if defined(glDepthBoundsEXT)
			return glDepthBoundsEXT(zmin, zmax);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthBoundsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthBoundsdNV(GLdouble zmin, GLdouble zmax) {
		#if defined(glDepthBoundsdNV)
			return glDepthBoundsdNV(zmin, zmax);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthBoundsdNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthFunc(enums::DepthFunction func) {
		#if defined(glDepthFunc)
			return glDepthFunc(static_cast<GLenum>(func));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthFunc" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthMask(GLboolean flag) {
		#if defined(glDepthMask)
			return glDepthMask(flag);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthMask" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRange(GLdouble n, GLdouble f) {
		#if defined(glDepthRange)
			return glDepthRange(n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeArraydvNV(GLuint first, GLsizei count, const GLdouble* v) {
		#if defined(glDepthRangeArraydvNV)
			return glDepthRangeArraydvNV(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeArraydvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeArrayfvNV(GLuint first, GLsizei count, const GLfloat* v) {
		#if defined(glDepthRangeArrayfvNV)
			return glDepthRangeArrayfvNV(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeArrayfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeArrayfvOES(GLuint first, GLsizei count, const GLfloat* v) {
		#if defined(glDepthRangeArrayfvOES)
			return glDepthRangeArrayfvOES(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeArrayfvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeArrayv(GLuint first, GLsizei count, const GLdouble* v) {
		#if defined(glDepthRangeArrayv)
			return glDepthRangeArrayv(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeArrayv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeIndexed(GLuint index, GLdouble n, GLdouble f) {
		#if defined(glDepthRangeIndexed)
			return glDepthRangeIndexed(index, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeIndexed" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeIndexeddNV(GLuint index, GLdouble n, GLdouble f) {
		#if defined(glDepthRangeIndexeddNV)
			return glDepthRangeIndexeddNV(index, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeIndexeddNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeIndexedfNV(GLuint index, GLfloat n, GLfloat f) {
		#if defined(glDepthRangeIndexedfNV)
			return glDepthRangeIndexedfNV(index, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeIndexedfNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangeIndexedfOES(GLuint index, GLfloat n, GLfloat f) {
		#if defined(glDepthRangeIndexedfOES)
			return glDepthRangeIndexedfOES(index, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangeIndexedfOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangedNV(GLdouble zNear, GLdouble zFar) {
		#if defined(glDepthRangedNV)
			return glDepthRangedNV(zNear, zFar);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangef(GLfloat n, GLfloat f) {
		#if defined(glDepthRangef)
			return glDepthRangef(n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangef" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangefOES(GLclampf n, GLclampf f) {
		#if defined(glDepthRangefOES)
			return glDepthRangefOES(n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangefOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangex(GLfixed n, GLfixed f) {
		#if defined(glDepthRangex)
			return glDepthRangex(n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void depthRangexOES(GLfixed n, GLfixed f) {
		#if defined(glDepthRangexOES)
			return glDepthRangexOES(n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDepthRangexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void detachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj) {
		#if defined(glDetachObjectARB)
			return glDetachObjectARB(containerObj, attachedObj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDetachObjectARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void detachShader(GLuint program, GLuint shader) {
		#if defined(glDetachShader)
			return glDetachShader(program, shader);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDetachShader" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void detailTexFuncSGIS(enums::TextureTarget target, GLsizei n, const GLfloat* points) {
		#if defined(glDetailTexFuncSGIS)
			return glDetailTexFuncSGIS(static_cast<GLenum>(target), n, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDetailTexFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disable(enums::EnableCap cap) {
		#if defined(glDisable)
			return glDisable(static_cast<GLenum>(cap));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableClientState(enums::EnableCap array) {
		#if defined(glDisableClientState)
			return glDisableClientState(static_cast<GLenum>(array));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableClientState" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableClientStateIndexedEXT(enums::EnableCap array, GLuint index) {
		#if defined(glDisableClientStateIndexedEXT)
			return glDisableClientStateIndexedEXT(static_cast<GLenum>(array), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableClientStateIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableClientStateiEXT(enums::EnableCap array, GLuint index) {
		#if defined(glDisableClientStateiEXT)
			return glDisableClientStateiEXT(static_cast<GLenum>(array), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableClientStateiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableDriverControlQCOM(GLuint driverControl) {
		#if defined(glDisableDriverControlQCOM)
			return glDisableDriverControlQCOM(driverControl);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableDriverControlQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableIndexedEXT(enums::EnableCap target, GLuint index) {
		#if defined(glDisableIndexedEXT)
			return glDisableIndexedEXT(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableVariantClientStateEXT(GLuint id) {
		#if defined(glDisableVariantClientStateEXT)
			return glDisableVariantClientStateEXT(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableVariantClientStateEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableVertexArrayAttrib(GLuint vaobj, GLuint index) {
		#if defined(glDisableVertexArrayAttrib)
			return glDisableVertexArrayAttrib(vaobj, index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableVertexArrayAttrib" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
		#if defined(glDisableVertexArrayAttribEXT)
			return glDisableVertexArrayAttribEXT(vaobj, index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableVertexArrayAttribEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableVertexArrayEXT(GLuint vaobj, enums::EnableCap array) {
		#if defined(glDisableVertexArrayEXT)
			return glDisableVertexArrayEXT(vaobj, static_cast<GLenum>(array));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableVertexArrayEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableVertexAttribAPPLE(GLuint index, GLenum pname) {
		#if defined(glDisableVertexAttribAPPLE)
			return glDisableVertexAttribAPPLE(index, pname);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableVertexAttribAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableVertexAttribArray(GLuint index) {
		#if defined(glDisableVertexAttribArray)
			return glDisableVertexAttribArray(index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableVertexAttribArray" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableVertexAttribArrayARB(GLuint index) {
		#if defined(glDisableVertexAttribArrayARB)
			return glDisableVertexAttribArrayARB(index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableVertexAttribArrayARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disablei(enums::EnableCap target, GLuint index) {
		#if defined(glDisablei)
			return glDisablei(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisablei" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableiEXT(enums::EnableCap target, GLuint index) {
		#if defined(glDisableiEXT)
			return glDisableiEXT(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableiNV(enums::EnableCap target, GLuint index) {
		#if defined(glDisableiNV)
			return glDisableiNV(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableiNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void disableiOES(enums::EnableCap target, GLuint index) {
		#if defined(glDisableiOES)
			return glDisableiOES(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDisableiOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void discardFramebufferEXT(enums::FramebufferTarget target, GLsizei numAttachments, const GLenum* attachments) {
		#if defined(glDiscardFramebufferEXT)
			return glDiscardFramebufferEXT(static_cast<GLenum>(target), numAttachments, attachments);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDiscardFramebufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void dispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
		#if defined(glDispatchCompute)
			return glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDispatchCompute" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void dispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z) {
		#if defined(glDispatchComputeGroupSizeARB)
			return glDispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDispatchComputeGroupSizeARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void dispatchComputeIndirect(GLintptr indirect) {
		#if defined(glDispatchComputeIndirect)
			return glDispatchComputeIndirect(indirect);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDispatchComputeIndirect" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArrays(enums::PrimitiveType mode, GLint first, GLsizei count) {
		#if defined(glDrawArrays)
			return glDrawArrays(static_cast<GLenum>(mode), first, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArrays" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysEXT(enums::PrimitiveType mode, GLint first, GLsizei count) {
		#if defined(glDrawArraysEXT)
			return glDrawArraysEXT(static_cast<GLenum>(mode), first, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysIndirect(enums::PrimitiveType mode, const void * indirect) {
		#if defined(glDrawArraysIndirect)
			return glDrawArraysIndirect(static_cast<GLenum>(mode), indirect);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysIndirect" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysInstanced(enums::PrimitiveType mode, GLint first, GLsizei count, GLsizei instancecount) {
		#if defined(glDrawArraysInstanced)
			return glDrawArraysInstanced(static_cast<GLenum>(mode), first, count, instancecount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysInstanced" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysInstancedANGLE(enums::PrimitiveType mode, GLint first, GLsizei count, GLsizei primcount) {
		#if defined(glDrawArraysInstancedANGLE)
			return glDrawArraysInstancedANGLE(static_cast<GLenum>(mode), first, count, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysInstancedANGLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysInstancedARB(enums::PrimitiveType mode, GLint first, GLsizei count, GLsizei primcount) {
		#if defined(glDrawArraysInstancedARB)
			return glDrawArraysInstancedARB(static_cast<GLenum>(mode), first, count, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysInstancedARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysInstancedBaseInstance(enums::PrimitiveType mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) {
		#if defined(glDrawArraysInstancedBaseInstance)
			return glDrawArraysInstancedBaseInstance(static_cast<GLenum>(mode), first, count, instancecount, baseinstance);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysInstancedBaseInstance" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysInstancedBaseInstanceEXT(enums::PrimitiveType mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) {
		#if defined(glDrawArraysInstancedBaseInstanceEXT)
			return glDrawArraysInstancedBaseInstanceEXT(static_cast<GLenum>(mode), first, count, instancecount, baseinstance);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysInstancedBaseInstanceEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysInstancedEXT(enums::PrimitiveType mode, GLint start, GLsizei count, GLsizei primcount) {
		#if defined(glDrawArraysInstancedEXT)
			return glDrawArraysInstancedEXT(static_cast<GLenum>(mode), start, count, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysInstancedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawArraysInstancedNV(enums::PrimitiveType mode, GLint first, GLsizei count, GLsizei primcount) {
		#if defined(glDrawArraysInstancedNV)
			return glDrawArraysInstancedNV(static_cast<GLenum>(mode), first, count, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawArraysInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawBuffer(enums::DrawBufferMode buf) {
		#if defined(glDrawBuffer)
			return glDrawBuffer(static_cast<GLenum>(buf));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawBuffers(GLsizei n, const GLenum* bufs) {
		#if defined(glDrawBuffers)
			return glDrawBuffers(n, bufs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawBuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawBuffersARB(GLsizei n, const GLenum* bufs) {
		#if defined(glDrawBuffersARB)
			return glDrawBuffersARB(n, bufs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawBuffersARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawBuffersATI(GLsizei n, const GLenum* bufs) {
		#if defined(glDrawBuffersATI)
			return glDrawBuffersATI(n, bufs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawBuffersATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawBuffersEXT(GLsizei n, const GLenum* bufs) {
		#if defined(glDrawBuffersEXT)
			return glDrawBuffersEXT(n, bufs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawBuffersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawBuffersIndexedEXT(GLint n, const GLenum* location, const GLint* indices) {
		#if defined(glDrawBuffersIndexedEXT)
			return glDrawBuffersIndexedEXT(n, location, indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawBuffersIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawBuffersNV(GLsizei n, const GLenum* bufs) {
		#if defined(glDrawBuffersNV)
			return glDrawBuffersNV(n, bufs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawBuffersNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawCommandsAddressNV(GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count) {
		#if defined(glDrawCommandsAddressNV)
			return glDrawCommandsAddressNV(primitiveMode, indirects, sizes, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawCommandsAddressNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawCommandsNV(GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count) {
		#if defined(glDrawCommandsNV)
			return glDrawCommandsNV(primitiveMode, buffer, indirects, sizes, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawCommandsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawCommandsStatesAddressNV(const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) {
		#if defined(glDrawCommandsStatesAddressNV)
			return glDrawCommandsStatesAddressNV(indirects, sizes, states, fbos, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawCommandsStatesAddressNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawCommandsStatesNV(GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) {
		#if defined(glDrawCommandsStatesNV)
			return glDrawCommandsStatesNV(buffer, indirects, sizes, states, fbos, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawCommandsStatesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementArrayAPPLE(enums::PrimitiveType mode, GLint first, GLsizei count) {
		#if defined(glDrawElementArrayAPPLE)
			return glDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementArrayAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementArrayATI(enums::PrimitiveType mode, GLsizei count) {
		#if defined(glDrawElementArrayATI)
			return glDrawElementArrayATI(static_cast<GLenum>(mode), count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementArrayATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElements(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices) {
		#if defined(glDrawElements)
			return glDrawElements(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElements" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsBaseVertex(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLint basevertex) {
		#if defined(glDrawElementsBaseVertex)
			return glDrawElementsBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsBaseVertex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsBaseVertexEXT(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLint basevertex) {
		#if defined(glDrawElementsBaseVertexEXT)
			return glDrawElementsBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsBaseVertexEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsBaseVertexOES(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLint basevertex) {
		#if defined(glDrawElementsBaseVertexOES)
			return glDrawElementsBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsBaseVertexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsIndirect(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect) {
		#if defined(glDrawElementsIndirect)
			return glDrawElementsIndirect(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsIndirect" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstanced(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount) {
		#if defined(glDrawElementsInstanced)
			return glDrawElementsInstanced(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstanced" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedANGLE(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei primcount) {
		#if defined(glDrawElementsInstancedANGLE)
			return glDrawElementsInstancedANGLE(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedANGLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedARB(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei primcount) {
		#if defined(glDrawElementsInstancedARB)
			return glDrawElementsInstancedARB(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedBaseInstance(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount, GLuint baseinstance) {
		#if defined(glDrawElementsInstancedBaseInstance)
			return glDrawElementsInstancedBaseInstance(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, baseinstance);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedBaseInstance" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedBaseInstanceEXT(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount, GLuint baseinstance) {
		#if defined(glDrawElementsInstancedBaseInstanceEXT)
			return glDrawElementsInstancedBaseInstanceEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, baseinstance);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedBaseInstanceEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedBaseVertex(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount, GLint basevertex) {
		#if defined(glDrawElementsInstancedBaseVertex)
			return glDrawElementsInstancedBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedBaseVertex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedBaseVertexBaseInstance(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) {
		#if defined(glDrawElementsInstancedBaseVertexBaseInstance)
			return glDrawElementsInstancedBaseVertexBaseInstance(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex, baseinstance);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedBaseVertexBaseInstance" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedBaseVertexBaseInstanceEXT(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) {
		#if defined(glDrawElementsInstancedBaseVertexBaseInstanceEXT)
			return glDrawElementsInstancedBaseVertexBaseInstanceEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex, baseinstance);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedBaseVertexBaseInstanceEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedBaseVertexEXT(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount, GLint basevertex) {
		#if defined(glDrawElementsInstancedBaseVertexEXT)
			return glDrawElementsInstancedBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedBaseVertexEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedBaseVertexOES(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei instancecount, GLint basevertex) {
		#if defined(glDrawElementsInstancedBaseVertexOES)
			return glDrawElementsInstancedBaseVertexOES(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, instancecount, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedBaseVertexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedEXT(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei primcount) {
		#if defined(glDrawElementsInstancedEXT)
			return glDrawElementsInstancedEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawElementsInstancedNV(enums::PrimitiveType mode, GLsizei count, enums::DrawElementsType type, const void * indices, GLsizei primcount) {
		#if defined(glDrawElementsInstancedNV)
			return glDrawElementsInstancedNV(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawElementsInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawMeshArraysSUN(enums::PrimitiveType mode, GLint first, GLsizei count, GLsizei width) {
		#if defined(glDrawMeshArraysSUN)
			return glDrawMeshArraysSUN(static_cast<GLenum>(mode), first, count, width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawMeshArraysSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawMeshTasksNV(GLuint first, GLuint count) {
		#if defined(glDrawMeshTasksNV)
			return glDrawMeshTasksNV(first, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawMeshTasksNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawMeshTasksIndirectNV(GLintptr indirect) {
		#if defined(glDrawMeshTasksIndirectNV)
			return glDrawMeshTasksIndirectNV(indirect);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawMeshTasksIndirectNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawPixels(GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glDrawPixels)
			return glDrawPixels(width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawPixels" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawRangeElementArrayAPPLE(enums::PrimitiveType mode, GLuint start, GLuint end, GLint first, GLsizei count) {
		#if defined(glDrawRangeElementArrayAPPLE)
			return glDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawRangeElementArrayAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawRangeElementArrayATI(enums::PrimitiveType mode, GLuint start, GLuint end, GLsizei count) {
		#if defined(glDrawRangeElementArrayATI)
			return glDrawRangeElementArrayATI(static_cast<GLenum>(mode), start, end, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawRangeElementArrayATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawRangeElements(enums::PrimitiveType mode, GLuint start, GLuint end, GLsizei count, enums::DrawElementsType type, const void * indices) {
		#if defined(glDrawRangeElements)
			return glDrawRangeElements(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawRangeElements" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawRangeElementsBaseVertex(enums::PrimitiveType mode, GLuint start, GLuint end, GLsizei count, enums::DrawElementsType type, const void * indices, GLint basevertex) {
		#if defined(glDrawRangeElementsBaseVertex)
			return glDrawRangeElementsBaseVertex(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawRangeElementsBaseVertex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawRangeElementsBaseVertexEXT(enums::PrimitiveType mode, GLuint start, GLuint end, GLsizei count, enums::DrawElementsType type, const void * indices, GLint basevertex) {
		#if defined(glDrawRangeElementsBaseVertexEXT)
			return glDrawRangeElementsBaseVertexEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawRangeElementsBaseVertexEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawRangeElementsBaseVertexOES(enums::PrimitiveType mode, GLuint start, GLuint end, GLsizei count, enums::DrawElementsType type, const void * indices, GLint basevertex) {
		#if defined(glDrawRangeElementsBaseVertexOES)
			return glDrawRangeElementsBaseVertexOES(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawRangeElementsBaseVertexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawRangeElementsEXT(enums::PrimitiveType mode, GLuint start, GLuint end, GLsizei count, enums::DrawElementsType type, const void * indices) {
		#if defined(glDrawRangeElementsEXT)
			return glDrawRangeElementsEXT(static_cast<GLenum>(mode), start, end, count, static_cast<GLenum>(type), indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawRangeElementsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexfOES(GLfloat x, GLfloat y, GLfloat z, GLfloat width, GLfloat height) {
		#if defined(glDrawTexfOES)
			return glDrawTexfOES(x, y, z, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexfOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexfvOES(const GLfloat* coords) {
		#if defined(glDrawTexfvOES)
			return glDrawTexfvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexfvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexiOES(GLint x, GLint y, GLint z, GLint width, GLint height) {
		#if defined(glDrawTexiOES)
			return glDrawTexiOES(x, y, z, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexiOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexivOES(const GLint* coords) {
		#if defined(glDrawTexivOES)
			return glDrawTexivOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexsOES(GLshort x, GLshort y, GLshort z, GLshort width, GLshort height) {
		#if defined(glDrawTexsOES)
			return glDrawTexsOES(x, y, z, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexsOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexsvOES(const GLshort* coords) {
		#if defined(glDrawTexsvOES)
			return glDrawTexsvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexsvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) {
		#if defined(glDrawTextureNV)
			return glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTextureNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexxOES(GLfixed x, GLfixed y, GLfixed z, GLfixed width, GLfixed height) {
		#if defined(glDrawTexxOES)
			return glDrawTexxOES(x, y, z, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTexxvOES(const GLfixed* coords) {
		#if defined(glDrawTexxvOES)
			return glDrawTexxvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTexxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTransformFeedback(enums::PrimitiveType mode, GLuint id) {
		#if defined(glDrawTransformFeedback)
			return glDrawTransformFeedback(static_cast<GLenum>(mode), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTransformFeedback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTransformFeedbackEXT(enums::PrimitiveType mode, GLuint id) {
		#if defined(glDrawTransformFeedbackEXT)
			return glDrawTransformFeedbackEXT(static_cast<GLenum>(mode), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTransformFeedbackEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTransformFeedbackInstanced(enums::PrimitiveType mode, GLuint id, GLsizei instancecount) {
		#if defined(glDrawTransformFeedbackInstanced)
			return glDrawTransformFeedbackInstanced(static_cast<GLenum>(mode), id, instancecount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTransformFeedbackInstanced" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTransformFeedbackInstancedEXT(enums::PrimitiveType mode, GLuint id, GLsizei instancecount) {
		#if defined(glDrawTransformFeedbackInstancedEXT)
			return glDrawTransformFeedbackInstancedEXT(static_cast<GLenum>(mode), id, instancecount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTransformFeedbackInstancedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTransformFeedbackNV(enums::PrimitiveType mode, GLuint id) {
		#if defined(glDrawTransformFeedbackNV)
			return glDrawTransformFeedbackNV(static_cast<GLenum>(mode), id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTransformFeedbackNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTransformFeedbackStream(enums::PrimitiveType mode, GLuint id, GLuint stream) {
		#if defined(glDrawTransformFeedbackStream)
			return glDrawTransformFeedbackStream(static_cast<GLenum>(mode), id, stream);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTransformFeedbackStream" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawTransformFeedbackStreamInstanced(enums::PrimitiveType mode, GLuint id, GLuint stream, GLsizei instancecount) {
		#if defined(glDrawTransformFeedbackStreamInstanced)
			return glDrawTransformFeedbackStreamInstanced(static_cast<GLenum>(mode), id, stream, instancecount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawTransformFeedbackStreamInstanced" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void eGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image) {
		#if defined(glEGLImageTargetRenderbufferStorageOES)
			return glEGLImageTargetRenderbufferStorageOES(target, image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEGLImageTargetRenderbufferStorageOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void eGLImageTargetTexStorageEXT(GLenum target, GLeglImageOES image, const GLint* attrib_list) {
		#if defined(glEGLImageTargetTexStorageEXT)
			return glEGLImageTargetTexStorageEXT(target, image, attrib_list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEGLImageTargetTexStorageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void eGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image) {
		#if defined(glEGLImageTargetTexture2DOES)
			return glEGLImageTargetTexture2DOES(target, image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEGLImageTargetTexture2DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void eGLImageTargetTextureStorageEXT(GLuint texture, GLeglImageOES image, const GLint* attrib_list) {
		#if defined(glEGLImageTargetTextureStorageEXT)
			return glEGLImageTargetTextureStorageEXT(texture, image, attrib_list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEGLImageTargetTextureStorageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void edgeFlag(GLboolean flag) {
		#if defined(glEdgeFlag)
			return glEdgeFlag(flag);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEdgeFlag" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void edgeFlagFormatNV(GLsizei stride) {
		#if defined(glEdgeFlagFormatNV)
			return glEdgeFlagFormatNV(stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEdgeFlagFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void edgeFlagPointer(GLsizei stride, const void * pointer) {
		#if defined(glEdgeFlagPointer)
			return glEdgeFlagPointer(stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEdgeFlagPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void edgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean* pointer) {
		#if defined(glEdgeFlagPointerEXT)
			return glEdgeFlagPointerEXT(stride, count, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEdgeFlagPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void edgeFlagPointerListIBM(GLint stride, const GLboolean** pointer, GLint ptrstride) {
		#if defined(glEdgeFlagPointerListIBM)
			return glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEdgeFlagPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void edgeFlagv(const GLboolean* flag) {
		#if defined(glEdgeFlagv)
			return glEdgeFlagv(flag);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEdgeFlagv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void elementPointerAPPLE(enums::ElementPointerTypeATI type, const void * pointer) {
		#if defined(glElementPointerAPPLE)
			return glElementPointerAPPLE(static_cast<GLenum>(type), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glElementPointerAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void elementPointerATI(enums::ElementPointerTypeATI type, const void * pointer) {
		#if defined(glElementPointerATI)
			return glElementPointerATI(static_cast<GLenum>(type), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glElementPointerATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enable(enums::EnableCap cap) {
		#if defined(glEnable)
			return glEnable(static_cast<GLenum>(cap));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableClientState(enums::EnableCap array) {
		#if defined(glEnableClientState)
			return glEnableClientState(static_cast<GLenum>(array));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableClientState" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableClientStateIndexedEXT(enums::EnableCap array, GLuint index) {
		#if defined(glEnableClientStateIndexedEXT)
			return glEnableClientStateIndexedEXT(static_cast<GLenum>(array), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableClientStateIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableClientStateiEXT(enums::EnableCap array, GLuint index) {
		#if defined(glEnableClientStateiEXT)
			return glEnableClientStateiEXT(static_cast<GLenum>(array), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableClientStateiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableDriverControlQCOM(GLuint driverControl) {
		#if defined(glEnableDriverControlQCOM)
			return glEnableDriverControlQCOM(driverControl);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableDriverControlQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableIndexedEXT(enums::EnableCap target, GLuint index) {
		#if defined(glEnableIndexedEXT)
			return glEnableIndexedEXT(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableVariantClientStateEXT(GLuint id) {
		#if defined(glEnableVariantClientStateEXT)
			return glEnableVariantClientStateEXT(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableVariantClientStateEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableVertexArrayAttrib(GLuint vaobj, GLuint index) {
		#if defined(glEnableVertexArrayAttrib)
			return glEnableVertexArrayAttrib(vaobj, index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableVertexArrayAttrib" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableVertexArrayAttribEXT(GLuint vaobj, GLuint index) {
		#if defined(glEnableVertexArrayAttribEXT)
			return glEnableVertexArrayAttribEXT(vaobj, index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableVertexArrayAttribEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableVertexArrayEXT(GLuint vaobj, enums::EnableCap array) {
		#if defined(glEnableVertexArrayEXT)
			return glEnableVertexArrayEXT(vaobj, static_cast<GLenum>(array));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableVertexArrayEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableVertexAttribAPPLE(GLuint index, GLenum pname) {
		#if defined(glEnableVertexAttribAPPLE)
			return glEnableVertexAttribAPPLE(index, pname);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableVertexAttribAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableVertexAttribArray(GLuint index) {
		#if defined(glEnableVertexAttribArray)
			return glEnableVertexAttribArray(index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableVertexAttribArray" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableVertexAttribArrayARB(GLuint index) {
		#if defined(glEnableVertexAttribArrayARB)
			return glEnableVertexAttribArrayARB(index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableVertexAttribArrayARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enablei(enums::EnableCap target, GLuint index) {
		#if defined(glEnablei)
			return glEnablei(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnablei" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableiEXT(enums::EnableCap target, GLuint index) {
		#if defined(glEnableiEXT)
			return glEnableiEXT(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableiNV(enums::EnableCap target, GLuint index) {
		#if defined(glEnableiNV)
			return glEnableiNV(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableiNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void enableiOES(enums::EnableCap target, GLuint index) {
		#if defined(glEnableiOES)
			return glEnableiOES(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnableiOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void end() {
		#if defined(glEnd)
			return glEnd();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEnd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endConditionalRender() {
		#if defined(glEndConditionalRender)
			return glEndConditionalRender();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndConditionalRender" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endConditionalRenderNV() {
		#if defined(glEndConditionalRenderNV)
			return glEndConditionalRenderNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndConditionalRenderNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endConditionalRenderNVX() {
		#if defined(glEndConditionalRenderNVX)
			return glEndConditionalRenderNVX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndConditionalRenderNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endFragmentShaderATI() {
		#if defined(glEndFragmentShaderATI)
			return glEndFragmentShaderATI();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndFragmentShaderATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endList() {
		#if defined(glEndList)
			return glEndList();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndList" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endOcclusionQueryNV() {
		#if defined(glEndOcclusionQueryNV)
			return glEndOcclusionQueryNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndOcclusionQueryNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endPerfMonitorAMD(GLuint monitor) {
		#if defined(glEndPerfMonitorAMD)
			return glEndPerfMonitorAMD(monitor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndPerfMonitorAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endPerfQueryINTEL(GLuint queryHandle) {
		#if defined(glEndPerfQueryINTEL)
			return glEndPerfQueryINTEL(queryHandle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndPerfQueryINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endQuery(enums::QueryTarget target) {
		#if defined(glEndQuery)
			return glEndQuery(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndQuery" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endQueryARB(enums::QueryTarget target) {
		#if defined(glEndQueryARB)
			return glEndQueryARB(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndQueryARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endQueryEXT(enums::QueryTarget target) {
		#if defined(glEndQueryEXT)
			return glEndQueryEXT(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndQueryEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endQueryIndexed(enums::QueryTarget target, GLuint index) {
		#if defined(glEndQueryIndexed)
			return glEndQueryIndexed(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndQueryIndexed" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endTilingQCOM(GLbitfield preserveMask) {
		#if defined(glEndTilingQCOM)
			return glEndTilingQCOM(preserveMask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndTilingQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endTransformFeedback() {
		#if defined(glEndTransformFeedback)
			return glEndTransformFeedback();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndTransformFeedback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endTransformFeedbackEXT() {
		#if defined(glEndTransformFeedbackEXT)
			return glEndTransformFeedbackEXT();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndTransformFeedbackEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endTransformFeedbackNV() {
		#if defined(glEndTransformFeedbackNV)
			return glEndTransformFeedbackNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndTransformFeedbackNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endVertexShaderEXT() {
		#if defined(glEndVertexShaderEXT)
			return glEndVertexShaderEXT();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndVertexShaderEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void endVideoCaptureNV(GLuint video_capture_slot) {
		#if defined(glEndVideoCaptureNV)
			return glEndVideoCaptureNV(video_capture_slot);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEndVideoCaptureNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord1d(GLdouble u) {
		#if defined(glEvalCoord1d)
			return glEvalCoord1d(u);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord1dv(const GLdouble* u) {
		#if defined(glEvalCoord1dv)
			return glEvalCoord1dv(u);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord1dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord1f(GLfloat u) {
		#if defined(glEvalCoord1f)
			return glEvalCoord1f(u);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord1fv(const GLfloat* u) {
		#if defined(glEvalCoord1fv)
			return glEvalCoord1fv(u);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord1fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord1xOES(GLfixed u) {
		#if defined(glEvalCoord1xOES)
			return glEvalCoord1xOES(u);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord1xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord1xvOES(const GLfixed* coords) {
		#if defined(glEvalCoord1xvOES)
			return glEvalCoord1xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord1xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord2d(GLdouble u, GLdouble v) {
		#if defined(glEvalCoord2d)
			return glEvalCoord2d(u, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord2dv(const GLdouble* u) {
		#if defined(glEvalCoord2dv)
			return glEvalCoord2dv(u);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord2f(GLfloat u, GLfloat v) {
		#if defined(glEvalCoord2f)
			return glEvalCoord2f(u, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord2fv(const GLfloat* u) {
		#if defined(glEvalCoord2fv)
			return glEvalCoord2fv(u);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord2xOES(GLfixed u, GLfixed v) {
		#if defined(glEvalCoord2xOES)
			return glEvalCoord2xOES(u, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord2xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalCoord2xvOES(const GLfixed* coords) {
		#if defined(glEvalCoord2xvOES)
			return glEvalCoord2xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalCoord2xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalMapsNV(enums::EvalTargetNV target, enums::EvalMapsModeNV mode) {
		#if defined(glEvalMapsNV)
			return glEvalMapsNV(static_cast<GLenum>(target), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalMapsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalMesh1(enums::MeshMode1 mode, GLint i1, GLint i2) {
		#if defined(glEvalMesh1)
			return glEvalMesh1(static_cast<GLenum>(mode), i1, i2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalMesh1" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalMesh2(enums::MeshMode2 mode, GLint i1, GLint i2, GLint j1, GLint j2) {
		#if defined(glEvalMesh2)
			return glEvalMesh2(static_cast<GLenum>(mode), i1, i2, j1, j2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalMesh2" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalPoint1(GLint i) {
		#if defined(glEvalPoint1)
			return glEvalPoint1(i);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalPoint1" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evalPoint2(GLint i, GLint j) {
		#if defined(glEvalPoint2)
			return glEvalPoint2(i, j);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvalPoint2" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void evaluateDepthValuesARB() {
		#if defined(glEvaluateDepthValuesARB)
			return glEvaluateDepthValuesARB();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glEvaluateDepthValuesARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void executeProgramNV(enums::VertexAttribEnumNV target, GLuint id, const GLfloat* params) {
		#if defined(glExecuteProgramNV)
			return glExecuteProgramNV(static_cast<GLenum>(target), id, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExecuteProgramNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetBufferPointervQCOM(GLenum target, void ** params) {
		#if defined(glExtGetBufferPointervQCOM)
			return glExtGetBufferPointervQCOM(target, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetBufferPointervQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetBuffersQCOM(GLuint* buffers, GLint maxBuffers, GLint* numBuffers) {
		#if defined(glExtGetBuffersQCOM)
			return glExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetBuffersQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetFramebuffersQCOM(GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers) {
		#if defined(glExtGetFramebuffersQCOM)
			return glExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetFramebuffersQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetProgramBinarySourceQCOM(GLuint program, enums::ShaderType shadertype, GLchar* source, GLint* length) {
		#if defined(glExtGetProgramBinarySourceQCOM)
			return glExtGetProgramBinarySourceQCOM(program, static_cast<GLenum>(shadertype), source, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetProgramBinarySourceQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetProgramsQCOM(GLuint* programs, GLint maxPrograms, GLint* numPrograms) {
		#if defined(glExtGetProgramsQCOM)
			return glExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetProgramsQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetRenderbuffersQCOM(GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers) {
		#if defined(glExtGetRenderbuffersQCOM)
			return glExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetRenderbuffersQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetShadersQCOM(GLuint* shaders, GLint maxShaders, GLint* numShaders) {
		#if defined(glExtGetShadersQCOM)
			return glExtGetShadersQCOM(shaders, maxShaders, numShaders);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetShadersQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params) {
		#if defined(glExtGetTexLevelParameterivQCOM)
			return glExtGetTexLevelParameterivQCOM(texture, face, level, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetTexLevelParameterivQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, void * texels) {
		#if defined(glExtGetTexSubImageQCOM)
			return glExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), texels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetTexSubImageQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extGetTexturesQCOM(GLuint* textures, GLint maxTextures, GLint* numTextures) {
		#if defined(glExtGetTexturesQCOM)
			return glExtGetTexturesQCOM(textures, maxTextures, numTextures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtGetTexturesQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean extIsProgramBinaryQCOM(GLuint program) {
		#if defined(glExtIsProgramBinaryQCOM)
			return glExtIsProgramBinaryQCOM(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtIsProgramBinaryQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void extTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param) {
		#if defined(glExtTexObjectStateOverrideiQCOM)
			return glExtTexObjectStateOverrideiQCOM(target, pname, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtTexObjectStateOverrideiQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extractComponentEXT(GLuint res, GLuint src, GLuint num) {
		#if defined(glExtractComponentEXT)
			return glExtractComponentEXT(res, src, num);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtractComponentEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void feedbackBuffer(GLsizei size, enums::FeedbackType type, GLfloat* buffer) {
		#if defined(glFeedbackBuffer)
			return glFeedbackBuffer(size, static_cast<GLenum>(type), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFeedbackBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void feedbackBufferxOES(GLsizei n, GLenum type, const GLfixed* buffer) {
		#if defined(glFeedbackBufferxOES)
			return glFeedbackBufferxOES(n, type, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFeedbackBufferxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLsync fenceSync(enums::SyncCondition condition, GLbitfield flags) {
		#if defined(glFenceSync)
			return glFenceSync(static_cast<GLenum>(condition), flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFenceSync" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLsync fenceSyncAPPLE(enums::SyncCondition condition, GLbitfield flags) {
		#if defined(glFenceSyncAPPLE)
			return glFenceSyncAPPLE(static_cast<GLenum>(condition), flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFenceSyncAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void finalCombinerInputNV(enums::CombinerVariableNV variable, enums::CombinerRegisterNV input, enums::CombinerMappingNV mapping, enums::CombinerComponentUsageNV componentUsage) {
		#if defined(glFinalCombinerInputNV)
			return glFinalCombinerInputNV(static_cast<GLenum>(variable), static_cast<GLenum>(input), static_cast<GLenum>(mapping), static_cast<GLenum>(componentUsage));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFinalCombinerInputNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void finish() {
		#if defined(glFinish)
			return glFinish();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFinish" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint finishAsyncSGIX(GLuint* markerp) {
		#if defined(glFinishAsyncSGIX)
			return glFinishAsyncSGIX(markerp);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFinishAsyncSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void finishFenceAPPLE(GLuint fence) {
		#if defined(glFinishFenceAPPLE)
			return glFinishFenceAPPLE(fence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFinishFenceAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void finishFenceNV(GLuint fence) {
		#if defined(glFinishFenceNV)
			return glFinishFenceNV(fence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFinishFenceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void finishObjectAPPLE(enums::ObjectTypeAPPLE object, GLint name) {
		#if defined(glFinishObjectAPPLE)
			return glFinishObjectAPPLE(static_cast<GLenum>(object), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFinishObjectAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void finishTextureSUNX() {
		#if defined(glFinishTextureSUNX)
			return glFinishTextureSUNX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFinishTextureSUNX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flush() {
		#if defined(glFlush)
			return glFlush();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlush" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushMappedBufferRange(enums::BufferTargetARB target, GLintptr offset, GLsizeiptr length) {
		#if defined(glFlushMappedBufferRange)
			return glFlushMappedBufferRange(static_cast<GLenum>(target), offset, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushMappedBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushMappedBufferRangeAPPLE(enums::BufferTargetARB target, GLintptr offset, GLsizeiptr size) {
		#if defined(glFlushMappedBufferRangeAPPLE)
			return glFlushMappedBufferRangeAPPLE(static_cast<GLenum>(target), offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushMappedBufferRangeAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushMappedBufferRangeEXT(enums::BufferTargetARB target, GLintptr offset, GLsizeiptr length) {
		#if defined(glFlushMappedBufferRangeEXT)
			return glFlushMappedBufferRangeEXT(static_cast<GLenum>(target), offset, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushMappedBufferRangeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length) {
		#if defined(glFlushMappedNamedBufferRange)
			return glFlushMappedNamedBufferRange(buffer, offset, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushMappedNamedBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length) {
		#if defined(glFlushMappedNamedBufferRangeEXT)
			return glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushMappedNamedBufferRangeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushPixelDataRangeNV(enums::PixelDataRangeTargetNV target) {
		#if defined(glFlushPixelDataRangeNV)
			return glFlushPixelDataRangeNV(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushPixelDataRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushRasterSGIX() {
		#if defined(glFlushRasterSGIX)
			return glFlushRasterSGIX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushRasterSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushStaticDataIBM(GLenum target) {
		#if defined(glFlushStaticDataIBM)
			return glFlushStaticDataIBM(target);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushStaticDataIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushVertexArrayRangeAPPLE(GLsizei length, void * pointer) {
		#if defined(glFlushVertexArrayRangeAPPLE)
			return glFlushVertexArrayRangeAPPLE(length, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushVertexArrayRangeAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void flushVertexArrayRangeNV() {
		#if defined(glFlushVertexArrayRangeNV)
			return glFlushVertexArrayRangeNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFlushVertexArrayRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordFormatNV(GLenum type, GLsizei stride) {
		#if defined(glFogCoordFormatNV)
			return glFogCoordFormatNV(type, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordPointer(enums::FogPointerTypeEXT type, GLsizei stride, const void * pointer) {
		#if defined(glFogCoordPointer)
			return glFogCoordPointer(static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordPointerEXT(enums::FogPointerTypeEXT type, GLsizei stride, const void * pointer) {
		#if defined(glFogCoordPointerEXT)
			return glFogCoordPointerEXT(static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordPointerListIBM(enums::FogPointerTypeIBM type, GLint stride, const void ** pointer, GLint ptrstride) {
		#if defined(glFogCoordPointerListIBM)
			return glFogCoordPointerListIBM(static_cast<GLenum>(type), stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordd(GLdouble coord) {
		#if defined(glFogCoordd)
			return glFogCoordd(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoorddEXT(GLdouble coord) {
		#if defined(glFogCoorddEXT)
			return glFogCoorddEXT(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoorddEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoorddv(const GLdouble* coord) {
		#if defined(glFogCoorddv)
			return glFogCoorddv(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoorddv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoorddvEXT(const GLdouble* coord) {
		#if defined(glFogCoorddvEXT)
			return glFogCoorddvEXT(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoorddvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordf(GLfloat coord) {
		#if defined(glFogCoordf)
			return glFogCoordf(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordfEXT(GLfloat coord) {
		#if defined(glFogCoordfEXT)
			return glFogCoordfEXT(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordfv(const GLfloat* coord) {
		#if defined(glFogCoordfv)
			return glFogCoordfv(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordfvEXT(const GLfloat* coord) {
		#if defined(glFogCoordfvEXT)
			return glFogCoordfvEXT(coord);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordhNV(GLhalfNV fog) {
		#if defined(glFogCoordhNV)
			return glFogCoordhNV(fog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordhNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogCoordhvNV(const GLhalfNV* fog) {
		#if defined(glFogCoordhvNV)
			return glFogCoordhvNV(fog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogCoordhvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogFuncSGIS(GLsizei n, const GLfloat* points) {
		#if defined(glFogFuncSGIS)
			return glFogFuncSGIS(n, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogf(enums::FogParameter pname, GLfloat param) {
		#if defined(glFogf)
			return glFogf(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogfv(enums::FogParameter pname, const GLfloat* params) {
		#if defined(glFogfv)
			return glFogfv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogi(enums::FogParameter pname, GLint param) {
		#if defined(glFogi)
			return glFogi(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogiv(enums::FogParameter pname, const GLint* params) {
		#if defined(glFogiv)
			return glFogiv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogx(enums::FogPName pname, GLfixed param) {
		#if defined(glFogx)
			return glFogx(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogxOES(enums::FogPName pname, GLfixed param) {
		#if defined(glFogxOES)
			return glFogxOES(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogxv(enums::FogPName pname, const GLfixed* param) {
		#if defined(glFogxv)
			return glFogxv(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fogxvOES(enums::FogPName pname, const GLfixed* param) {
		#if defined(glFogxvOES)
			return glFogxvOES(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFogxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentColorMaterialSGIX(enums::TriangleFace face, enums::MaterialParameter mode) {
		#if defined(glFragmentColorMaterialSGIX)
			return glFragmentColorMaterialSGIX(static_cast<GLenum>(face), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentColorMaterialSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentCoverageColorNV(GLuint color) {
		#if defined(glFragmentCoverageColorNV)
			return glFragmentCoverageColorNV(color);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentCoverageColorNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightModelfSGIX(enums::FragmentLightModelParameterSGIX pname, GLfloat param) {
		#if defined(glFragmentLightModelfSGIX)
			return glFragmentLightModelfSGIX(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightModelfSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightModelfvSGIX(enums::FragmentLightModelParameterSGIX pname, const GLfloat* params) {
		#if defined(glFragmentLightModelfvSGIX)
			return glFragmentLightModelfvSGIX(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightModelfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightModeliSGIX(enums::FragmentLightModelParameterSGIX pname, GLint param) {
		#if defined(glFragmentLightModeliSGIX)
			return glFragmentLightModeliSGIX(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightModeliSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightModelivSGIX(enums::FragmentLightModelParameterSGIX pname, const GLint* params) {
		#if defined(glFragmentLightModelivSGIX)
			return glFragmentLightModelivSGIX(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightModelivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightfSGIX(enums::FragmentLightNameSGIX light, enums::FragmentLightParameterSGIX pname, GLfloat param) {
		#if defined(glFragmentLightfSGIX)
			return glFragmentLightfSGIX(static_cast<GLenum>(light), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightfSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightfvSGIX(enums::FragmentLightNameSGIX light, enums::FragmentLightParameterSGIX pname, const GLfloat* params) {
		#if defined(glFragmentLightfvSGIX)
			return glFragmentLightfvSGIX(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightiSGIX(enums::FragmentLightNameSGIX light, enums::FragmentLightParameterSGIX pname, GLint param) {
		#if defined(glFragmentLightiSGIX)
			return glFragmentLightiSGIX(static_cast<GLenum>(light), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightiSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentLightivSGIX(enums::FragmentLightNameSGIX light, enums::FragmentLightParameterSGIX pname, const GLint* params) {
		#if defined(glFragmentLightivSGIX)
			return glFragmentLightivSGIX(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentLightivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentMaterialfSGIX(enums::TriangleFace face, enums::MaterialParameter pname, GLfloat param) {
		#if defined(glFragmentMaterialfSGIX)
			return glFragmentMaterialfSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentMaterialfSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentMaterialfvSGIX(enums::TriangleFace face, enums::MaterialParameter pname, const GLfloat* params) {
		#if defined(glFragmentMaterialfvSGIX)
			return glFragmentMaterialfvSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentMaterialfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentMaterialiSGIX(enums::TriangleFace face, enums::MaterialParameter pname, GLint param) {
		#if defined(glFragmentMaterialiSGIX)
			return glFragmentMaterialiSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentMaterialiSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void fragmentMaterialivSGIX(enums::TriangleFace face, enums::MaterialParameter pname, const GLint* params) {
		#if defined(glFragmentMaterialivSGIX)
			return glFragmentMaterialivSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFragmentMaterialivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frameTerminatorGREMEDY() {
		#if defined(glFrameTerminatorGREMEDY)
			return glFrameTerminatorGREMEDY();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrameTerminatorGREMEDY" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frameZoomSGIX(GLint factor) {
		#if defined(glFrameZoomSGIX)
			return glFrameZoomSGIX(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrameZoomSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferDrawBufferEXT(GLuint framebuffer, enums::DrawBufferMode mode) {
		#if defined(glFramebufferDrawBufferEXT)
			return glFramebufferDrawBufferEXT(framebuffer, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferDrawBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum* bufs) {
		#if defined(glFramebufferDrawBuffersEXT)
			return glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferDrawBuffersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferFetchBarrierEXT() {
		#if defined(glFramebufferFetchBarrierEXT)
			return glFramebufferFetchBarrierEXT();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferFetchBarrierEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferFetchBarrierQCOM() {
		#if defined(glFramebufferFetchBarrierQCOM)
			return glFramebufferFetchBarrierQCOM();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferFetchBarrierQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferFoveationConfigQCOM(GLuint framebuffer, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint* providedFeatures) {
		#if defined(glFramebufferFoveationConfigQCOM)
			return glFramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferFoveationConfigQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferFoveationParametersQCOM(GLuint framebuffer, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea) {
		#if defined(glFramebufferFoveationParametersQCOM)
			return glFramebufferFoveationParametersQCOM(framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferFoveationParametersQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferParameteri(enums::FramebufferTarget target, enums::FramebufferParameterName pname, GLint param) {
		#if defined(glFramebufferParameteri)
			return glFramebufferParameteri(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferPixelLocalStorageSizeEXT(GLuint target, GLsizei size) {
		#if defined(glFramebufferPixelLocalStorageSizeEXT)
			return glFramebufferPixelLocalStorageSizeEXT(target, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferPixelLocalStorageSizeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferReadBufferEXT(GLuint framebuffer, enums::ReadBufferMode mode) {
		#if defined(glFramebufferReadBufferEXT)
			return glFramebufferReadBufferEXT(framebuffer, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferReadBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferRenderbuffer(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::RenderbufferTarget renderbuffertarget, GLuint renderbuffer) {
		#if defined(glFramebufferRenderbuffer)
			return glFramebufferRenderbuffer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferRenderbuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferRenderbufferEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::RenderbufferTarget renderbuffertarget, GLuint renderbuffer) {
		#if defined(glFramebufferRenderbufferEXT)
			return glFramebufferRenderbufferEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferRenderbufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferRenderbufferOES(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::RenderbufferTarget renderbuffertarget, GLuint renderbuffer) {
		#if defined(glFramebufferRenderbufferOES)
			return glFramebufferRenderbufferOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferRenderbufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferSampleLocationsfvARB(enums::FramebufferTarget target, GLuint start, GLsizei count, const GLfloat* v) {
		#if defined(glFramebufferSampleLocationsfvARB)
			return glFramebufferSampleLocationsfvARB(static_cast<GLenum>(target), start, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferSampleLocationsfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferSampleLocationsfvNV(enums::FramebufferTarget target, GLuint start, GLsizei count, const GLfloat* v) {
		#if defined(glFramebufferSampleLocationsfvNV)
			return glFramebufferSampleLocationsfvNV(static_cast<GLenum>(target), start, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferSampleLocationsfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferSamplePositionsfvAMD(enums::FramebufferTarget target, GLuint numsamples, GLuint pixelindex, const GLfloat* values) {
		#if defined(glFramebufferSamplePositionsfvAMD)
			return glFramebufferSamplePositionsfvAMD(static_cast<GLenum>(target), numsamples, pixelindex, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferSamplePositionsfvAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferShadingRateEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint baseLayer, GLsizei numLayers, GLsizei texelWidth, GLsizei texelHeight) {
		#if defined(glFramebufferShadingRateEXT)
			return glFramebufferShadingRateEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, baseLayer, numLayers, texelWidth, texelHeight);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferShadingRateEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level) {
		#if defined(glFramebufferTexture)
			return glFramebufferTexture(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture1D(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level) {
		#if defined(glFramebufferTexture1D)
			return glFramebufferTexture1D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture1DEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level) {
		#if defined(glFramebufferTexture1DEXT)
			return glFramebufferTexture1DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture2D(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level) {
		#if defined(glFramebufferTexture2D)
			return glFramebufferTexture2D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture2DEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level) {
		#if defined(glFramebufferTexture2DEXT)
			return glFramebufferTexture2DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture2DDownsampleIMG(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level, GLint xscale, GLint yscale) {
		#if defined(glFramebufferTexture2DDownsampleIMG)
			return glFramebufferTexture2DDownsampleIMG(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, xscale, yscale);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture2DDownsampleIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture2DMultisampleEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level, GLsizei samples) {
		#if defined(glFramebufferTexture2DMultisampleEXT)
			return glFramebufferTexture2DMultisampleEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, samples);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture2DMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture2DMultisampleIMG(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level, GLsizei samples) {
		#if defined(glFramebufferTexture2DMultisampleIMG)
			return glFramebufferTexture2DMultisampleIMG(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, samples);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture2DMultisampleIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture2DOES(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level) {
		#if defined(glFramebufferTexture2DOES)
			return glFramebufferTexture2DOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture2DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture3D(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level, GLint zoffset) {
		#if defined(glFramebufferTexture3D)
			return glFramebufferTexture3D(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, zoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture3DEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level, GLint zoffset) {
		#if defined(glFramebufferTexture3DEXT)
			return glFramebufferTexture3DEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, zoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTexture3DOES(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level, GLint zoffset) {
		#if defined(glFramebufferTexture3DOES)
			return glFramebufferTexture3DOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, zoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTexture3DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureARB(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level) {
		#if defined(glFramebufferTextureARB)
			return glFramebufferTextureARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level) {
		#if defined(glFramebufferTextureEXT)
			return glFramebufferTextureEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureFaceARB(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, enums::TextureTarget face) {
		#if defined(glFramebufferTextureFaceARB)
			return glFramebufferTextureFaceARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureFaceARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureFaceEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, enums::TextureTarget face) {
		#if defined(glFramebufferTextureFaceEXT)
			return glFramebufferTextureFaceEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureFaceEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureLayer(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint layer) {
		#if defined(glFramebufferTextureLayer)
			return glFramebufferTextureLayer(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureLayer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureLayerARB(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint layer) {
		#if defined(glFramebufferTextureLayerARB)
			return glFramebufferTextureLayerARB(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureLayerARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureLayerEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint layer) {
		#if defined(glFramebufferTextureLayerEXT)
			return glFramebufferTextureLayerEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureLayerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureLayerDownsampleIMG(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale) {
		#if defined(glFramebufferTextureLayerDownsampleIMG)
			return glFramebufferTextureLayerDownsampleIMG(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, layer, xscale, yscale);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureLayerDownsampleIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureMultisampleMultiviewOVR(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews) {
		#if defined(glFramebufferTextureMultisampleMultiviewOVR)
			return glFramebufferTextureMultisampleMultiviewOVR(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, samples, baseViewIndex, numViews);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureMultisampleMultiviewOVR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureMultiviewOVR(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) {
		#if defined(glFramebufferTextureMultiviewOVR)
			return glFramebufferTextureMultiviewOVR(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level, baseViewIndex, numViews);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureMultiviewOVR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferTextureOES(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, GLuint texture, GLint level) {
		#if defined(glFramebufferTextureOES)
			return glFramebufferTextureOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferTextureOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void freeObjectBufferATI(GLuint buffer) {
		#if defined(glFreeObjectBufferATI)
			return glFreeObjectBufferATI(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFreeObjectBufferATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frontFace(enums::FrontFaceDirection mode) {
		#if defined(glFrontFace)
			return glFrontFace(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrontFace" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
		#if defined(glFrustum)
			return glFrustum(left, right, bottom, top, zNear, zFar);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrustum" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frustumf(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
		#if defined(glFrustumf)
			return glFrustumf(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrustumf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
		#if defined(glFrustumfOES)
			return glFrustumfOES(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrustumfOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frustumx(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) {
		#if defined(glFrustumx)
			return glFrustumx(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrustumx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void frustumxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) {
		#if defined(glFrustumxOES)
			return glFrustumxOES(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFrustumxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint genAsyncMarkersSGIX(GLsizei range) {
		#if defined(glGenAsyncMarkersSGIX)
			return glGenAsyncMarkersSGIX(range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenAsyncMarkersSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void genBuffers(GLsizei n, GLuint* buffers) {
		#if defined(glGenBuffers)
			return glGenBuffers(n, buffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenBuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genBuffersARB(GLsizei n, GLuint* buffers) {
		#if defined(glGenBuffersARB)
			return glGenBuffersARB(n, buffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenBuffersARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genFencesAPPLE(GLsizei n, GLuint* fences) {
		#if defined(glGenFencesAPPLE)
			return glGenFencesAPPLE(n, fences);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenFencesAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genFencesNV(GLsizei n, GLuint* fences) {
		#if defined(glGenFencesNV)
			return glGenFencesNV(n, fences);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenFencesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint genFragmentShadersATI(GLuint range) {
		#if defined(glGenFragmentShadersATI)
			return glGenFragmentShadersATI(range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenFragmentShadersATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void genFramebuffers(GLsizei n, GLuint* framebuffers) {
		#if defined(glGenFramebuffers)
			return glGenFramebuffers(n, framebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenFramebuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genFramebuffersEXT(GLsizei n, GLuint* framebuffers) {
		#if defined(glGenFramebuffersEXT)
			return glGenFramebuffersEXT(n, framebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenFramebuffersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genFramebuffersOES(GLsizei n, GLuint* framebuffers) {
		#if defined(glGenFramebuffersOES)
			return glGenFramebuffersOES(n, framebuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenFramebuffersOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint genLists(GLsizei range) {
		#if defined(glGenLists)
			return glGenLists(range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenLists" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void genNamesAMD(GLenum identifier, GLuint num, GLuint* names) {
		#if defined(glGenNamesAMD)
			return glGenNamesAMD(identifier, num, names);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenNamesAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genOcclusionQueriesNV(GLsizei n, GLuint* ids) {
		#if defined(glGenOcclusionQueriesNV)
			return glGenOcclusionQueriesNV(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenOcclusionQueriesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint genPathsNV(GLsizei range) {
		#if defined(glGenPathsNV)
			return glGenPathsNV(range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenPathsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void genPerfMonitorsAMD(GLsizei n, GLuint* monitors) {
		#if defined(glGenPerfMonitorsAMD)
			return glGenPerfMonitorsAMD(n, monitors);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenPerfMonitorsAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genProgramPipelines(GLsizei n, GLuint* pipelines) {
		#if defined(glGenProgramPipelines)
			return glGenProgramPipelines(n, pipelines);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenProgramPipelines" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genProgramPipelinesEXT(GLsizei n, GLuint* pipelines) {
		#if defined(glGenProgramPipelinesEXT)
			return glGenProgramPipelinesEXT(n, pipelines);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenProgramPipelinesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genProgramsARB(GLsizei n, GLuint* programs) {
		#if defined(glGenProgramsARB)
			return glGenProgramsARB(n, programs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenProgramsARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genProgramsNV(GLsizei n, GLuint* programs) {
		#if defined(glGenProgramsNV)
			return glGenProgramsNV(n, programs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenProgramsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genQueries(GLsizei n, GLuint* ids) {
		#if defined(glGenQueries)
			return glGenQueries(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenQueries" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genQueriesARB(GLsizei n, GLuint* ids) {
		#if defined(glGenQueriesARB)
			return glGenQueriesARB(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenQueriesARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genQueriesEXT(GLsizei n, GLuint* ids) {
		#if defined(glGenQueriesEXT)
			return glGenQueriesEXT(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenQueriesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genQueryResourceTagNV(GLsizei n, GLint* tagIds) {
		#if defined(glGenQueryResourceTagNV)
			return glGenQueryResourceTagNV(n, tagIds);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenQueryResourceTagNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genRenderbuffers(GLsizei n, GLuint* renderbuffers) {
		#if defined(glGenRenderbuffers)
			return glGenRenderbuffers(n, renderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenRenderbuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genRenderbuffersEXT(GLsizei n, GLuint* renderbuffers) {
		#if defined(glGenRenderbuffersEXT)
			return glGenRenderbuffersEXT(n, renderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenRenderbuffersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genRenderbuffersOES(GLsizei n, GLuint* renderbuffers) {
		#if defined(glGenRenderbuffersOES)
			return glGenRenderbuffersOES(n, renderbuffers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenRenderbuffersOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genSamplers(GLsizei count, GLuint* samplers) {
		#if defined(glGenSamplers)
			return glGenSamplers(count, samplers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenSamplers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genSemaphoresEXT(GLsizei n, GLuint* semaphores) {
		#if defined(glGenSemaphoresEXT)
			return glGenSemaphoresEXT(n, semaphores);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenSemaphoresEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint genSymbolsEXT(enums::DataTypeEXT datatype, enums::VertexShaderStorageTypeEXT storagetype, enums::ParameterRangeEXT range, GLuint components) {
		#if defined(glGenSymbolsEXT)
			return glGenSymbolsEXT(static_cast<GLenum>(datatype), static_cast<GLenum>(storagetype), static_cast<GLenum>(range), components);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenSymbolsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void genTextures(GLsizei n, GLuint* textures) {
		#if defined(glGenTextures)
			return glGenTextures(n, textures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenTextures" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genTexturesEXT(GLsizei n, GLuint* textures) {
		#if defined(glGenTexturesEXT)
			return glGenTexturesEXT(n, textures);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenTexturesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genTransformFeedbacks(GLsizei n, GLuint* ids) {
		#if defined(glGenTransformFeedbacks)
			return glGenTransformFeedbacks(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenTransformFeedbacks" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genTransformFeedbacksNV(GLsizei n, GLuint* ids) {
		#if defined(glGenTransformFeedbacksNV)
			return glGenTransformFeedbacksNV(n, ids);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenTransformFeedbacksNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genVertexArrays(GLsizei n, GLuint* arrays) {
		#if defined(glGenVertexArrays)
			return glGenVertexArrays(n, arrays);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenVertexArrays" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genVertexArraysAPPLE(GLsizei n, GLuint* arrays) {
		#if defined(glGenVertexArraysAPPLE)
			return glGenVertexArraysAPPLE(n, arrays);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenVertexArraysAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void genVertexArraysOES(GLsizei n, GLuint* arrays) {
		#if defined(glGenVertexArraysOES)
			return glGenVertexArraysOES(n, arrays);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenVertexArraysOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint genVertexShadersEXT(GLuint range) {
		#if defined(glGenVertexShadersEXT)
			return glGenVertexShadersEXT(range);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenVertexShadersEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void generateMipmap(enums::TextureTarget target) {
		#if defined(glGenerateMipmap)
			return glGenerateMipmap(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenerateMipmap" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void generateMipmapEXT(enums::TextureTarget target) {
		#if defined(glGenerateMipmapEXT)
			return glGenerateMipmapEXT(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenerateMipmapEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void generateMipmapOES(enums::TextureTarget target) {
		#if defined(glGenerateMipmapOES)
			return glGenerateMipmapOES(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenerateMipmapOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void generateMultiTexMipmapEXT(enums::TextureUnit texunit, enums::TextureTarget target) {
		#if defined(glGenerateMultiTexMipmapEXT)
			return glGenerateMultiTexMipmapEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenerateMultiTexMipmapEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void generateTextureMipmap(GLuint texture) {
		#if defined(glGenerateTextureMipmap)
			return glGenerateTextureMipmap(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenerateTextureMipmap" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void generateTextureMipmapEXT(GLuint texture, enums::TextureTarget target) {
		#if defined(glGenerateTextureMipmapEXT)
			return glGenerateTextureMipmapEXT(texture, static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGenerateTextureMipmapEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, enums::AtomicCounterBufferPName pname, GLint* params) {
		#if defined(glGetActiveAtomicCounterBufferiv)
			return glGetActiveAtomicCounterBufferiv(program, bufferIndex, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveAtomicCounterBufferiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) {
		#if defined(glGetActiveAttrib)
			return glGetActiveAttrib(program, index, bufSize, length, size, type, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveAttrib" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) {
		#if defined(glGetActiveAttribARB)
			return glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveAttribARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveSubroutineName(GLuint program, enums::ShaderType shadertype, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name) {
		#if defined(glGetActiveSubroutineName)
			return glGetActiveSubroutineName(program, static_cast<GLenum>(shadertype), index, bufSize, length, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveSubroutineName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveSubroutineUniformName(GLuint program, enums::ShaderType shadertype, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name) {
		#if defined(glGetActiveSubroutineUniformName)
			return glGetActiveSubroutineUniformName(program, static_cast<GLenum>(shadertype), index, bufSize, length, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveSubroutineUniformName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveSubroutineUniformiv(GLuint program, enums::ShaderType shadertype, GLuint index, enums::SubroutineParameterName pname, GLint* values) {
		#if defined(glGetActiveSubroutineUniformiv)
			return glGetActiveSubroutineUniformiv(program, static_cast<GLenum>(shadertype), index, static_cast<GLenum>(pname), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveSubroutineUniformiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) {
		#if defined(glGetActiveUniform)
			return glGetActiveUniform(program, index, bufSize, length, size, type, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveUniform" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLcharARB* name) {
		#if defined(glGetActiveUniformARB)
			return glGetActiveUniformARB(programObj, index, maxLength, length, size, type, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveUniformARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName) {
		#if defined(glGetActiveUniformBlockName)
			return glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveUniformBlockName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, enums::UniformBlockPName pname, GLint* params) {
		#if defined(glGetActiveUniformBlockiv)
			return glGetActiveUniformBlockiv(program, uniformBlockIndex, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveUniformBlockiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName) {
		#if defined(glGetActiveUniformName)
			return glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveUniformName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, enums::UniformPName pname, GLint* params) {
		#if defined(glGetActiveUniformsiv)
			return glGetActiveUniformsiv(program, uniformCount, uniformIndices, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveUniformsiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) {
		#if defined(glGetActiveVaryingNV)
			return glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetActiveVaryingNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getArrayObjectfvATI(enums::EnableCap array, enums::ArrayObjectPNameATI pname, GLfloat* params) {
		#if defined(glGetArrayObjectfvATI)
			return glGetArrayObjectfvATI(static_cast<GLenum>(array), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetArrayObjectfvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getArrayObjectivATI(enums::EnableCap array, enums::ArrayObjectPNameATI pname, GLint* params) {
		#if defined(glGetArrayObjectivATI)
			return glGetArrayObjectivATI(static_cast<GLenum>(array), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetArrayObjectivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB* obj) {
		#if defined(glGetAttachedObjectsARB)
			return glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetAttachedObjectsARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders) {
		#if defined(glGetAttachedShaders)
			return glGetAttachedShaders(program, maxCount, count, shaders);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetAttachedShaders" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint getAttribLocation(GLuint program, const GLchar* name) {
		#if defined(glGetAttribLocation)
			return glGetAttribLocation(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetAttribLocation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getAttribLocationARB(GLhandleARB programObj, const GLcharARB* name) {
		#if defined(glGetAttribLocationARB)
			return glGetAttribLocationARB(programObj, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetAttribLocationARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getBooleanIndexedvEXT(enums::BufferTargetARB target, GLuint index, GLboolean* data) {
		#if defined(glGetBooleanIndexedvEXT)
			return glGetBooleanIndexedvEXT(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBooleanIndexedvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBooleani_v(enums::BufferTargetARB target, GLuint index, GLboolean* data) {
		#if defined(glGetBooleani_v)
			return glGetBooleani_v(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBooleani_v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBooleanv(enums::GetPName pname, GLboolean* data) {
		#if defined(glGetBooleanv)
			return glGetBooleanv(static_cast<GLenum>(pname), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBooleanv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferParameteri64v(enums::BufferTargetARB target, enums::BufferPNameARB pname, GLint64* params) {
		#if defined(glGetBufferParameteri64v)
			return glGetBufferParameteri64v(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferParameteri64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferParameteriv(enums::BufferTargetARB target, enums::BufferPNameARB pname, GLint* params) {
		#if defined(glGetBufferParameteriv)
			return glGetBufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferParameterivARB(enums::BufferTargetARB target, enums::BufferPNameARB pname, GLint* params) {
		#if defined(glGetBufferParameterivARB)
			return glGetBufferParameterivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferParameterivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferParameterui64vNV(enums::BufferTargetARB target, GLenum pname, GLuint64EXT* params) {
		#if defined(glGetBufferParameterui64vNV)
			return glGetBufferParameterui64vNV(static_cast<GLenum>(target), pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferParameterui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferPointerv(enums::BufferTargetARB target, enums::BufferPointerNameARB pname, void ** params) {
		#if defined(glGetBufferPointerv)
			return glGetBufferPointerv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferPointerv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferPointervARB(enums::BufferTargetARB target, enums::BufferPointerNameARB pname, void ** params) {
		#if defined(glGetBufferPointervARB)
			return glGetBufferPointervARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferPointervARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferPointervOES(enums::BufferTargetARB target, enums::BufferPointerNameARB pname, void ** params) {
		#if defined(glGetBufferPointervOES)
			return glGetBufferPointervOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferPointervOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferSubData(enums::BufferTargetARB target, GLintptr offset, GLsizeiptr size, void * data) {
		#if defined(glGetBufferSubData)
			return glGetBufferSubData(static_cast<GLenum>(target), offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getBufferSubDataARB(enums::BufferTargetARB target, GLintptrARB offset, GLsizeiptrARB size, void * data) {
		#if defined(glGetBufferSubDataARB)
			return glGetBufferSubDataARB(static_cast<GLenum>(target), offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetBufferSubDataARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getClipPlane(enums::ClipPlaneName plane, GLdouble* equation) {
		#if defined(glGetClipPlane)
			return glGetClipPlane(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetClipPlane" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getClipPlanef(enums::ClipPlaneName plane, GLfloat* equation) {
		#if defined(glGetClipPlanef)
			return glGetClipPlanef(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetClipPlanef" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getClipPlanefOES(enums::ClipPlaneName plane, GLfloat* equation) {
		#if defined(glGetClipPlanefOES)
			return glGetClipPlanefOES(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetClipPlanefOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getClipPlanex(enums::ClipPlaneName plane, GLfixed* equation) {
		#if defined(glGetClipPlanex)
			return glGetClipPlanex(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetClipPlanex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getClipPlanexOES(enums::ClipPlaneName plane, GLfixed* equation) {
		#if defined(glGetClipPlanexOES)
			return glGetClipPlanexOES(static_cast<GLenum>(plane), equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetClipPlanexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTable(enums::ColorTableTarget target, enums::PixelFormat format, enums::PixelType type, void * table) {
		#if defined(glGetColorTable)
			return glGetColorTable(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), table);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableEXT(enums::ColorTableTarget target, enums::PixelFormat format, enums::PixelType type, void * data) {
		#if defined(glGetColorTableEXT)
			return glGetColorTableEXT(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableParameterfv(enums::ColorTableTarget target, enums::ColorTableParameterPName pname, GLfloat* params) {
		#if defined(glGetColorTableParameterfv)
			return glGetColorTableParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableParameterfvEXT(enums::ColorTableTarget target, enums::ColorTableParameterPName pname, GLfloat* params) {
		#if defined(glGetColorTableParameterfvEXT)
			return glGetColorTableParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableParameterfvSGI(enums::ColorTableTargetSGI target, enums::ColorTableParameterPName pname, GLfloat* params) {
		#if defined(glGetColorTableParameterfvSGI)
			return glGetColorTableParameterfvSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableParameterfvSGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableParameteriv(enums::ColorTableTarget target, enums::ColorTableParameterPName pname, GLint* params) {
		#if defined(glGetColorTableParameteriv)
			return glGetColorTableParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableParameterivEXT(enums::ColorTableTarget target, enums::ColorTableParameterPName pname, GLint* params) {
		#if defined(glGetColorTableParameterivEXT)
			return glGetColorTableParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableParameterivSGI(enums::ColorTableTargetSGI target, enums::ColorTableParameterPName pname, GLint* params) {
		#if defined(glGetColorTableParameterivSGI)
			return glGetColorTableParameterivSGI(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableParameterivSGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getColorTableSGI(enums::ColorTableTargetSGI target, enums::PixelFormat format, enums::PixelType type, void * table) {
		#if defined(glGetColorTableSGI)
			return glGetColorTableSGI(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), table);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetColorTableSGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCombinerInputParameterfvNV(enums::CombinerStageNV stage, enums::CombinerPortionNV portion, enums::CombinerVariableNV variable, enums::CombinerParameterNV pname, GLfloat* params) {
		#if defined(glGetCombinerInputParameterfvNV)
			return glGetCombinerInputParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(variable), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCombinerInputParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCombinerInputParameterivNV(enums::CombinerStageNV stage, enums::CombinerPortionNV portion, enums::CombinerVariableNV variable, enums::CombinerParameterNV pname, GLint* params) {
		#if defined(glGetCombinerInputParameterivNV)
			return glGetCombinerInputParameterivNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(variable), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCombinerInputParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCombinerOutputParameterfvNV(enums::CombinerStageNV stage, enums::CombinerPortionNV portion, enums::CombinerParameterNV pname, GLfloat* params) {
		#if defined(glGetCombinerOutputParameterfvNV)
			return glGetCombinerOutputParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCombinerOutputParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCombinerOutputParameterivNV(enums::CombinerStageNV stage, enums::CombinerPortionNV portion, enums::CombinerParameterNV pname, GLint* params) {
		#if defined(glGetCombinerOutputParameterivNV)
			return glGetCombinerOutputParameterivNV(static_cast<GLenum>(stage), static_cast<GLenum>(portion), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCombinerOutputParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCombinerStageParameterfvNV(enums::CombinerStageNV stage, enums::CombinerParameterNV pname, GLfloat* params) {
		#if defined(glGetCombinerStageParameterfvNV)
			return glGetCombinerStageParameterfvNV(static_cast<GLenum>(stage), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCombinerStageParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint getCommandHeaderNV(enums::CommandOpcodesNV tokenID, GLuint size) {
		#if defined(glGetCommandHeaderNV)
			return glGetCommandHeaderNV(static_cast<GLenum>(tokenID), size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCommandHeaderNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getCompressedMultiTexImageEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint lod, void * img) {
		#if defined(glGetCompressedMultiTexImageEXT)
			return glGetCompressedMultiTexImageEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), lod, img);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCompressedMultiTexImageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCompressedTexImage(enums::TextureTarget target, GLint level, void * img) {
		#if defined(glGetCompressedTexImage)
			return glGetCompressedTexImage(static_cast<GLenum>(target), level, img);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCompressedTexImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCompressedTexImageARB(enums::TextureTarget target, GLint level, void * img) {
		#if defined(glGetCompressedTexImageARB)
			return glGetCompressedTexImageARB(static_cast<GLenum>(target), level, img);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCompressedTexImageARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void * pixels) {
		#if defined(glGetCompressedTextureImage)
			return glGetCompressedTextureImage(texture, level, bufSize, pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCompressedTextureImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCompressedTextureImageEXT(GLuint texture, enums::TextureTarget target, GLint lod, void * img) {
		#if defined(glGetCompressedTextureImageEXT)
			return glGetCompressedTextureImageEXT(texture, static_cast<GLenum>(target), lod, img);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCompressedTextureImageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void * pixels) {
		#if defined(glGetCompressedTextureSubImage)
			return glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCompressedTextureSubImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getConvolutionFilter(enums::ConvolutionTarget target, enums::PixelFormat format, enums::PixelType type, void * image) {
		#if defined(glGetConvolutionFilter)
			return glGetConvolutionFilter(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetConvolutionFilter" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getConvolutionFilterEXT(enums::ConvolutionTargetEXT target, enums::PixelFormat format, enums::PixelType type, void * image) {
		#if defined(glGetConvolutionFilterEXT)
			return glGetConvolutionFilterEXT(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetConvolutionFilterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getConvolutionParameterfv(enums::ConvolutionTarget target, enums::ConvolutionParameter pname, GLfloat* params) {
		#if defined(glGetConvolutionParameterfv)
			return glGetConvolutionParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetConvolutionParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getConvolutionParameterfvEXT(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, GLfloat* params) {
		#if defined(glGetConvolutionParameterfvEXT)
			return glGetConvolutionParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetConvolutionParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getConvolutionParameteriv(enums::ConvolutionTarget target, enums::ConvolutionParameter pname, GLint* params) {
		#if defined(glGetConvolutionParameteriv)
			return glGetConvolutionParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetConvolutionParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getConvolutionParameterivEXT(enums::ConvolutionTargetEXT target, enums::ConvolutionParameter pname, GLint* params) {
		#if defined(glGetConvolutionParameterivEXT)
			return glGetConvolutionParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetConvolutionParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getConvolutionParameterxvOES(GLenum target, GLenum pname, GLfixed* params) {
		#if defined(glGetConvolutionParameterxvOES)
			return glGetConvolutionParameterxvOES(target, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetConvolutionParameterxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getCoverageModulationTableNV(GLsizei bufSize, GLfloat* v) {
		#if defined(glGetCoverageModulationTableNV)
			return glGetCoverageModulationTableNV(bufSize, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetCoverageModulationTableNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint getDebugMessageLog(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) {
		#if defined(glGetDebugMessageLog)
			return glGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDebugMessageLog" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint getDebugMessageLogAMD(GLuint count, GLsizei bufSize, GLenum* categories, GLenum* severities, GLuint* ids, GLsizei* lengths, GLchar* message) {
		#if defined(glGetDebugMessageLogAMD)
			return glGetDebugMessageLogAMD(count, bufSize, categories, severities, ids, lengths, message);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDebugMessageLogAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint getDebugMessageLogARB(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) {
		#if defined(glGetDebugMessageLogARB)
			return glGetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, messageLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDebugMessageLogARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint getDebugMessageLogKHR(GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog) {
		#if defined(glGetDebugMessageLogKHR)
			return glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDebugMessageLogKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getDetailTexFuncSGIS(enums::TextureTarget target, GLfloat* points) {
		#if defined(glGetDetailTexFuncSGIS)
			return glGetDetailTexFuncSGIS(static_cast<GLenum>(target), points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDetailTexFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getDoubleIndexedvEXT(enums::GetPName target, GLuint index, GLdouble* data) {
		#if defined(glGetDoubleIndexedvEXT)
			return glGetDoubleIndexedvEXT(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDoubleIndexedvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getDoublei_v(enums::GetPName target, GLuint index, GLdouble* data) {
		#if defined(glGetDoublei_v)
			return glGetDoublei_v(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDoublei_v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getDoublei_vEXT(enums::GetPName pname, GLuint index, GLdouble* params) {
		#if defined(glGetDoublei_vEXT)
			return glGetDoublei_vEXT(static_cast<GLenum>(pname), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDoublei_vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getDoublev(enums::GetPName pname, GLdouble* data) {
		#if defined(glGetDoublev)
			return glGetDoublev(static_cast<GLenum>(pname), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDoublev" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar* driverControlString) {
		#if defined(glGetDriverControlStringQCOM)
			return glGetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDriverControlStringQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getDriverControlsQCOM(GLint* num, GLsizei size, GLuint* driverControls) {
		#if defined(glGetDriverControlsQCOM)
			return glGetDriverControlsQCOM(num, size, driverControls);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetDriverControlsQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLenum getError() {
		#if defined(glGetError)
			return glGetError();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetError" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getFenceivNV(GLuint fence, enums::FenceParameterNameNV pname, GLint* params) {
		#if defined(glGetFenceivNV)
			return glGetFenceivNV(fence, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFenceivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFinalCombinerInputParameterfvNV(enums::CombinerVariableNV variable, enums::CombinerParameterNV pname, GLfloat* params) {
		#if defined(glGetFinalCombinerInputParameterfvNV)
			return glGetFinalCombinerInputParameterfvNV(static_cast<GLenum>(variable), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFinalCombinerInputParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFinalCombinerInputParameterivNV(enums::CombinerVariableNV variable, enums::CombinerParameterNV pname, GLint* params) {
		#if defined(glGetFinalCombinerInputParameterivNV)
			return glGetFinalCombinerInputParameterivNV(static_cast<GLenum>(variable), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFinalCombinerInputParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFirstPerfQueryIdINTEL(GLuint* queryId) {
		#if defined(glGetFirstPerfQueryIdINTEL)
			return glGetFirstPerfQueryIdINTEL(queryId);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFirstPerfQueryIdINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFixedv(enums::GetPName pname, GLfixed* params) {
		#if defined(glGetFixedv)
			return glGetFixedv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFixedv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFixedvOES(enums::GetPName pname, GLfixed* params) {
		#if defined(glGetFixedvOES)
			return glGetFixedvOES(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFixedvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFloatIndexedvEXT(enums::GetPName target, GLuint index, GLfloat* data) {
		#if defined(glGetFloatIndexedvEXT)
			return glGetFloatIndexedvEXT(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFloatIndexedvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFloati_v(enums::GetPName target, GLuint index, GLfloat* data) {
		#if defined(glGetFloati_v)
			return glGetFloati_v(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFloati_v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFloati_vEXT(enums::GetPName pname, GLuint index, GLfloat* params) {
		#if defined(glGetFloati_vEXT)
			return glGetFloati_vEXT(static_cast<GLenum>(pname), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFloati_vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFloati_vNV(enums::GetPName target, GLuint index, GLfloat* data) {
		#if defined(glGetFloati_vNV)
			return glGetFloati_vNV(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFloati_vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFloati_vOES(enums::GetPName target, GLuint index, GLfloat* data) {
		#if defined(glGetFloati_vOES)
			return glGetFloati_vOES(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFloati_vOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFloatv(enums::GetPName pname, GLfloat* data) {
		#if defined(glGetFloatv)
			return glGetFloatv(static_cast<GLenum>(pname), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFloatv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFogFuncSGIS(GLfloat* points) {
		#if defined(glGetFogFuncSGIS)
			return glGetFogFuncSGIS(points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFogFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint getFragDataIndex(GLuint program, const GLchar* name) {
		#if defined(glGetFragDataIndex)
			return glGetFragDataIndex(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragDataIndex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getFragDataIndexEXT(GLuint program, const GLchar* name) {
		#if defined(glGetFragDataIndexEXT)
			return glGetFragDataIndexEXT(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragDataIndexEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getFragDataLocation(GLuint program, const GLchar* name) {
		#if defined(glGetFragDataLocation)
			return glGetFragDataLocation(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragDataLocation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getFragDataLocationEXT(GLuint program, const GLchar* name) {
		#if defined(glGetFragDataLocationEXT)
			return glGetFragDataLocationEXT(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragDataLocationEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getFragmentLightfvSGIX(enums::FragmentLightNameSGIX light, enums::FragmentLightParameterSGIX pname, GLfloat* params) {
		#if defined(glGetFragmentLightfvSGIX)
			return glGetFragmentLightfvSGIX(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragmentLightfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFragmentLightivSGIX(enums::FragmentLightNameSGIX light, enums::FragmentLightParameterSGIX pname, GLint* params) {
		#if defined(glGetFragmentLightivSGIX)
			return glGetFragmentLightivSGIX(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragmentLightivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFragmentMaterialfvSGIX(enums::TriangleFace face, enums::MaterialParameter pname, GLfloat* params) {
		#if defined(glGetFragmentMaterialfvSGIX)
			return glGetFragmentMaterialfvSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragmentMaterialfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFragmentMaterialivSGIX(enums::TriangleFace face, enums::MaterialParameter pname, GLint* params) {
		#if defined(glGetFragmentMaterialivSGIX)
			return glGetFragmentMaterialivSGIX(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragmentMaterialivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFragmentShadingRatesEXT(GLsizei samples, GLsizei maxCount, GLsizei* count, GLenum* shadingRates) {
		#if defined(glGetFragmentShadingRatesEXT)
			return glGetFragmentShadingRatesEXT(samples, maxCount, count, shadingRates);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFragmentShadingRatesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFramebufferAttachmentParameteriv(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::FramebufferAttachmentParameterName pname, GLint* params) {
		#if defined(glGetFramebufferAttachmentParameteriv)
			return glGetFramebufferAttachmentParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferAttachmentParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFramebufferAttachmentParameterivEXT(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::FramebufferAttachmentParameterName pname, GLint* params) {
		#if defined(glGetFramebufferAttachmentParameterivEXT)
			return glGetFramebufferAttachmentParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferAttachmentParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFramebufferAttachmentParameterivOES(enums::FramebufferTarget target, enums::FramebufferAttachment attachment, enums::FramebufferAttachmentParameterName pname, GLint* params) {
		#if defined(glGetFramebufferAttachmentParameterivOES)
			return glGetFramebufferAttachmentParameterivOES(static_cast<GLenum>(target), static_cast<GLenum>(attachment), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferAttachmentParameterivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFramebufferParameterfvAMD(enums::FramebufferTarget target, enums::FramebufferAttachmentParameterName pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values) {
		#if defined(glGetFramebufferParameterfvAMD)
			return glGetFramebufferParameterfvAMD(static_cast<GLenum>(target), static_cast<GLenum>(pname), numsamples, pixelindex, size, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferParameterfvAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFramebufferParameteriv(enums::FramebufferTarget target, enums::FramebufferAttachmentParameterName pname, GLint* params) {
		#if defined(glGetFramebufferParameteriv)
			return glGetFramebufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFramebufferParameterivEXT(GLuint framebuffer, enums::GetFramebufferParameter pname, GLint* params) {
		#if defined(glGetFramebufferParameterivEXT)
			return glGetFramebufferParameterivEXT(framebuffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLsizei getFramebufferPixelLocalStorageSizeEXT(GLuint target) {
		#if defined(glGetFramebufferPixelLocalStorageSizeEXT)
			return glGetFramebufferPixelLocalStorageSizeEXT(target);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferPixelLocalStorageSizeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum getGraphicsResetStatus() {
		#if defined(glGetGraphicsResetStatus)
			return glGetGraphicsResetStatus();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetGraphicsResetStatus" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum getGraphicsResetStatusARB() {
		#if defined(glGetGraphicsResetStatusARB)
			return glGetGraphicsResetStatusARB();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetGraphicsResetStatusARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum getGraphicsResetStatusEXT() {
		#if defined(glGetGraphicsResetStatusEXT)
			return glGetGraphicsResetStatusEXT();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetGraphicsResetStatusEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum getGraphicsResetStatusKHR() {
		#if defined(glGetGraphicsResetStatusKHR)
			return glGetGraphicsResetStatusKHR();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetGraphicsResetStatusKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLhandleARB getHandleARB(enums::ContainerType pname) {
		#if defined(glGetHandleARB)
			return glGetHandleARB(static_cast<GLenum>(pname));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHandleARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getHistogram(enums::HistogramTargetEXT target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, void * values) {
		#if defined(glGetHistogram)
			return glGetHistogram(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHistogram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getHistogramEXT(enums::HistogramTargetEXT target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, void * values) {
		#if defined(glGetHistogramEXT)
			return glGetHistogramEXT(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHistogramEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getHistogramParameterfv(enums::HistogramTargetEXT target, enums::GetHistogramParameterPNameEXT pname, GLfloat* params) {
		#if defined(glGetHistogramParameterfv)
			return glGetHistogramParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHistogramParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getHistogramParameterfvEXT(enums::HistogramTargetEXT target, enums::GetHistogramParameterPNameEXT pname, GLfloat* params) {
		#if defined(glGetHistogramParameterfvEXT)
			return glGetHistogramParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHistogramParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getHistogramParameteriv(enums::HistogramTargetEXT target, enums::GetHistogramParameterPNameEXT pname, GLint* params) {
		#if defined(glGetHistogramParameteriv)
			return glGetHistogramParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHistogramParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getHistogramParameterivEXT(enums::HistogramTargetEXT target, enums::GetHistogramParameterPNameEXT pname, GLint* params) {
		#if defined(glGetHistogramParameterivEXT)
			return glGetHistogramParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHistogramParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getHistogramParameterxvOES(enums::HistogramTargetEXT target, enums::GetHistogramParameterPNameEXT pname, GLfixed* params) {
		#if defined(glGetHistogramParameterxvOES)
			return glGetHistogramParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetHistogramParameterxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint64 getImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, enums::PixelFormat format) {
		#if defined(glGetImageHandleARB)
			return glGetImageHandleARB(texture, level, layered, layer, static_cast<GLenum>(format));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetImageHandleARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint64 getImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, enums::PixelFormat format) {
		#if defined(glGetImageHandleNV)
			return glGetImageHandleNV(texture, level, layered, layer, static_cast<GLenum>(format));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetImageHandleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getImageTransformParameterfvHP(enums::ImageTransformTargetHP target, enums::ImageTransformPNameHP pname, GLfloat* params) {
		#if defined(glGetImageTransformParameterfvHP)
			return glGetImageTransformParameterfvHP(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetImageTransformParameterfvHP" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getImageTransformParameterivHP(enums::ImageTransformTargetHP target, enums::ImageTransformPNameHP pname, GLint* params) {
		#if defined(glGetImageTransformParameterivHP)
			return glGetImageTransformParameterivHP(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetImageTransformParameterivHP" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* infoLog) {
		#if defined(glGetInfoLogARB)
			return glGetInfoLogARB(obj, maxLength, length, infoLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInfoLogARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint getInstrumentsSGIX() {
		#if defined(glGetInstrumentsSGIX)
			return glGetInstrumentsSGIX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInstrumentsSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getInteger64i_v(enums::GetPName target, GLuint index, GLint64* data) {
		#if defined(glGetInteger64i_v)
			return glGetInteger64i_v(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInteger64i_v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInteger64v(enums::GetPName pname, GLint64* data) {
		#if defined(glGetInteger64v)
			return glGetInteger64v(static_cast<GLenum>(pname), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInteger64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInteger64vAPPLE(enums::GetPName pname, GLint64* params) {
		#if defined(glGetInteger64vAPPLE)
			return glGetInteger64vAPPLE(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInteger64vAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInteger64vEXT(enums::GetPName pname, GLint64* data) {
		#if defined(glGetInteger64vEXT)
			return glGetInteger64vEXT(static_cast<GLenum>(pname), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInteger64vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getIntegerIndexedvEXT(enums::GetPName target, GLuint index, GLint* data) {
		#if defined(glGetIntegerIndexedvEXT)
			return glGetIntegerIndexedvEXT(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetIntegerIndexedvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getIntegeri_v(enums::GetPName target, GLuint index, GLint* data) {
		#if defined(glGetIntegeri_v)
			return glGetIntegeri_v(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetIntegeri_v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getIntegeri_vEXT(enums::GetPName target, GLuint index, GLint* data) {
		#if defined(glGetIntegeri_vEXT)
			return glGetIntegeri_vEXT(static_cast<GLenum>(target), index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetIntegeri_vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getIntegerui64i_vNV(GLenum value, GLuint index, GLuint64EXT* result) {
		#if defined(glGetIntegerui64i_vNV)
			return glGetIntegerui64i_vNV(value, index, result);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetIntegerui64i_vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getIntegerui64vNV(GLenum value, GLuint64EXT* result) {
		#if defined(glGetIntegerui64vNV)
			return glGetIntegerui64vNV(value, result);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetIntegerui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getIntegerv(enums::GetPName pname, GLint* data) {
		#if defined(glGetIntegerv)
			return glGetIntegerv(static_cast<GLenum>(pname), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetIntegerv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInternalformatSampleivNV(enums::TextureTarget target, enums::InternalFormat internalformat, GLsizei samples, enums::InternalFormatPName pname, GLsizei count, GLint* params) {
		#if defined(glGetInternalformatSampleivNV)
			return glGetInternalformatSampleivNV(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), samples, static_cast<GLenum>(pname), count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInternalformatSampleivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInternalformati64v(enums::TextureTarget target, enums::InternalFormat internalformat, enums::InternalFormatPName pname, GLsizei count, GLint64* params) {
		#if defined(glGetInternalformati64v)
			return glGetInternalformati64v(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), static_cast<GLenum>(pname), count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInternalformati64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInternalformativ(enums::TextureTarget target, enums::InternalFormat internalformat, enums::InternalFormatPName pname, GLsizei count, GLint* params) {
		#if defined(glGetInternalformativ)
			return glGetInternalformativ(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), static_cast<GLenum>(pname), count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInternalformativ" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInvariantBooleanvEXT(GLuint id, enums::GetVariantValueEXT value, GLboolean* data) {
		#if defined(glGetInvariantBooleanvEXT)
			return glGetInvariantBooleanvEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInvariantBooleanvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInvariantFloatvEXT(GLuint id, enums::GetVariantValueEXT value, GLfloat* data) {
		#if defined(glGetInvariantFloatvEXT)
			return glGetInvariantFloatvEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInvariantFloatvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getInvariantIntegervEXT(GLuint id, enums::GetVariantValueEXT value, GLint* data) {
		#if defined(glGetInvariantIntegervEXT)
			return glGetInvariantIntegervEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetInvariantIntegervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLightfv(enums::LightName light, enums::LightParameter pname, GLfloat* params) {
		#if defined(glGetLightfv)
			return glGetLightfv(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLightfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLightiv(enums::LightName light, enums::LightParameter pname, GLint* params) {
		#if defined(glGetLightiv)
			return glGetLightiv(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLightiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLightxOES(enums::LightName light, enums::LightParameter pname, GLfixed* params) {
		#if defined(glGetLightxOES)
			return glGetLightxOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLightxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLightxv(enums::LightName light, enums::LightParameter pname, GLfixed* params) {
		#if defined(glGetLightxv)
			return glGetLightxv(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLightxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLightxvOES(enums::LightName light, enums::LightParameter pname, GLfixed* params) {
		#if defined(glGetLightxvOES)
			return glGetLightxvOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLightxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getListParameterfvSGIX(GLuint list, enums::ListParameterName pname, GLfloat* params) {
		#if defined(glGetListParameterfvSGIX)
			return glGetListParameterfvSGIX(list, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetListParameterfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getListParameterivSGIX(GLuint list, enums::ListParameterName pname, GLint* params) {
		#if defined(glGetListParameterivSGIX)
			return glGetListParameterivSGIX(list, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetListParameterivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLocalConstantBooleanvEXT(GLuint id, enums::GetVariantValueEXT value, GLboolean* data) {
		#if defined(glGetLocalConstantBooleanvEXT)
			return glGetLocalConstantBooleanvEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLocalConstantBooleanvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLocalConstantFloatvEXT(GLuint id, enums::GetVariantValueEXT value, GLfloat* data) {
		#if defined(glGetLocalConstantFloatvEXT)
			return glGetLocalConstantFloatvEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLocalConstantFloatvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getLocalConstantIntegervEXT(GLuint id, enums::GetVariantValueEXT value, GLint* data) {
		#if defined(glGetLocalConstantIntegervEXT)
			return glGetLocalConstantIntegervEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetLocalConstantIntegervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapAttribParameterfvNV(enums::EvalTargetNV target, GLuint index, enums::MapAttribParameterNV pname, GLfloat* params) {
		#if defined(glGetMapAttribParameterfvNV)
			return glGetMapAttribParameterfvNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapAttribParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapAttribParameterivNV(enums::EvalTargetNV target, GLuint index, enums::MapAttribParameterNV pname, GLint* params) {
		#if defined(glGetMapAttribParameterivNV)
			return glGetMapAttribParameterivNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapAttribParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapControlPointsNV(enums::EvalTargetNV target, GLuint index, enums::MapTypeNV type, GLsizei ustride, GLsizei vstride, GLboolean packed, void * points) {
		#if defined(glGetMapControlPointsNV)
			return glGetMapControlPointsNV(static_cast<GLenum>(target), index, static_cast<GLenum>(type), ustride, vstride, packed, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapControlPointsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapParameterfvNV(enums::EvalTargetNV target, enums::MapParameterNV pname, GLfloat* params) {
		#if defined(glGetMapParameterfvNV)
			return glGetMapParameterfvNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapParameterivNV(enums::EvalTargetNV target, enums::MapParameterNV pname, GLint* params) {
		#if defined(glGetMapParameterivNV)
			return glGetMapParameterivNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapdv(enums::MapTarget target, enums::GetMapQuery query, GLdouble* v) {
		#if defined(glGetMapdv)
			return glGetMapdv(static_cast<GLenum>(target), static_cast<GLenum>(query), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapfv(enums::MapTarget target, enums::GetMapQuery query, GLfloat* v) {
		#if defined(glGetMapfv)
			return glGetMapfv(static_cast<GLenum>(target), static_cast<GLenum>(query), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapiv(enums::MapTarget target, enums::GetMapQuery query, GLint* v) {
		#if defined(glGetMapiv)
			return glGetMapiv(static_cast<GLenum>(target), static_cast<GLenum>(query), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMapxvOES(enums::MapTarget target, enums::GetMapQuery query, GLfixed* v) {
		#if defined(glGetMapxvOES)
			return glGetMapxvOES(static_cast<GLenum>(target), static_cast<GLenum>(query), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMapxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMaterialfv(enums::TriangleFace face, enums::MaterialParameter pname, GLfloat* params) {
		#if defined(glGetMaterialfv)
			return glGetMaterialfv(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMaterialfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMaterialiv(enums::TriangleFace face, enums::MaterialParameter pname, GLint* params) {
		#if defined(glGetMaterialiv)
			return glGetMaterialiv(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMaterialiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMaterialxOES(enums::TriangleFace face, enums::MaterialParameter pname, GLfixed param) {
		#if defined(glGetMaterialxOES)
			return glGetMaterialxOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMaterialxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMaterialxv(enums::TriangleFace face, enums::MaterialParameter pname, GLfixed* params) {
		#if defined(glGetMaterialxv)
			return glGetMaterialxv(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMaterialxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMaterialxvOES(enums::TriangleFace face, enums::MaterialParameter pname, GLfixed* params) {
		#if defined(glGetMaterialxvOES)
			return glGetMaterialxvOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMaterialxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMemoryObjectDetachedResourcesuivNV(GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint* params) {
		#if defined(glGetMemoryObjectDetachedResourcesuivNV)
			return glGetMemoryObjectDetachedResourcesuivNV(memory, pname, first, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMemoryObjectDetachedResourcesuivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMemoryObjectParameterivEXT(GLuint memoryObject, enums::MemoryObjectParameterName pname, GLint* params) {
		#if defined(glGetMemoryObjectParameterivEXT)
			return glGetMemoryObjectParameterivEXT(memoryObject, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMemoryObjectParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMinmax(enums::MinmaxTargetEXT target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, void * values) {
		#if defined(glGetMinmax)
			return glGetMinmax(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMinmax" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMinmaxEXT(enums::MinmaxTargetEXT target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, void * values) {
		#if defined(glGetMinmaxEXT)
			return glGetMinmaxEXT(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMinmaxEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMinmaxParameterfv(enums::MinmaxTargetEXT target, enums::GetMinmaxParameterPNameEXT pname, GLfloat* params) {
		#if defined(glGetMinmaxParameterfv)
			return glGetMinmaxParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMinmaxParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMinmaxParameterfvEXT(enums::MinmaxTargetEXT target, enums::GetMinmaxParameterPNameEXT pname, GLfloat* params) {
		#if defined(glGetMinmaxParameterfvEXT)
			return glGetMinmaxParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMinmaxParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMinmaxParameteriv(enums::MinmaxTargetEXT target, enums::GetMinmaxParameterPNameEXT pname, GLint* params) {
		#if defined(glGetMinmaxParameteriv)
			return glGetMinmaxParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMinmaxParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMinmaxParameterivEXT(enums::MinmaxTargetEXT target, enums::GetMinmaxParameterPNameEXT pname, GLint* params) {
		#if defined(glGetMinmaxParameterivEXT)
			return glGetMinmaxParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMinmaxParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexEnvfvEXT(enums::TextureUnit texunit, enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfloat* params) {
		#if defined(glGetMultiTexEnvfvEXT)
			return glGetMultiTexEnvfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexEnvfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexEnvivEXT(enums::TextureUnit texunit, enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLint* params) {
		#if defined(glGetMultiTexEnvivEXT)
			return glGetMultiTexEnvivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexEnvivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexGendvEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, GLdouble* params) {
		#if defined(glGetMultiTexGendvEXT)
			return glGetMultiTexGendvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexGendvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexGenfvEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfloat* params) {
		#if defined(glGetMultiTexGenfvEXT)
			return glGetMultiTexGenfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexGenfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexGenivEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, GLint* params) {
		#if defined(glGetMultiTexGenivEXT)
			return glGetMultiTexGenivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexGenivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexImageEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::PixelFormat format, enums::PixelType type, void * pixels) {
		#if defined(glGetMultiTexImageEXT)
			return glGetMultiTexImageEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexImageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexLevelParameterfvEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetMultiTexLevelParameterfvEXT)
			return glGetMultiTexLevelParameterfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexLevelParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexLevelParameterivEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetMultiTexLevelParameterivEXT)
			return glGetMultiTexLevelParameterivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexLevelParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexParameterIivEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetMultiTexParameterIivEXT)
			return glGetMultiTexParameterIivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexParameterIuivEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::GetTextureParameter pname, GLuint* params) {
		#if defined(glGetMultiTexParameterIuivEXT)
			return glGetMultiTexParameterIuivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexParameterfvEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetMultiTexParameterfvEXT)
			return glGetMultiTexParameterfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultiTexParameterivEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetMultiTexParameterivEXT)
			return glGetMultiTexParameterivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultiTexParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultisamplefv(enums::GetMultisamplePNameNV pname, GLuint index, GLfloat* val) {
		#if defined(glGetMultisamplefv)
			return glGetMultisamplefv(static_cast<GLenum>(pname), index, val);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultisamplefv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getMultisamplefvNV(enums::GetMultisamplePNameNV pname, GLuint index, GLfloat* val) {
		#if defined(glGetMultisamplefvNV)
			return glGetMultisamplefvNV(static_cast<GLenum>(pname), index, val);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetMultisamplefvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferParameteri64v(GLuint buffer, enums::BufferPNameARB pname, GLint64* params) {
		#if defined(glGetNamedBufferParameteri64v)
			return glGetNamedBufferParameteri64v(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferParameteri64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferParameteriv(GLuint buffer, enums::BufferPNameARB pname, GLint* params) {
		#if defined(glGetNamedBufferParameteriv)
			return glGetNamedBufferParameteriv(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferParameterivEXT(GLuint buffer, enums::BufferPNameARB pname, GLint* params) {
		#if defined(glGetNamedBufferParameterivEXT)
			return glGetNamedBufferParameterivEXT(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferParameterui64vNV(GLuint buffer, enums::BufferPNameARB pname, GLuint64EXT* params) {
		#if defined(glGetNamedBufferParameterui64vNV)
			return glGetNamedBufferParameterui64vNV(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferParameterui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferPointerv(GLuint buffer, enums::BufferPointerNameARB pname, void ** params) {
		#if defined(glGetNamedBufferPointerv)
			return glGetNamedBufferPointerv(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferPointerv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferPointervEXT(GLuint buffer, enums::BufferPointerNameARB pname, void ** params) {
		#if defined(glGetNamedBufferPointervEXT)
			return glGetNamedBufferPointervEXT(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferPointervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data) {
		#if defined(glGetNamedBufferSubData)
			return glGetNamedBufferSubData(buffer, offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, void * data) {
		#if defined(glGetNamedBufferSubDataEXT)
			return glGetNamedBufferSubDataEXT(buffer, offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedBufferSubDataEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedFramebufferParameterfvAMD(GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values) {
		#if defined(glGetNamedFramebufferParameterfvAMD)
			return glGetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedFramebufferParameterfvAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedFramebufferAttachmentParameteriv(GLuint framebuffer, enums::FramebufferAttachment attachment, enums::FramebufferAttachmentParameterName pname, GLint* params) {
		#if defined(glGetNamedFramebufferAttachmentParameteriv)
			return glGetNamedFramebufferAttachmentParameteriv(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedFramebufferAttachmentParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, enums::FramebufferAttachmentParameterName pname, GLint* params) {
		#if defined(glGetNamedFramebufferAttachmentParameterivEXT)
			return glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedFramebufferAttachmentParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedFramebufferParameteriv(GLuint framebuffer, enums::GetFramebufferParameter pname, GLint* param) {
		#if defined(glGetNamedFramebufferParameteriv)
			return glGetNamedFramebufferParameteriv(framebuffer, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedFramebufferParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedFramebufferParameterivEXT(GLuint framebuffer, enums::GetFramebufferParameter pname, GLint* params) {
		#if defined(glGetNamedFramebufferParameterivEXT)
			return glGetNamedFramebufferParameterivEXT(framebuffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedFramebufferParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedProgramLocalParameterIivEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLint* params) {
		#if defined(glGetNamedProgramLocalParameterIivEXT)
			return glGetNamedProgramLocalParameterIivEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedProgramLocalParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedProgramLocalParameterIuivEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLuint* params) {
		#if defined(glGetNamedProgramLocalParameterIuivEXT)
			return glGetNamedProgramLocalParameterIuivEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedProgramLocalParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedProgramLocalParameterdvEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLdouble* params) {
		#if defined(glGetNamedProgramLocalParameterdvEXT)
			return glGetNamedProgramLocalParameterdvEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedProgramLocalParameterdvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedProgramLocalParameterfvEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLfloat* params) {
		#if defined(glGetNamedProgramLocalParameterfvEXT)
			return glGetNamedProgramLocalParameterfvEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedProgramLocalParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedProgramStringEXT(GLuint program, enums::ProgramTarget target, enums::ProgramStringProperty pname, void * string) {
		#if defined(glGetNamedProgramStringEXT)
			return glGetNamedProgramStringEXT(program, static_cast<GLenum>(target), static_cast<GLenum>(pname), string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedProgramStringEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedProgramivEXT(GLuint program, enums::ProgramTarget target, enums::ProgramPropertyARB pname, GLint* params) {
		#if defined(glGetNamedProgramivEXT)
			return glGetNamedProgramivEXT(program, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedProgramivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedRenderbufferParameteriv(GLuint renderbuffer, enums::RenderbufferParameterName pname, GLint* params) {
		#if defined(glGetNamedRenderbufferParameteriv)
			return glGetNamedRenderbufferParameteriv(renderbuffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedRenderbufferParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedRenderbufferParameterivEXT(GLuint renderbuffer, enums::RenderbufferParameterName pname, GLint* params) {
		#if defined(glGetNamedRenderbufferParameterivEXT)
			return glGetNamedRenderbufferParameterivEXT(renderbuffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedRenderbufferParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedStringARB(GLint namelen, const GLchar* name, GLsizei bufSize, GLint* stringlen, GLchar* string) {
		#if defined(glGetNamedStringARB)
			return glGetNamedStringARB(namelen, name, bufSize, stringlen, string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedStringARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNamedStringivARB(GLint namelen, const GLchar* name, GLenum pname, GLint* params) {
		#if defined(glGetNamedStringivARB)
			return glGetNamedStringivARB(namelen, name, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNamedStringivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getNextPerfQueryIdINTEL(GLuint queryId, GLuint* nextQueryId) {
		#if defined(glGetNextPerfQueryIdINTEL)
			return glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetNextPerfQueryIdINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectBufferfvATI(GLuint buffer, enums::ArrayObjectPNameATI pname, GLfloat* params) {
		#if defined(glGetObjectBufferfvATI)
			return glGetObjectBufferfvATI(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectBufferfvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectBufferivATI(GLuint buffer, enums::ArrayObjectPNameATI pname, GLint* params) {
		#if defined(glGetObjectBufferivATI)
			return glGetObjectBufferivATI(buffer, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectBufferivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectLabel(enums::ObjectIdentifier identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label) {
		#if defined(glGetObjectLabel)
			return glGetObjectLabel(static_cast<GLenum>(identifier), name, bufSize, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectLabel" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar* label) {
		#if defined(glGetObjectLabelEXT)
			return glGetObjectLabelEXT(type, object, bufSize, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectLabelEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectLabelKHR(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar* label) {
		#if defined(glGetObjectLabelKHR)
			return glGetObjectLabelKHR(identifier, name, bufSize, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectLabelKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat* params) {
		#if defined(glGetObjectParameterfvARB)
			return glGetObjectParameterfvARB(obj, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectParameterfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint* params) {
		#if defined(glGetObjectParameterivAPPLE)
			return glGetObjectParameterivAPPLE(objectType, name, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectParameterivAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint* params) {
		#if defined(glGetObjectParameterivARB)
			return glGetObjectParameterivARB(obj, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectParameterivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectPtrLabel(const void * ptr, GLsizei bufSize, GLsizei* length, GLchar* label) {
		#if defined(glGetObjectPtrLabel)
			return glGetObjectPtrLabel(ptr, bufSize, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectPtrLabel" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getObjectPtrLabelKHR(const void * ptr, GLsizei bufSize, GLsizei* length, GLchar* label) {
		#if defined(glGetObjectPtrLabelKHR)
			return glGetObjectPtrLabelKHR(ptr, bufSize, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetObjectPtrLabelKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getOcclusionQueryivNV(GLuint id, enums::OcclusionQueryParameterNameNV pname, GLint* params) {
		#if defined(glGetOcclusionQueryivNV)
			return glGetOcclusionQueryivNV(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetOcclusionQueryivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getOcclusionQueryuivNV(GLuint id, enums::OcclusionQueryParameterNameNV pname, GLuint* params) {
		#if defined(glGetOcclusionQueryuivNV)
			return glGetOcclusionQueryuivNV(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetOcclusionQueryuivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathColorGenfvNV(enums::PathColor color, enums::PathGenMode pname, GLfloat* value) {
		#if defined(glGetPathColorGenfvNV)
			return glGetPathColorGenfvNV(static_cast<GLenum>(color), static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathColorGenfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathColorGenivNV(enums::PathColor color, enums::PathGenMode pname, GLint* value) {
		#if defined(glGetPathColorGenivNV)
			return glGetPathColorGenivNV(static_cast<GLenum>(color), static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathColorGenivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathCommandsNV(GLuint path, GLubyte* commands) {
		#if defined(glGetPathCommandsNV)
			return glGetPathCommandsNV(path, commands);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathCommandsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathCoordsNV(GLuint path, GLfloat* coords) {
		#if defined(glGetPathCoordsNV)
			return glGetPathCoordsNV(path, coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathCoordsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathDashArrayNV(GLuint path, GLfloat* dashArray) {
		#if defined(glGetPathDashArrayNV)
			return glGetPathDashArrayNV(path, dashArray);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathDashArrayNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLfloat getPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments) {
		#if defined(glGetPathLengthNV)
			return glGetPathLengthNV(path, startSegment, numSegments);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathLengthNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getPathMetricRangeNV(GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics) {
		#if defined(glGetPathMetricRangeNV)
			return glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathMetricRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, GLsizei stride, GLfloat* metrics) {
		#if defined(glGetPathMetricsNV)
			return glGetPathMetricsNV(metricQueryMask, numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, stride, metrics);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathMetricsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathParameterfvNV(GLuint path, enums::PathParameter pname, GLfloat* value) {
		#if defined(glGetPathParameterfvNV)
			return glGetPathParameterfvNV(path, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathParameterivNV(GLuint path, enums::PathParameter pname, GLint* value) {
		#if defined(glGetPathParameterivNV)
			return glGetPathParameterivNV(path, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathSpacingNV(enums::PathListMode pathListMode, GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, enums::PathTransformType transformType, GLfloat* returnedSpacing) {
		#if defined(glGetPathSpacingNV)
			return glGetPathSpacingNV(static_cast<GLenum>(pathListMode), numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, advanceScale, kerningScale, static_cast<GLenum>(transformType), returnedSpacing);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathSpacingNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathTexGenfvNV(enums::TextureUnit texCoordSet, enums::PathGenMode pname, GLfloat* value) {
		#if defined(glGetPathTexGenfvNV)
			return glGetPathTexGenfvNV(static_cast<GLenum>(texCoordSet), static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathTexGenfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPathTexGenivNV(enums::TextureUnit texCoordSet, enums::PathGenMode pname, GLint* value) {
		#if defined(glGetPathTexGenivNV)
			return glGetPathTexGenivNV(static_cast<GLenum>(texCoordSet), static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPathTexGenivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfCounterInfoINTEL(GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar* counterDesc, GLuint* counterOffset, GLuint* counterDataSize, GLuint* counterTypeEnum, GLuint* counterDataTypeEnum, GLuint64* rawCounterMaxValue) {
		#if defined(glGetPerfCounterInfoINTEL)
			return glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfCounterInfoINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint* bytesWritten) {
		#if defined(glGetPerfMonitorCounterDataAMD)
			return glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfMonitorCounterDataAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, void * data) {
		#if defined(glGetPerfMonitorCounterInfoAMD)
			return glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfMonitorCounterInfoAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar* counterString) {
		#if defined(glGetPerfMonitorCounterStringAMD)
			return glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfMonitorCounterStringAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfMonitorCountersAMD(GLuint group, GLint* numCounters, GLint* maxActiveCounters, GLsizei counterSize, GLuint* counters) {
		#if defined(glGetPerfMonitorCountersAMD)
			return glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfMonitorCountersAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei* length, GLchar* groupString) {
		#if defined(glGetPerfMonitorGroupStringAMD)
			return glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfMonitorGroupStringAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfMonitorGroupsAMD(GLint* numGroups, GLsizei groupsSize, GLuint* groups) {
		#if defined(glGetPerfMonitorGroupsAMD)
			return glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfMonitorGroupsAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfQueryDataINTEL(GLuint queryHandle, GLuint flags, GLsizei dataSize, void * data, GLuint* bytesWritten) {
		#if defined(glGetPerfQueryDataINTEL)
			return glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfQueryDataINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfQueryIdByNameINTEL(GLchar* queryName, GLuint* queryId) {
		#if defined(glGetPerfQueryIdByNameINTEL)
			return glGetPerfQueryIdByNameINTEL(queryName, queryId);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfQueryIdByNameINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPerfQueryInfoINTEL(GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint* dataSize, GLuint* noCounters, GLuint* noInstances, GLuint* capsMask) {
		#if defined(glGetPerfQueryInfoINTEL)
			return glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPerfQueryInfoINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelMapfv(enums::PixelMap map, GLfloat* values) {
		#if defined(glGetPixelMapfv)
			return glGetPixelMapfv(static_cast<GLenum>(map), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelMapfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelMapuiv(enums::PixelMap map, GLuint* values) {
		#if defined(glGetPixelMapuiv)
			return glGetPixelMapuiv(static_cast<GLenum>(map), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelMapuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelMapusv(enums::PixelMap map, GLushort* values) {
		#if defined(glGetPixelMapusv)
			return glGetPixelMapusv(static_cast<GLenum>(map), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelMapusv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelMapxv(enums::PixelMap map, GLint size, GLfixed* values) {
		#if defined(glGetPixelMapxv)
			return glGetPixelMapxv(static_cast<GLenum>(map), size, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelMapxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelTexGenParameterfvSGIS(enums::PixelTexGenParameterNameSGIS pname, GLfloat* params) {
		#if defined(glGetPixelTexGenParameterfvSGIS)
			return glGetPixelTexGenParameterfvSGIS(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelTexGenParameterfvSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelTexGenParameterivSGIS(enums::PixelTexGenParameterNameSGIS pname, GLint* params) {
		#if defined(glGetPixelTexGenParameterivSGIS)
			return glGetPixelTexGenParameterivSGIS(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelTexGenParameterivSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat* params) {
		#if defined(glGetPixelTransformParameterfvEXT)
			return glGetPixelTransformParameterfvEXT(target, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelTransformParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint* params) {
		#if defined(glGetPixelTransformParameterivEXT)
			return glGetPixelTransformParameterivEXT(target, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPixelTransformParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPointerIndexedvEXT(GLenum target, GLuint index, void ** data) {
		#if defined(glGetPointerIndexedvEXT)
			return glGetPointerIndexedvEXT(target, index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPointerIndexedvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPointeri_vEXT(GLenum pname, GLuint index, void ** params) {
		#if defined(glGetPointeri_vEXT)
			return glGetPointeri_vEXT(pname, index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPointeri_vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPointerv(enums::GetPointervPName pname, void ** params) {
		#if defined(glGetPointerv)
			return glGetPointerv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPointerv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPointervEXT(enums::GetPointervPName pname, void ** params) {
		#if defined(glGetPointervEXT)
			return glGetPointervEXT(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPointervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPointervKHR(GLenum pname, void ** params) {
		#if defined(glGetPointervKHR)
			return glGetPointervKHR(pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPointervKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getPolygonStipple(GLubyte* mask) {
		#if defined(glGetPolygonStipple)
			return glGetPolygonStipple(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetPolygonStipple" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramBinary(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void * binary) {
		#if defined(glGetProgramBinary)
			return glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramBinary" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei* length, GLenum* binaryFormat, void * binary) {
		#if defined(glGetProgramBinaryOES)
			return glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramBinaryOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramEnvParameterIivNV(enums::ProgramTarget target, GLuint index, GLint* params) {
		#if defined(glGetProgramEnvParameterIivNV)
			return glGetProgramEnvParameterIivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramEnvParameterIivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramEnvParameterIuivNV(enums::ProgramTarget target, GLuint index, GLuint* params) {
		#if defined(glGetProgramEnvParameterIuivNV)
			return glGetProgramEnvParameterIuivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramEnvParameterIuivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramEnvParameterdvARB(enums::ProgramTarget target, GLuint index, GLdouble* params) {
		#if defined(glGetProgramEnvParameterdvARB)
			return glGetProgramEnvParameterdvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramEnvParameterdvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramEnvParameterfvARB(enums::ProgramTarget target, GLuint index, GLfloat* params) {
		#if defined(glGetProgramEnvParameterfvARB)
			return glGetProgramEnvParameterfvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramEnvParameterfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
		#if defined(glGetProgramInfoLog)
			return glGetProgramInfoLog(program, bufSize, length, infoLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramInfoLog" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramInterfaceiv(GLuint program, enums::ProgramInterface programInterface, enums::ProgramInterfacePName pname, GLint* params) {
		#if defined(glGetProgramInterfaceiv)
			return glGetProgramInterfaceiv(program, static_cast<GLenum>(programInterface), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramInterfaceiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramLocalParameterIivNV(enums::ProgramTarget target, GLuint index, GLint* params) {
		#if defined(glGetProgramLocalParameterIivNV)
			return glGetProgramLocalParameterIivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramLocalParameterIivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramLocalParameterIuivNV(enums::ProgramTarget target, GLuint index, GLuint* params) {
		#if defined(glGetProgramLocalParameterIuivNV)
			return glGetProgramLocalParameterIuivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramLocalParameterIuivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramLocalParameterdvARB(enums::ProgramTarget target, GLuint index, GLdouble* params) {
		#if defined(glGetProgramLocalParameterdvARB)
			return glGetProgramLocalParameterdvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramLocalParameterdvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramLocalParameterfvARB(enums::ProgramTarget target, GLuint index, GLfloat* params) {
		#if defined(glGetProgramLocalParameterfvARB)
			return glGetProgramLocalParameterfvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramLocalParameterfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte* name, GLdouble* params) {
		#if defined(glGetProgramNamedParameterdvNV)
			return glGetProgramNamedParameterdvNV(id, len, name, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramNamedParameterdvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte* name, GLfloat* params) {
		#if defined(glGetProgramNamedParameterfvNV)
			return glGetProgramNamedParameterfvNV(id, len, name, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramNamedParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramParameterdvNV(enums::VertexAttribEnumNV target, GLuint index, enums::VertexAttribEnumNV pname, GLdouble* params) {
		#if defined(glGetProgramParameterdvNV)
			return glGetProgramParameterdvNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramParameterdvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramParameterfvNV(enums::VertexAttribEnumNV target, GLuint index, enums::VertexAttribEnumNV pname, GLfloat* params) {
		#if defined(glGetProgramParameterfvNV)
			return glGetProgramParameterfvNV(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
		#if defined(glGetProgramPipelineInfoLog)
			return glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramPipelineInfoLog" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
		#if defined(glGetProgramPipelineInfoLogEXT)
			return glGetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramPipelineInfoLogEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramPipelineiv(GLuint pipeline, enums::PipelineParameterName pname, GLint* params) {
		#if defined(glGetProgramPipelineiv)
			return glGetProgramPipelineiv(pipeline, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramPipelineiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramPipelineivEXT(GLuint pipeline, enums::PipelineParameterName pname, GLint* params) {
		#if defined(glGetProgramPipelineivEXT)
			return glGetProgramPipelineivEXT(pipeline, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramPipelineivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint getProgramResourceIndex(GLuint program, enums::ProgramInterface programInterface, const GLchar* name) {
		#if defined(glGetProgramResourceIndex)
			return glGetProgramResourceIndex(program, static_cast<GLenum>(programInterface), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramResourceIndex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getProgramResourceLocation(GLuint program, enums::ProgramInterface programInterface, const GLchar* name) {
		#if defined(glGetProgramResourceLocation)
			return glGetProgramResourceLocation(program, static_cast<GLenum>(programInterface), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramResourceLocation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getProgramResourceLocationIndex(GLuint program, enums::ProgramInterface programInterface, const GLchar* name) {
		#if defined(glGetProgramResourceLocationIndex)
			return glGetProgramResourceLocationIndex(program, static_cast<GLenum>(programInterface), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramResourceLocationIndex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getProgramResourceLocationIndexEXT(GLuint program, enums::ProgramInterface programInterface, const GLchar* name) {
		#if defined(glGetProgramResourceLocationIndexEXT)
			return glGetProgramResourceLocationIndexEXT(program, static_cast<GLenum>(programInterface), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramResourceLocationIndexEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getProgramResourceName(GLuint program, enums::ProgramInterface programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar* name) {
		#if defined(glGetProgramResourceName)
			return glGetProgramResourceName(program, static_cast<GLenum>(programInterface), index, bufSize, length, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramResourceName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramResourcefvNV(GLuint program, enums::ProgramInterface programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei count, GLsizei* length, GLfloat* params) {
		#if defined(glGetProgramResourcefvNV)
			return glGetProgramResourcefvNV(program, static_cast<GLenum>(programInterface), index, propCount, props, count, length, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramResourcefvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramResourceiv(GLuint program, enums::ProgramInterface programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei count, GLsizei* length, GLint* params) {
		#if defined(glGetProgramResourceiv)
			return glGetProgramResourceiv(program, static_cast<GLenum>(programInterface), index, propCount, props, count, length, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramResourceiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramStageiv(GLuint program, enums::ShaderType shadertype, enums::ProgramStagePName pname, GLint* values) {
		#if defined(glGetProgramStageiv)
			return glGetProgramStageiv(program, static_cast<GLenum>(shadertype), static_cast<GLenum>(pname), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramStageiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramStringARB(enums::ProgramTarget target, enums::ProgramStringProperty pname, void * string) {
		#if defined(glGetProgramStringARB)
			return glGetProgramStringARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramStringARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramStringNV(GLuint id, enums::VertexAttribEnumNV pname, GLubyte* program) {
		#if defined(glGetProgramStringNV)
			return glGetProgramStringNV(id, static_cast<GLenum>(pname), program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramStringNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint* param) {
		#if defined(glGetProgramSubroutineParameteruivNV)
			return glGetProgramSubroutineParameteruivNV(target, index, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramSubroutineParameteruivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramiv(GLuint program, enums::ProgramPropertyARB pname, GLint* params) {
		#if defined(glGetProgramiv)
			return glGetProgramiv(program, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramivARB(enums::ProgramTarget target, enums::ProgramPropertyARB pname, GLint* params) {
		#if defined(glGetProgramivARB)
			return glGetProgramivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getProgramivNV(GLuint id, enums::VertexAttribEnumNV pname, GLint* params) {
		#if defined(glGetProgramivNV)
			return glGetProgramivNV(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetProgramivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryBufferObjecti64v(GLuint id, GLuint buffer, enums::QueryObjectParameterName pname, GLintptr offset) {
		#if defined(glGetQueryBufferObjecti64v)
			return glGetQueryBufferObjecti64v(id, buffer, static_cast<GLenum>(pname), offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryBufferObjecti64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryBufferObjectiv(GLuint id, GLuint buffer, enums::QueryObjectParameterName pname, GLintptr offset) {
		#if defined(glGetQueryBufferObjectiv)
			return glGetQueryBufferObjectiv(id, buffer, static_cast<GLenum>(pname), offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryBufferObjectiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryBufferObjectui64v(GLuint id, GLuint buffer, enums::QueryObjectParameterName pname, GLintptr offset) {
		#if defined(glGetQueryBufferObjectui64v)
			return glGetQueryBufferObjectui64v(id, buffer, static_cast<GLenum>(pname), offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryBufferObjectui64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryBufferObjectuiv(GLuint id, GLuint buffer, enums::QueryObjectParameterName pname, GLintptr offset) {
		#if defined(glGetQueryBufferObjectuiv)
			return glGetQueryBufferObjectuiv(id, buffer, static_cast<GLenum>(pname), offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryBufferObjectuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryIndexediv(enums::QueryTarget target, GLuint index, enums::QueryParameterName pname, GLint* params) {
		#if defined(glGetQueryIndexediv)
			return glGetQueryIndexediv(static_cast<GLenum>(target), index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryIndexediv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjecti64v(GLuint id, enums::QueryObjectParameterName pname, GLint64* params) {
		#if defined(glGetQueryObjecti64v)
			return glGetQueryObjecti64v(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjecti64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjecti64vEXT(GLuint id, enums::QueryObjectParameterName pname, GLint64* params) {
		#if defined(glGetQueryObjecti64vEXT)
			return glGetQueryObjecti64vEXT(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjecti64vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectiv(GLuint id, enums::QueryObjectParameterName pname, GLint* params) {
		#if defined(glGetQueryObjectiv)
			return glGetQueryObjectiv(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectivARB(GLuint id, enums::QueryObjectParameterName pname, GLint* params) {
		#if defined(glGetQueryObjectivARB)
			return glGetQueryObjectivARB(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectivEXT(GLuint id, enums::QueryObjectParameterName pname, GLint* params) {
		#if defined(glGetQueryObjectivEXT)
			return glGetQueryObjectivEXT(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectui64v(GLuint id, enums::QueryObjectParameterName pname, GLuint64* params) {
		#if defined(glGetQueryObjectui64v)
			return glGetQueryObjectui64v(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectui64v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectui64vEXT(GLuint id, enums::QueryObjectParameterName pname, GLuint64* params) {
		#if defined(glGetQueryObjectui64vEXT)
			return glGetQueryObjectui64vEXT(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectui64vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectuiv(GLuint id, enums::QueryObjectParameterName pname, GLuint* params) {
		#if defined(glGetQueryObjectuiv)
			return glGetQueryObjectuiv(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectuivARB(GLuint id, enums::QueryObjectParameterName pname, GLuint* params) {
		#if defined(glGetQueryObjectuivARB)
			return glGetQueryObjectuivARB(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectuivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryObjectuivEXT(GLuint id, enums::QueryObjectParameterName pname, GLuint* params) {
		#if defined(glGetQueryObjectuivEXT)
			return glGetQueryObjectuivEXT(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryObjectuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryiv(enums::QueryTarget target, enums::QueryParameterName pname, GLint* params) {
		#if defined(glGetQueryiv)
			return glGetQueryiv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryivARB(enums::QueryTarget target, enums::QueryParameterName pname, GLint* params) {
		#if defined(glGetQueryivARB)
			return glGetQueryivARB(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getQueryivEXT(enums::QueryTarget target, enums::QueryParameterName pname, GLint* params) {
		#if defined(glGetQueryivEXT)
			return glGetQueryivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetQueryivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getRenderbufferParameteriv(enums::RenderbufferTarget target, enums::RenderbufferParameterName pname, GLint* params) {
		#if defined(glGetRenderbufferParameteriv)
			return glGetRenderbufferParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetRenderbufferParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getRenderbufferParameterivEXT(enums::RenderbufferTarget target, enums::RenderbufferParameterName pname, GLint* params) {
		#if defined(glGetRenderbufferParameterivEXT)
			return glGetRenderbufferParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetRenderbufferParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getRenderbufferParameterivOES(enums::RenderbufferTarget target, enums::RenderbufferParameterName pname, GLint* params) {
		#if defined(glGetRenderbufferParameterivOES)
			return glGetRenderbufferParameterivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetRenderbufferParameterivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameterIiv(GLuint sampler, enums::SamplerParameterI pname, GLint* params) {
		#if defined(glGetSamplerParameterIiv)
			return glGetSamplerParameterIiv(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameterIiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameterIivEXT(GLuint sampler, enums::SamplerParameterI pname, GLint* params) {
		#if defined(glGetSamplerParameterIivEXT)
			return glGetSamplerParameterIivEXT(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameterIivOES(GLuint sampler, enums::SamplerParameterI pname, GLint* params) {
		#if defined(glGetSamplerParameterIivOES)
			return glGetSamplerParameterIivOES(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameterIivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameterIuiv(GLuint sampler, enums::SamplerParameterI pname, GLuint* params) {
		#if defined(glGetSamplerParameterIuiv)
			return glGetSamplerParameterIuiv(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameterIuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameterIuivEXT(GLuint sampler, enums::SamplerParameterI pname, GLuint* params) {
		#if defined(glGetSamplerParameterIuivEXT)
			return glGetSamplerParameterIuivEXT(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameterIuivOES(GLuint sampler, enums::SamplerParameterI pname, GLuint* params) {
		#if defined(glGetSamplerParameterIuivOES)
			return glGetSamplerParameterIuivOES(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameterIuivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameterfv(GLuint sampler, enums::SamplerParameterF pname, GLfloat* params) {
		#if defined(glGetSamplerParameterfv)
			return glGetSamplerParameterfv(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSamplerParameteriv(GLuint sampler, enums::SamplerParameterI pname, GLint* params) {
		#if defined(glGetSamplerParameteriv)
			return glGetSamplerParameteriv(sampler, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSamplerParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSemaphoreParameterivNV(GLuint semaphore, enums::SemaphoreParameterName pname, GLint* params) {
		#if defined(glGetSemaphoreParameterivNV)
			return glGetSemaphoreParameterivNV(semaphore, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSemaphoreParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSemaphoreParameterui64vEXT(GLuint semaphore, enums::SemaphoreParameterName pname, GLuint64* params) {
		#if defined(glGetSemaphoreParameterui64vEXT)
			return glGetSemaphoreParameterui64vEXT(semaphore, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSemaphoreParameterui64vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSeparableFilter(enums::SeparableTargetEXT target, enums::PixelFormat format, enums::PixelType type, void * row, void * column, void * span) {
		#if defined(glGetSeparableFilter)
			return glGetSeparableFilter(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), row, column, span);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSeparableFilter" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSeparableFilterEXT(enums::SeparableTargetEXT target, enums::PixelFormat format, enums::PixelType type, void * row, void * column, void * span) {
		#if defined(glGetSeparableFilterEXT)
			return glGetSeparableFilterEXT(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), row, column, span);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSeparableFilterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
		#if defined(glGetShaderInfoLog)
			return glGetShaderInfoLog(shader, bufSize, length, infoLog);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetShaderInfoLog" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getShaderPrecisionFormat(enums::ShaderType shadertype, enums::PrecisionType precisiontype, GLint* range, GLint* precision) {
		#if defined(glGetShaderPrecisionFormat)
			return glGetShaderPrecisionFormat(static_cast<GLenum>(shadertype), static_cast<GLenum>(precisiontype), range, precision);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetShaderPrecisionFormat" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getShaderSource(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source) {
		#if defined(glGetShaderSource)
			return glGetShaderSource(shader, bufSize, length, source);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetShaderSource" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB* source) {
		#if defined(glGetShaderSourceARB)
			return glGetShaderSourceARB(obj, maxLength, length, source);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetShaderSourceARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getShaderiv(GLuint shader, enums::ShaderParameterName pname, GLint* params) {
		#if defined(glGetShaderiv)
			return glGetShaderiv(shader, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetShaderiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getShadingRateImagePaletteNV(GLuint viewport, GLuint entry, GLenum* rate) {
		#if defined(glGetShadingRateImagePaletteNV)
			return glGetShadingRateImagePaletteNV(viewport, entry, rate);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetShadingRateImagePaletteNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getShadingRateSampleLocationivNV(GLenum rate, GLuint samples, GLuint index, GLint* location) {
		#if defined(glGetShadingRateSampleLocationivNV)
			return glGetShadingRateSampleLocationivNV(rate, samples, index, location);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetShadingRateSampleLocationivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSharpenTexFuncSGIS(enums::TextureTarget target, GLfloat* points) {
		#if defined(glGetSharpenTexFuncSGIS)
			return glGetSharpenTexFuncSGIS(static_cast<GLenum>(target), points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSharpenTexFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLushort getStageIndexNV(enums::ShaderType shadertype) {
		#if defined(glGetStageIndexNV)
			return glGetStageIndexNV(static_cast<GLenum>(shadertype));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetStageIndexNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline const GLubyte* getString(enums::StringName name) {
		#if defined(glGetString)
			return glGetString(static_cast<GLenum>(name));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetString" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline const GLubyte* getStringi(enums::StringName name, GLuint index) {
		#if defined(glGetStringi)
			return glGetStringi(static_cast<GLenum>(name), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetStringi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint getSubroutineIndex(GLuint program, enums::ShaderType shadertype, const GLchar* name) {
		#if defined(glGetSubroutineIndex)
			return glGetSubroutineIndex(program, static_cast<GLenum>(shadertype), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSubroutineIndex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getSubroutineUniformLocation(GLuint program, enums::ShaderType shadertype, const GLchar* name) {
		#if defined(glGetSubroutineUniformLocation)
			return glGetSubroutineUniformLocation(program, static_cast<GLenum>(shadertype), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSubroutineUniformLocation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getSynciv(GLsync sync, enums::SyncParameterName pname, GLsizei count, GLsizei* length, GLint* values) {
		#if defined(glGetSynciv)
			return glGetSynciv(sync, static_cast<GLenum>(pname), count, length, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSynciv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getSyncivAPPLE(GLsync sync, enums::SyncParameterName pname, GLsizei count, GLsizei* length, GLint* values) {
		#if defined(glGetSyncivAPPLE)
			return glGetSyncivAPPLE(sync, static_cast<GLenum>(pname), count, length, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetSyncivAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexBumpParameterfvATI(enums::GetTexBumpParameterATI pname, GLfloat* param) {
		#if defined(glGetTexBumpParameterfvATI)
			return glGetTexBumpParameterfvATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexBumpParameterfvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexBumpParameterivATI(enums::GetTexBumpParameterATI pname, GLint* param) {
		#if defined(glGetTexBumpParameterivATI)
			return glGetTexBumpParameterivATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexBumpParameterivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexEnvfv(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfloat* params) {
		#if defined(glGetTexEnvfv)
			return glGetTexEnvfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexEnvfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexEnviv(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLint* params) {
		#if defined(glGetTexEnviv)
			return glGetTexEnviv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexEnviv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexEnvxv(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfixed* params) {
		#if defined(glGetTexEnvxv)
			return glGetTexEnvxv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexEnvxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexEnvxvOES(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfixed* params) {
		#if defined(glGetTexEnvxvOES)
			return glGetTexEnvxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexEnvxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexFilterFuncSGIS(enums::TextureTarget target, enums::TextureFilterSGIS filter, GLfloat* weights) {
		#if defined(glGetTexFilterFuncSGIS)
			return glGetTexFilterFuncSGIS(static_cast<GLenum>(target), static_cast<GLenum>(filter), weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexFilterFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexGendv(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLdouble* params) {
		#if defined(glGetTexGendv)
			return glGetTexGendv(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexGendv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexGenfv(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfloat* params) {
		#if defined(glGetTexGenfv)
			return glGetTexGenfv(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexGenfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexGenfvOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfloat* params) {
		#if defined(glGetTexGenfvOES)
			return glGetTexGenfvOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexGenfvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexGeniv(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLint* params) {
		#if defined(glGetTexGeniv)
			return glGetTexGeniv(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexGeniv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexGenivOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLint* params) {
		#if defined(glGetTexGenivOES)
			return glGetTexGenivOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexGenivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexGenxvOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfixed* params) {
		#if defined(glGetTexGenxvOES)
			return glGetTexGenxvOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexGenxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexImage(enums::TextureTarget target, GLint level, enums::PixelFormat format, enums::PixelType type, void * pixels) {
		#if defined(glGetTexImage)
			return glGetTexImage(static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexLevelParameterfv(enums::TextureTarget target, GLint level, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetTexLevelParameterfv)
			return glGetTexLevelParameterfv(static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexLevelParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexLevelParameteriv(enums::TextureTarget target, GLint level, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTexLevelParameteriv)
			return glGetTexLevelParameteriv(static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexLevelParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexLevelParameterxvOES(enums::TextureTarget target, GLint level, enums::GetTextureParameter pname, GLfixed* params) {
		#if defined(glGetTexLevelParameterxvOES)
			return glGetTexLevelParameterxvOES(static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexLevelParameterxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterIiv(enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTexParameterIiv)
			return glGetTexParameterIiv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterIiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterIivEXT(enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTexParameterIivEXT)
			return glGetTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterIivOES(enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTexParameterIivOES)
			return glGetTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterIivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterIuiv(enums::TextureTarget target, enums::GetTextureParameter pname, GLuint* params) {
		#if defined(glGetTexParameterIuiv)
			return glGetTexParameterIuiv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterIuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterIuivEXT(enums::TextureTarget target, enums::GetTextureParameter pname, GLuint* params) {
		#if defined(glGetTexParameterIuivEXT)
			return glGetTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterIuivOES(enums::TextureTarget target, enums::GetTextureParameter pname, GLuint* params) {
		#if defined(glGetTexParameterIuivOES)
			return glGetTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterIuivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterPointervAPPLE(GLenum target, GLenum pname, void ** params) {
		#if defined(glGetTexParameterPointervAPPLE)
			return glGetTexParameterPointervAPPLE(target, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterPointervAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterfv(enums::TextureTarget target, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetTexParameterfv)
			return glGetTexParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameteriv(enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTexParameteriv)
			return glGetTexParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterxv(enums::TextureTarget target, enums::GetTextureParameter pname, GLfixed* params) {
		#if defined(glGetTexParameterxv)
			return glGetTexParameterxv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTexParameterxvOES(enums::TextureTarget target, enums::GetTextureParameter pname, GLfixed* params) {
		#if defined(glGetTexParameterxvOES)
			return glGetTexParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTexParameterxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint64 getTextureHandleARB(GLuint texture) {
		#if defined(glGetTextureHandleARB)
			return glGetTextureHandleARB(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureHandleARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint64 getTextureHandleIMG(GLuint texture) {
		#if defined(glGetTextureHandleIMG)
			return glGetTextureHandleIMG(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureHandleIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint64 getTextureHandleNV(GLuint texture) {
		#if defined(glGetTextureHandleNV)
			return glGetTextureHandleNV(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureHandleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getTextureImage(GLuint texture, GLint level, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * pixels) {
		#if defined(glGetTextureImage)
			return glGetTextureImage(texture, level, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureImageEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::PixelFormat format, enums::PixelType type, void * pixels) {
		#if defined(glGetTextureImageEXT)
			return glGetTextureImageEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureImageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureLevelParameterfv(GLuint texture, GLint level, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetTextureLevelParameterfv)
			return glGetTextureLevelParameterfv(texture, level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureLevelParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureLevelParameterfvEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetTextureLevelParameterfvEXT)
			return glGetTextureLevelParameterfvEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureLevelParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureLevelParameteriv(GLuint texture, GLint level, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTextureLevelParameteriv)
			return glGetTextureLevelParameteriv(texture, level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureLevelParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureLevelParameterivEXT(GLuint texture, enums::TextureTarget target, GLint level, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTextureLevelParameterivEXT)
			return glGetTextureLevelParameterivEXT(texture, static_cast<GLenum>(target), level, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureLevelParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameterIiv(GLuint texture, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTextureParameterIiv)
			return glGetTextureParameterIiv(texture, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameterIiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameterIivEXT(GLuint texture, enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTextureParameterIivEXT)
			return glGetTextureParameterIivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameterIuiv(GLuint texture, enums::GetTextureParameter pname, GLuint* params) {
		#if defined(glGetTextureParameterIuiv)
			return glGetTextureParameterIuiv(texture, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameterIuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameterIuivEXT(GLuint texture, enums::TextureTarget target, enums::GetTextureParameter pname, GLuint* params) {
		#if defined(glGetTextureParameterIuivEXT)
			return glGetTextureParameterIuivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameterfv(GLuint texture, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetTextureParameterfv)
			return glGetTextureParameterfv(texture, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameterfvEXT(GLuint texture, enums::TextureTarget target, enums::GetTextureParameter pname, GLfloat* params) {
		#if defined(glGetTextureParameterfvEXT)
			return glGetTextureParameterfvEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameteriv(GLuint texture, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTextureParameteriv)
			return glGetTextureParameteriv(texture, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTextureParameterivEXT(GLuint texture, enums::TextureTarget target, enums::GetTextureParameter pname, GLint* params) {
		#if defined(glGetTextureParameterivEXT)
			return glGetTextureParameterivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint64 getTextureSamplerHandleARB(GLuint texture, GLuint sampler) {
		#if defined(glGetTextureSamplerHandleARB)
			return glGetTextureSamplerHandleARB(texture, sampler);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureSamplerHandleARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint64 getTextureSamplerHandleIMG(GLuint texture, GLuint sampler) {
		#if defined(glGetTextureSamplerHandleIMG)
			return glGetTextureSamplerHandleIMG(texture, sampler);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureSamplerHandleIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLuint64 getTextureSamplerHandleNV(GLuint texture, GLuint sampler) {
		#if defined(glGetTextureSamplerHandleNV)
			return glGetTextureSamplerHandleNV(texture, sampler);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureSamplerHandleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * pixels) {
		#if defined(glGetTextureSubImage)
			return glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTextureSubImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTrackMatrixivNV(enums::VertexAttribEnumNV target, GLuint address, enums::VertexAttribEnumNV pname, GLint* params) {
		#if defined(glGetTrackMatrixivNV)
			return glGetTrackMatrixivNV(static_cast<GLenum>(target), address, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTrackMatrixivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) {
		#if defined(glGetTransformFeedbackVarying)
			return glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTransformFeedbackVarying" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) {
		#if defined(glGetTransformFeedbackVaryingEXT)
			return glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTransformFeedbackVaryingEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint* location) {
		#if defined(glGetTransformFeedbackVaryingNV)
			return glGetTransformFeedbackVaryingNV(program, index, location);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTransformFeedbackVaryingNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTransformFeedbacki64_v(GLuint xfb, enums::TransformFeedbackPName pname, GLuint index, GLint64* param) {
		#if defined(glGetTransformFeedbacki64_v)
			return glGetTransformFeedbacki64_v(xfb, static_cast<GLenum>(pname), index, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTransformFeedbacki64_v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTransformFeedbacki_v(GLuint xfb, enums::TransformFeedbackPName pname, GLuint index, GLint* param) {
		#if defined(glGetTransformFeedbacki_v)
			return glGetTransformFeedbacki_v(xfb, static_cast<GLenum>(pname), index, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTransformFeedbacki_v" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTransformFeedbackiv(GLuint xfb, enums::TransformFeedbackPName pname, GLint* param) {
		#if defined(glGetTransformFeedbackiv)
			return glGetTransformFeedbackiv(xfb, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTransformFeedbackiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source) {
		#if defined(glGetTranslatedShaderSourceANGLE)
			return glGetTranslatedShaderSourceANGLE(shader, bufSize, length, source);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetTranslatedShaderSourceANGLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint getUniformBlockIndex(GLuint program, const GLchar* uniformBlockName) {
		#if defined(glGetUniformBlockIndex)
			return glGetUniformBlockIndex(program, uniformBlockName);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformBlockIndex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getUniformBufferSizeEXT(GLuint program, GLint location) {
		#if defined(glGetUniformBufferSizeEXT)
			return glGetUniformBufferSizeEXT(program, location);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformBufferSizeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getUniformIndices(GLuint program, GLsizei uniformCount, const GLchar*const* uniformNames, GLuint* uniformIndices) {
		#if defined(glGetUniformIndices)
			return glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformIndices" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint getUniformLocation(GLuint program, const GLchar* name) {
		#if defined(glGetUniformLocation)
			return glGetUniformLocation(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformLocation" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint getUniformLocationARB(GLhandleARB programObj, const GLcharARB* name) {
		#if defined(glGetUniformLocationARB)
			return glGetUniformLocationARB(programObj, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformLocationARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLintptr getUniformOffsetEXT(GLuint program, GLint location) {
		#if defined(glGetUniformOffsetEXT)
			return glGetUniformOffsetEXT(program, location);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getUniformSubroutineuiv(enums::ShaderType shadertype, GLint location, GLuint* params) {
		#if defined(glGetUniformSubroutineuiv)
			return glGetUniformSubroutineuiv(static_cast<GLenum>(shadertype), location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformSubroutineuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformdv(GLuint program, GLint location, GLdouble* params) {
		#if defined(glGetUniformdv)
			return glGetUniformdv(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformfv(GLuint program, GLint location, GLfloat* params) {
		#if defined(glGetUniformfv)
			return glGetUniformfv(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformfvARB(GLhandleARB programObj, GLint location, GLfloat* params) {
		#if defined(glGetUniformfvARB)
			return glGetUniformfvARB(programObj, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformi64vARB(GLuint program, GLint location, GLint64* params) {
		#if defined(glGetUniformi64vARB)
			return glGetUniformi64vARB(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformi64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformi64vNV(GLuint program, GLint location, GLint64EXT* params) {
		#if defined(glGetUniformi64vNV)
			return glGetUniformi64vNV(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformi64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformiv(GLuint program, GLint location, GLint* params) {
		#if defined(glGetUniformiv)
			return glGetUniformiv(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformivARB(GLhandleARB programObj, GLint location, GLint* params) {
		#if defined(glGetUniformivARB)
			return glGetUniformivARB(programObj, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformui64vARB(GLuint program, GLint location, GLuint64* params) {
		#if defined(glGetUniformui64vARB)
			return glGetUniformui64vARB(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformui64vNV(GLuint program, GLint location, GLuint64EXT* params) {
		#if defined(glGetUniformui64vNV)
			return glGetUniformui64vNV(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformuiv(GLuint program, GLint location, GLuint* params) {
		#if defined(glGetUniformuiv)
			return glGetUniformuiv(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUniformuivEXT(GLuint program, GLint location, GLuint* params) {
		#if defined(glGetUniformuivEXT)
			return glGetUniformuivEXT(program, location, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUniformuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUnsignedBytevEXT(enums::GetPName pname, GLubyte* data) {
		#if defined(glGetUnsignedBytevEXT)
			return glGetUnsignedBytevEXT(static_cast<GLenum>(pname), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUnsignedBytevEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getUnsignedBytei_vEXT(GLenum target, GLuint index, GLubyte* data) {
		#if defined(glGetUnsignedBytei_vEXT)
			return glGetUnsignedBytei_vEXT(target, index, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetUnsignedBytei_vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVariantArrayObjectfvATI(GLuint id, enums::ArrayObjectPNameATI pname, GLfloat* params) {
		#if defined(glGetVariantArrayObjectfvATI)
			return glGetVariantArrayObjectfvATI(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVariantArrayObjectfvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVariantArrayObjectivATI(GLuint id, enums::ArrayObjectPNameATI pname, GLint* params) {
		#if defined(glGetVariantArrayObjectivATI)
			return glGetVariantArrayObjectivATI(id, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVariantArrayObjectivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVariantBooleanvEXT(GLuint id, enums::GetVariantValueEXT value, GLboolean* data) {
		#if defined(glGetVariantBooleanvEXT)
			return glGetVariantBooleanvEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVariantBooleanvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVariantFloatvEXT(GLuint id, enums::GetVariantValueEXT value, GLfloat* data) {
		#if defined(glGetVariantFloatvEXT)
			return glGetVariantFloatvEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVariantFloatvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVariantIntegervEXT(GLuint id, enums::GetVariantValueEXT value, GLint* data) {
		#if defined(glGetVariantIntegervEXT)
			return glGetVariantIntegervEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVariantIntegervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVariantPointervEXT(GLuint id, enums::GetVariantValueEXT value, void ** data) {
		#if defined(glGetVariantPointervEXT)
			return glGetVariantPointervEXT(id, static_cast<GLenum>(value), data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVariantPointervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint getVaryingLocationNV(GLuint program, const GLchar* name) {
		#if defined(glGetVaryingLocationNV)
			return glGetVaryingLocationNV(program, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVaryingLocationNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void getVertexArrayIndexed64iv(GLuint vaobj, GLuint index, enums::VertexArrayPName pname, GLint64* param) {
		#if defined(glGetVertexArrayIndexed64iv)
			return glGetVertexArrayIndexed64iv(vaobj, index, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexArrayIndexed64iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexArrayIndexediv(GLuint vaobj, GLuint index, enums::VertexArrayPName pname, GLint* param) {
		#if defined(glGetVertexArrayIndexediv)
			return glGetVertexArrayIndexediv(vaobj, index, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexArrayIndexediv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, enums::VertexArrayPName pname, GLint* param) {
		#if defined(glGetVertexArrayIntegeri_vEXT)
			return glGetVertexArrayIntegeri_vEXT(vaobj, index, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexArrayIntegeri_vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexArrayIntegervEXT(GLuint vaobj, enums::VertexArrayPName pname, GLint* param) {
		#if defined(glGetVertexArrayIntegervEXT)
			return glGetVertexArrayIntegervEXT(vaobj, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexArrayIntegervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, enums::VertexArrayPName pname, void ** param) {
		#if defined(glGetVertexArrayPointeri_vEXT)
			return glGetVertexArrayPointeri_vEXT(vaobj, index, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexArrayPointeri_vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexArrayPointervEXT(GLuint vaobj, enums::VertexArrayPName pname, void ** param) {
		#if defined(glGetVertexArrayPointervEXT)
			return glGetVertexArrayPointervEXT(vaobj, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexArrayPointervEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexArrayiv(GLuint vaobj, enums::VertexArrayPName pname, GLint* param) {
		#if defined(glGetVertexArrayiv)
			return glGetVertexArrayiv(vaobj, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexArrayiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribArrayObjectfvATI(GLuint index, enums::ArrayObjectPNameATI pname, GLfloat* params) {
		#if defined(glGetVertexAttribArrayObjectfvATI)
			return glGetVertexAttribArrayObjectfvATI(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribArrayObjectfvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribArrayObjectivATI(GLuint index, enums::ArrayObjectPNameATI pname, GLint* params) {
		#if defined(glGetVertexAttribArrayObjectivATI)
			return glGetVertexAttribArrayObjectivATI(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribArrayObjectivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribIiv(GLuint index, enums::VertexAttribEnum pname, GLint* params) {
		#if defined(glGetVertexAttribIiv)
			return glGetVertexAttribIiv(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribIiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribIivEXT(GLuint index, enums::VertexAttribEnum pname, GLint* params) {
		#if defined(glGetVertexAttribIivEXT)
			return glGetVertexAttribIivEXT(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribIuiv(GLuint index, enums::VertexAttribEnum pname, GLuint* params) {
		#if defined(glGetVertexAttribIuiv)
			return glGetVertexAttribIuiv(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribIuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribIuivEXT(GLuint index, enums::VertexAttribEnum pname, GLuint* params) {
		#if defined(glGetVertexAttribIuivEXT)
			return glGetVertexAttribIuivEXT(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribLdv(GLuint index, enums::VertexAttribEnum pname, GLdouble* params) {
		#if defined(glGetVertexAttribLdv)
			return glGetVertexAttribLdv(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribLdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribLdvEXT(GLuint index, enums::VertexAttribEnum pname, GLdouble* params) {
		#if defined(glGetVertexAttribLdvEXT)
			return glGetVertexAttribLdvEXT(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribLdvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribLi64vNV(GLuint index, enums::VertexAttribEnum pname, GLint64EXT* params) {
		#if defined(glGetVertexAttribLi64vNV)
			return glGetVertexAttribLi64vNV(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribLi64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribLui64vARB(GLuint index, enums::VertexAttribEnum pname, GLuint64EXT* params) {
		#if defined(glGetVertexAttribLui64vARB)
			return glGetVertexAttribLui64vARB(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribLui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribLui64vNV(GLuint index, enums::VertexAttribEnum pname, GLuint64EXT* params) {
		#if defined(glGetVertexAttribLui64vNV)
			return glGetVertexAttribLui64vNV(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribLui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribPointerv(GLuint index, enums::VertexAttribPointerPropertyARB pname, void ** pointer) {
		#if defined(glGetVertexAttribPointerv)
			return glGetVertexAttribPointerv(index, static_cast<GLenum>(pname), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribPointerv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribPointervARB(GLuint index, enums::VertexAttribPointerPropertyARB pname, void ** pointer) {
		#if defined(glGetVertexAttribPointervARB)
			return glGetVertexAttribPointervARB(index, static_cast<GLenum>(pname), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribPointervARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribPointervNV(GLuint index, enums::VertexAttribEnumNV pname, void ** pointer) {
		#if defined(glGetVertexAttribPointervNV)
			return glGetVertexAttribPointervNV(index, static_cast<GLenum>(pname), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribPointervNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribdv(GLuint index, enums::VertexAttribPropertyARB pname, GLdouble* params) {
		#if defined(glGetVertexAttribdv)
			return glGetVertexAttribdv(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribdvARB(GLuint index, enums::VertexAttribPropertyARB pname, GLdouble* params) {
		#if defined(glGetVertexAttribdvARB)
			return glGetVertexAttribdvARB(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribdvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribdvNV(GLuint index, enums::VertexAttribEnumNV pname, GLdouble* params) {
		#if defined(glGetVertexAttribdvNV)
			return glGetVertexAttribdvNV(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribdvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribfv(GLuint index, enums::VertexAttribPropertyARB pname, GLfloat* params) {
		#if defined(glGetVertexAttribfv)
			return glGetVertexAttribfv(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribfvARB(GLuint index, enums::VertexAttribPropertyARB pname, GLfloat* params) {
		#if defined(glGetVertexAttribfvARB)
			return glGetVertexAttribfvARB(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribfvNV(GLuint index, enums::VertexAttribEnumNV pname, GLfloat* params) {
		#if defined(glGetVertexAttribfvNV)
			return glGetVertexAttribfvNV(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribiv(GLuint index, enums::VertexAttribPropertyARB pname, GLint* params) {
		#if defined(glGetVertexAttribiv)
			return glGetVertexAttribiv(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribivARB(GLuint index, enums::VertexAttribPropertyARB pname, GLint* params) {
		#if defined(glGetVertexAttribivARB)
			return glGetVertexAttribivARB(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVertexAttribivNV(GLuint index, enums::VertexAttribEnumNV pname, GLint* params) {
		#if defined(glGetVertexAttribivNV)
			return glGetVertexAttribivNV(index, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVertexAttribivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params) {
		#if defined(glGetVideoCaptureStreamdvNV)
			return glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideoCaptureStreamdvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params) {
		#if defined(glGetVideoCaptureStreamfvNV)
			return glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideoCaptureStreamfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params) {
		#if defined(glGetVideoCaptureStreamivNV)
			return glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideoCaptureStreamivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint* params) {
		#if defined(glGetVideoCaptureivNV)
			return glGetVideoCaptureivNV(video_capture_slot, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideoCaptureivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT* params) {
		#if defined(glGetVideoi64vNV)
			return glGetVideoi64vNV(video_slot, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideoi64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideoivNV(GLuint video_slot, GLenum pname, GLint* params) {
		#if defined(glGetVideoivNV)
			return glGetVideoivNV(video_slot, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideoivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT* params) {
		#if defined(glGetVideoui64vNV)
			return glGetVideoui64vNV(video_slot, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideoui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getVideouivNV(GLuint video_slot, GLenum pname, GLuint* params) {
		#if defined(glGetVideouivNV)
			return glGetVideouivNV(video_slot, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVideouivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnColorTable(enums::ColorTableTarget target, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * table) {
		#if defined(glGetnColorTable)
			return glGetnColorTable(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, table);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnColorTable" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnColorTableARB(enums::ColorTableTarget target, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * table) {
		#if defined(glGetnColorTableARB)
			return glGetnColorTableARB(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, table);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnColorTableARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnCompressedTexImage(enums::TextureTarget target, GLint lod, GLsizei bufSize, void * pixels) {
		#if defined(glGetnCompressedTexImage)
			return glGetnCompressedTexImage(static_cast<GLenum>(target), lod, bufSize, pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnCompressedTexImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnCompressedTexImageARB(enums::TextureTarget target, GLint lod, GLsizei bufSize, void * img) {
		#if defined(glGetnCompressedTexImageARB)
			return glGetnCompressedTexImageARB(static_cast<GLenum>(target), lod, bufSize, img);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnCompressedTexImageARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnConvolutionFilter(enums::ConvolutionTarget target, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * image) {
		#if defined(glGetnConvolutionFilter)
			return glGetnConvolutionFilter(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnConvolutionFilter" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnConvolutionFilterARB(enums::ConvolutionTarget target, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * image) {
		#if defined(glGetnConvolutionFilterARB)
			return glGetnConvolutionFilterARB(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, image);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnConvolutionFilterARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnHistogram(enums::HistogramTarget target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * values) {
		#if defined(glGetnHistogram)
			return glGetnHistogram(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnHistogram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnHistogramARB(enums::HistogramTargetEXT target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * values) {
		#if defined(glGetnHistogramARB)
			return glGetnHistogramARB(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnHistogramARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMapdv(enums::MapTarget target, enums::MapQuery query, GLsizei bufSize, GLdouble* v) {
		#if defined(glGetnMapdv)
			return glGetnMapdv(static_cast<GLenum>(target), static_cast<GLenum>(query), bufSize, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMapdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMapdvARB(enums::MapTarget target, enums::MapQuery query, GLsizei bufSize, GLdouble* v) {
		#if defined(glGetnMapdvARB)
			return glGetnMapdvARB(static_cast<GLenum>(target), static_cast<GLenum>(query), bufSize, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMapdvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMapfv(enums::MapTarget target, enums::MapQuery query, GLsizei bufSize, GLfloat* v) {
		#if defined(glGetnMapfv)
			return glGetnMapfv(static_cast<GLenum>(target), static_cast<GLenum>(query), bufSize, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMapfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMapfvARB(enums::MapTarget target, enums::MapQuery query, GLsizei bufSize, GLfloat* v) {
		#if defined(glGetnMapfvARB)
			return glGetnMapfvARB(static_cast<GLenum>(target), static_cast<GLenum>(query), bufSize, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMapfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMapiv(enums::MapTarget target, enums::MapQuery query, GLsizei bufSize, GLint* v) {
		#if defined(glGetnMapiv)
			return glGetnMapiv(static_cast<GLenum>(target), static_cast<GLenum>(query), bufSize, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMapiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMapivARB(enums::MapTarget target, enums::MapQuery query, GLsizei bufSize, GLint* v) {
		#if defined(glGetnMapivARB)
			return glGetnMapivARB(static_cast<GLenum>(target), static_cast<GLenum>(query), bufSize, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMapivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMinmax(enums::MinmaxTarget target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * values) {
		#if defined(glGetnMinmax)
			return glGetnMinmax(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMinmax" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnMinmaxARB(enums::MinmaxTargetEXT target, GLboolean reset, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * values) {
		#if defined(glGetnMinmaxARB)
			return glGetnMinmaxARB(static_cast<GLenum>(target), reset, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnMinmaxARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPixelMapfv(enums::PixelMap map, GLsizei bufSize, GLfloat* values) {
		#if defined(glGetnPixelMapfv)
			return glGetnPixelMapfv(static_cast<GLenum>(map), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPixelMapfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPixelMapfvARB(enums::PixelMap map, GLsizei bufSize, GLfloat* values) {
		#if defined(glGetnPixelMapfvARB)
			return glGetnPixelMapfvARB(static_cast<GLenum>(map), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPixelMapfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPixelMapuiv(enums::PixelMap map, GLsizei bufSize, GLuint* values) {
		#if defined(glGetnPixelMapuiv)
			return glGetnPixelMapuiv(static_cast<GLenum>(map), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPixelMapuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPixelMapuivARB(enums::PixelMap map, GLsizei bufSize, GLuint* values) {
		#if defined(glGetnPixelMapuivARB)
			return glGetnPixelMapuivARB(static_cast<GLenum>(map), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPixelMapuivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPixelMapusv(enums::PixelMap map, GLsizei bufSize, GLushort* values) {
		#if defined(glGetnPixelMapusv)
			return glGetnPixelMapusv(static_cast<GLenum>(map), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPixelMapusv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPixelMapusvARB(enums::PixelMap map, GLsizei bufSize, GLushort* values) {
		#if defined(glGetnPixelMapusvARB)
			return glGetnPixelMapusvARB(static_cast<GLenum>(map), bufSize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPixelMapusvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPolygonStipple(GLsizei bufSize, GLubyte* pattern) {
		#if defined(glGetnPolygonStipple)
			return glGetnPolygonStipple(bufSize, pattern);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPolygonStipple" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnPolygonStippleARB(GLsizei bufSize, GLubyte* pattern) {
		#if defined(glGetnPolygonStippleARB)
			return glGetnPolygonStippleARB(bufSize, pattern);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnPolygonStippleARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnSeparableFilter(enums::SeparableTarget target, enums::PixelFormat format, enums::PixelType type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span) {
		#if defined(glGetnSeparableFilter)
			return glGetnSeparableFilter(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), rowBufSize, row, columnBufSize, column, span);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnSeparableFilter" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnSeparableFilterARB(enums::SeparableTargetEXT target, enums::PixelFormat format, enums::PixelType type, GLsizei rowBufSize, void * row, GLsizei columnBufSize, void * column, void * span) {
		#if defined(glGetnSeparableFilterARB)
			return glGetnSeparableFilterARB(static_cast<GLenum>(target), static_cast<GLenum>(format), static_cast<GLenum>(type), rowBufSize, row, columnBufSize, column, span);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnSeparableFilterARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnTexImage(enums::TextureTarget target, GLint level, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * pixels) {
		#if defined(glGetnTexImage)
			return glGetnTexImage(static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnTexImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnTexImageARB(enums::TextureTarget target, GLint level, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * img) {
		#if defined(glGetnTexImageARB)
			return glGetnTexImageARB(static_cast<GLenum>(target), level, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, img);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnTexImageARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) {
		#if defined(glGetnUniformdv)
			return glGetnUniformdv(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble* params) {
		#if defined(glGetnUniformdvARB)
			return glGetnUniformdvARB(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformdvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) {
		#if defined(glGetnUniformfv)
			return glGetnUniformfv(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) {
		#if defined(glGetnUniformfvARB)
			return glGetnUniformfvARB(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) {
		#if defined(glGetnUniformfvEXT)
			return glGetnUniformfvEXT(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformfvKHR(GLuint program, GLint location, GLsizei bufSize, GLfloat* params) {
		#if defined(glGetnUniformfvKHR)
			return glGetnUniformfvKHR(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformfvKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformi64vARB(GLuint program, GLint location, GLsizei bufSize, GLint64* params) {
		#if defined(glGetnUniformi64vARB)
			return glGetnUniformi64vARB(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformi64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint* params) {
		#if defined(glGetnUniformiv)
			return glGetnUniformiv(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint* params) {
		#if defined(glGetnUniformivARB)
			return glGetnUniformivARB(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint* params) {
		#if defined(glGetnUniformivEXT)
			return glGetnUniformivEXT(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformivKHR(GLuint program, GLint location, GLsizei bufSize, GLint* params) {
		#if defined(glGetnUniformivKHR)
			return glGetnUniformivKHR(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformivKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformui64vARB(GLuint program, GLint location, GLsizei bufSize, GLuint64* params) {
		#if defined(glGetnUniformui64vARB)
			return glGetnUniformui64vARB(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint* params) {
		#if defined(glGetnUniformuiv)
			return glGetnUniformuiv(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint* params) {
		#if defined(glGetnUniformuivARB)
			return glGetnUniformuivARB(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformuivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getnUniformuivKHR(GLuint program, GLint location, GLsizei bufSize, GLuint* params) {
		#if defined(glGetnUniformuivKHR)
			return glGetnUniformuivKHR(program, location, bufSize, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetnUniformuivKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactorbSUN(GLbyte factor) {
		#if defined(glGlobalAlphaFactorbSUN)
			return glGlobalAlphaFactorbSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactorbSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactordSUN(GLdouble factor) {
		#if defined(glGlobalAlphaFactordSUN)
			return glGlobalAlphaFactordSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactordSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactorfSUN(GLfloat factor) {
		#if defined(glGlobalAlphaFactorfSUN)
			return glGlobalAlphaFactorfSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactorfSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactoriSUN(GLint factor) {
		#if defined(glGlobalAlphaFactoriSUN)
			return glGlobalAlphaFactoriSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactoriSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactorsSUN(GLshort factor) {
		#if defined(glGlobalAlphaFactorsSUN)
			return glGlobalAlphaFactorsSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactorsSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactorubSUN(GLubyte factor) {
		#if defined(glGlobalAlphaFactorubSUN)
			return glGlobalAlphaFactorubSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactorubSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactoruiSUN(GLuint factor) {
		#if defined(glGlobalAlphaFactoruiSUN)
			return glGlobalAlphaFactoruiSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactoruiSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void globalAlphaFactorusSUN(GLushort factor) {
		#if defined(glGlobalAlphaFactorusSUN)
			return glGlobalAlphaFactorusSUN(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGlobalAlphaFactorusSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void hint(enums::HintTarget target, enums::HintMode mode) {
		#if defined(glHint)
			return glHint(static_cast<GLenum>(target), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glHint" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void hintPGI(enums::HintTargetPGI target, GLint mode) {
		#if defined(glHintPGI)
			return glHintPGI(static_cast<GLenum>(target), mode);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glHintPGI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void histogram(enums::HistogramTargetEXT target, GLsizei width, enums::InternalFormat internalformat, GLboolean sink) {
		#if defined(glHistogram)
			return glHistogram(static_cast<GLenum>(target), width, static_cast<GLenum>(internalformat), sink);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glHistogram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void histogramEXT(enums::HistogramTargetEXT target, GLsizei width, enums::InternalFormat internalformat, GLboolean sink) {
		#if defined(glHistogramEXT)
			return glHistogramEXT(static_cast<GLenum>(target), width, static_cast<GLenum>(internalformat), sink);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glHistogramEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void iglooInterfaceSGIX(GLenum pname, const void * params) {
		#if defined(glIglooInterfaceSGIX)
			return glIglooInterfaceSGIX(pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIglooInterfaceSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void imageTransformParameterfHP(enums::ImageTransformTargetHP target, enums::ImageTransformPNameHP pname, GLfloat param) {
		#if defined(glImageTransformParameterfHP)
			return glImageTransformParameterfHP(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImageTransformParameterfHP" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void imageTransformParameterfvHP(enums::ImageTransformTargetHP target, enums::ImageTransformPNameHP pname, const GLfloat* params) {
		#if defined(glImageTransformParameterfvHP)
			return glImageTransformParameterfvHP(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImageTransformParameterfvHP" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void imageTransformParameteriHP(enums::ImageTransformTargetHP target, enums::ImageTransformPNameHP pname, GLint param) {
		#if defined(glImageTransformParameteriHP)
			return glImageTransformParameteriHP(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImageTransformParameteriHP" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void imageTransformParameterivHP(enums::ImageTransformTargetHP target, enums::ImageTransformPNameHP pname, const GLint* params) {
		#if defined(glImageTransformParameterivHP)
			return glImageTransformParameterivHP(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImageTransformParameterivHP" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void importMemoryFdEXT(GLuint memory, GLuint64 size, enums::ExternalHandleType handleType, GLint fd) {
		#if defined(glImportMemoryFdEXT)
			return glImportMemoryFdEXT(memory, size, static_cast<GLenum>(handleType), fd);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImportMemoryFdEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void importMemoryWin32HandleEXT(GLuint memory, GLuint64 size, enums::ExternalHandleType handleType, void * handle) {
		#if defined(glImportMemoryWin32HandleEXT)
			return glImportMemoryWin32HandleEXT(memory, size, static_cast<GLenum>(handleType), handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImportMemoryWin32HandleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void importMemoryWin32NameEXT(GLuint memory, GLuint64 size, enums::ExternalHandleType handleType, const void * name) {
		#if defined(glImportMemoryWin32NameEXT)
			return glImportMemoryWin32NameEXT(memory, size, static_cast<GLenum>(handleType), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImportMemoryWin32NameEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void importSemaphoreFdEXT(GLuint semaphore, enums::ExternalHandleType handleType, GLint fd) {
		#if defined(glImportSemaphoreFdEXT)
			return glImportSemaphoreFdEXT(semaphore, static_cast<GLenum>(handleType), fd);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImportSemaphoreFdEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void importSemaphoreWin32HandleEXT(GLuint semaphore, enums::ExternalHandleType handleType, void * handle) {
		#if defined(glImportSemaphoreWin32HandleEXT)
			return glImportSemaphoreWin32HandleEXT(semaphore, static_cast<GLenum>(handleType), handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImportSemaphoreWin32HandleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void importSemaphoreWin32NameEXT(GLuint semaphore, enums::ExternalHandleType handleType, const void * name) {
		#if defined(glImportSemaphoreWin32NameEXT)
			return glImportSemaphoreWin32NameEXT(semaphore, static_cast<GLenum>(handleType), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImportSemaphoreWin32NameEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLsync importSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags) {
		#if defined(glImportSyncEXT)
			return glImportSyncEXT(external_sync_type, external_sync, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glImportSyncEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void indexFormatNV(GLenum type, GLsizei stride) {
		#if defined(glIndexFormatNV)
			return glIndexFormatNV(type, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexFuncEXT(enums::IndexFunctionEXT func, GLclampf ref) {
		#if defined(glIndexFuncEXT)
			return glIndexFuncEXT(static_cast<GLenum>(func), ref);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexFuncEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexMask(GLuint mask) {
		#if defined(glIndexMask)
			return glIndexMask(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexMask" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexMaterialEXT(enums::TriangleFace face, enums::IndexMaterialParameterEXT mode) {
		#if defined(glIndexMaterialEXT)
			return glIndexMaterialEXT(static_cast<GLenum>(face), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexMaterialEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexPointer(enums::IndexPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glIndexPointer)
			return glIndexPointer(static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexPointerEXT(enums::IndexPointerType type, GLsizei stride, GLsizei count, const void * pointer) {
		#if defined(glIndexPointerEXT)
			return glIndexPointerEXT(static_cast<GLenum>(type), stride, count, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexPointerListIBM(enums::IndexPointerType type, GLint stride, const void ** pointer, GLint ptrstride) {
		#if defined(glIndexPointerListIBM)
			return glIndexPointerListIBM(static_cast<GLenum>(type), stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexd(GLdouble c) {
		#if defined(glIndexd)
			return glIndexd(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexdv(const GLdouble* c) {
		#if defined(glIndexdv)
			return glIndexdv(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexf(GLfloat c) {
		#if defined(glIndexf)
			return glIndexf(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexfv(const GLfloat* c) {
		#if defined(glIndexfv)
			return glIndexfv(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexi(GLint c) {
		#if defined(glIndexi)
			return glIndexi(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexiv(const GLint* c) {
		#if defined(glIndexiv)
			return glIndexiv(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexs(GLshort c) {
		#if defined(glIndexs)
			return glIndexs(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexs" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexsv(const GLshort* c) {
		#if defined(glIndexsv)
			return glIndexsv(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexsv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexub(GLubyte c) {
		#if defined(glIndexub)
			return glIndexub(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexub" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexubv(const GLubyte* c) {
		#if defined(glIndexubv)
			return glIndexubv(c);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexubv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexxOES(GLfixed component) {
		#if defined(glIndexxOES)
			return glIndexxOES(component);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void indexxvOES(const GLfixed* component) {
		#if defined(glIndexxvOES)
			return glIndexxvOES(component);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIndexxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void initNames() {
		#if defined(glInitNames)
			return glInitNames();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInitNames" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void insertComponentEXT(GLuint res, GLuint src, GLuint num) {
		#if defined(glInsertComponentEXT)
			return glInsertComponentEXT(res, src, num);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInsertComponentEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void insertEventMarkerEXT(GLsizei length, const GLchar* marker) {
		#if defined(glInsertEventMarkerEXT)
			return glInsertEventMarkerEXT(length, marker);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInsertEventMarkerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void instrumentsBufferSGIX(GLsizei size, GLint* buffer) {
		#if defined(glInstrumentsBufferSGIX)
			return glInstrumentsBufferSGIX(size, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInstrumentsBufferSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void interleavedArrays(enums::InterleavedArrayFormat format, GLsizei stride, const void * pointer) {
		#if defined(glInterleavedArrays)
			return glInterleavedArrays(static_cast<GLenum>(format), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInterleavedArrays" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void interpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight) {
		#if defined(glInterpolatePathsNV)
			return glInterpolatePathsNV(resultPath, pathA, pathB, weight);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInterpolatePathsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateBufferData(GLuint buffer) {
		#if defined(glInvalidateBufferData)
			return glInvalidateBufferData(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateBufferData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) {
		#if defined(glInvalidateBufferSubData)
			return glInvalidateBufferSubData(buffer, offset, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateFramebuffer(enums::FramebufferTarget target, GLsizei numAttachments, const GLenum* attachments) {
		#if defined(glInvalidateFramebuffer)
			return glInvalidateFramebuffer(static_cast<GLenum>(target), numAttachments, attachments);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateFramebuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments) {
		#if defined(glInvalidateNamedFramebufferData)
			return glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateNamedFramebufferData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glInvalidateNamedFramebufferSubData)
			return glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateNamedFramebufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateSubFramebuffer(enums::FramebufferTarget target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glInvalidateSubFramebuffer)
			return glInvalidateSubFramebuffer(static_cast<GLenum>(target), numAttachments, attachments, x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateSubFramebuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateTexImage(GLuint texture, GLint level) {
		#if defined(glInvalidateTexImage)
			return glInvalidateTexImage(texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateTexImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void invalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) {
		#if defined(glInvalidateTexSubImage)
			return glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glInvalidateTexSubImage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean isAsyncMarkerSGIX(GLuint marker) {
		#if defined(glIsAsyncMarkerSGIX)
			return glIsAsyncMarkerSGIX(marker);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsAsyncMarkerSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isBuffer(GLuint buffer) {
		#if defined(glIsBuffer)
			return glIsBuffer(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isBufferARB(GLuint buffer) {
		#if defined(glIsBufferARB)
			return glIsBufferARB(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsBufferARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isBufferResidentNV(GLenum target) {
		#if defined(glIsBufferResidentNV)
			return glIsBufferResidentNV(target);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsBufferResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isCommandListNV(GLuint list) {
		#if defined(glIsCommandListNV)
			return glIsCommandListNV(list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsCommandListNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isEnabled(enums::EnableCap cap) {
		#if defined(glIsEnabled)
			return glIsEnabled(static_cast<GLenum>(cap));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsEnabled" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isEnabledIndexedEXT(enums::EnableCap target, GLuint index) {
		#if defined(glIsEnabledIndexedEXT)
			return glIsEnabledIndexedEXT(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsEnabledIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isEnabledi(enums::EnableCap target, GLuint index) {
		#if defined(glIsEnabledi)
			return glIsEnabledi(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsEnabledi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isEnablediEXT(enums::EnableCap target, GLuint index) {
		#if defined(glIsEnablediEXT)
			return glIsEnablediEXT(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsEnablediEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isEnablediNV(enums::EnableCap target, GLuint index) {
		#if defined(glIsEnablediNV)
			return glIsEnablediNV(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsEnablediNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isEnablediOES(enums::EnableCap target, GLuint index) {
		#if defined(glIsEnablediOES)
			return glIsEnablediOES(static_cast<GLenum>(target), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsEnablediOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isFenceAPPLE(GLuint fence) {
		#if defined(glIsFenceAPPLE)
			return glIsFenceAPPLE(fence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsFenceAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isFenceNV(GLuint fence) {
		#if defined(glIsFenceNV)
			return glIsFenceNV(fence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsFenceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isFramebuffer(GLuint framebuffer) {
		#if defined(glIsFramebuffer)
			return glIsFramebuffer(framebuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsFramebuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isFramebufferEXT(GLuint framebuffer) {
		#if defined(glIsFramebufferEXT)
			return glIsFramebufferEXT(framebuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsFramebufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isFramebufferOES(GLuint framebuffer) {
		#if defined(glIsFramebufferOES)
			return glIsFramebufferOES(framebuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsFramebufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isImageHandleResidentARB(GLuint64 handle) {
		#if defined(glIsImageHandleResidentARB)
			return glIsImageHandleResidentARB(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsImageHandleResidentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isImageHandleResidentNV(GLuint64 handle) {
		#if defined(glIsImageHandleResidentNV)
			return glIsImageHandleResidentNV(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsImageHandleResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isList(GLuint list) {
		#if defined(glIsList)
			return glIsList(list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsList" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isMemoryObjectEXT(GLuint memoryObject) {
		#if defined(glIsMemoryObjectEXT)
			return glIsMemoryObjectEXT(memoryObject);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsMemoryObjectEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isNameAMD(GLenum identifier, GLuint name) {
		#if defined(glIsNameAMD)
			return glIsNameAMD(identifier, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsNameAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isNamedBufferResidentNV(GLuint buffer) {
		#if defined(glIsNamedBufferResidentNV)
			return glIsNamedBufferResidentNV(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsNamedBufferResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isNamedStringARB(GLint namelen, const GLchar* name) {
		#if defined(glIsNamedStringARB)
			return glIsNamedStringARB(namelen, name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsNamedStringARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isObjectBufferATI(GLuint buffer) {
		#if defined(glIsObjectBufferATI)
			return glIsObjectBufferATI(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsObjectBufferATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isOcclusionQueryNV(GLuint id) {
		#if defined(glIsOcclusionQueryNV)
			return glIsOcclusionQueryNV(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsOcclusionQueryNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isPathNV(GLuint path) {
		#if defined(glIsPathNV)
			return glIsPathNV(path);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y) {
		#if defined(glIsPointInFillPathNV)
			return glIsPointInFillPathNV(path, mask, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsPointInFillPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y) {
		#if defined(glIsPointInStrokePathNV)
			return glIsPointInStrokePathNV(path, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsPointInStrokePathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isProgram(GLuint program) {
		#if defined(glIsProgram)
			return glIsProgram(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsProgram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isProgramARB(GLuint program) {
		#if defined(glIsProgramARB)
			return glIsProgramARB(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsProgramARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isProgramNV(GLuint id) {
		#if defined(glIsProgramNV)
			return glIsProgramNV(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsProgramNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isProgramPipeline(GLuint pipeline) {
		#if defined(glIsProgramPipeline)
			return glIsProgramPipeline(pipeline);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsProgramPipeline" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isProgramPipelineEXT(GLuint pipeline) {
		#if defined(glIsProgramPipelineEXT)
			return glIsProgramPipelineEXT(pipeline);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsProgramPipelineEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isQuery(GLuint id) {
		#if defined(glIsQuery)
			return glIsQuery(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsQuery" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isQueryARB(GLuint id) {
		#if defined(glIsQueryARB)
			return glIsQueryARB(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsQueryARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isQueryEXT(GLuint id) {
		#if defined(glIsQueryEXT)
			return glIsQueryEXT(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsQueryEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isRenderbuffer(GLuint renderbuffer) {
		#if defined(glIsRenderbuffer)
			return glIsRenderbuffer(renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsRenderbuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isRenderbufferEXT(GLuint renderbuffer) {
		#if defined(glIsRenderbufferEXT)
			return glIsRenderbufferEXT(renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsRenderbufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isRenderbufferOES(GLuint renderbuffer) {
		#if defined(glIsRenderbufferOES)
			return glIsRenderbufferOES(renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsRenderbufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isSemaphoreEXT(GLuint semaphore) {
		#if defined(glIsSemaphoreEXT)
			return glIsSemaphoreEXT(semaphore);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsSemaphoreEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isSampler(GLuint sampler) {
		#if defined(glIsSampler)
			return glIsSampler(sampler);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsSampler" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isShader(GLuint shader) {
		#if defined(glIsShader)
			return glIsShader(shader);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsShader" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isStateNV(GLuint state) {
		#if defined(glIsStateNV)
			return glIsStateNV(state);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsStateNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isSync(GLsync sync) {
		#if defined(glIsSync)
			return glIsSync(sync);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsSync" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isSyncAPPLE(GLsync sync) {
		#if defined(glIsSyncAPPLE)
			return glIsSyncAPPLE(sync);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsSyncAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isTexture(GLuint texture) {
		#if defined(glIsTexture)
			return glIsTexture(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsTexture" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isTextureEXT(GLuint texture) {
		#if defined(glIsTextureEXT)
			return glIsTextureEXT(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsTextureEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isTextureHandleResidentARB(GLuint64 handle) {
		#if defined(glIsTextureHandleResidentARB)
			return glIsTextureHandleResidentARB(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsTextureHandleResidentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isTextureHandleResidentNV(GLuint64 handle) {
		#if defined(glIsTextureHandleResidentNV)
			return glIsTextureHandleResidentNV(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsTextureHandleResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isTransformFeedback(GLuint id) {
		#if defined(glIsTransformFeedback)
			return glIsTransformFeedback(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsTransformFeedback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isTransformFeedbackNV(GLuint id) {
		#if defined(glIsTransformFeedbackNV)
			return glIsTransformFeedbackNV(id);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsTransformFeedbackNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isVariantEnabledEXT(GLuint id, enums::VariantCapEXT cap) {
		#if defined(glIsVariantEnabledEXT)
			return glIsVariantEnabledEXT(id, static_cast<GLenum>(cap));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsVariantEnabledEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isVertexArray(GLuint array) {
		#if defined(glIsVertexArray)
			return glIsVertexArray(array);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsVertexArray" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isVertexArrayAPPLE(GLuint array) {
		#if defined(glIsVertexArrayAPPLE)
			return glIsVertexArrayAPPLE(array);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsVertexArrayAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isVertexArrayOES(GLuint array) {
		#if defined(glIsVertexArrayOES)
			return glIsVertexArrayOES(array);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsVertexArrayOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean isVertexAttribEnabledAPPLE(GLuint index, GLenum pname) {
		#if defined(glIsVertexAttribEnabledAPPLE)
			return glIsVertexAttribEnabledAPPLE(index, pname);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glIsVertexAttribEnabledAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void lGPUCopyImageSubDataNVX(GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth) {
		#if defined(glLGPUCopyImageSubDataNVX)
			return glLGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLGPUCopyImageSubDataNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lGPUInterlockNVX() {
		#if defined(glLGPUInterlockNVX)
			return glLGPUInterlockNVX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLGPUInterlockNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lGPUNamedBufferSubDataNVX(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data) {
		#if defined(glLGPUNamedBufferSubDataNVX)
			return glLGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLGPUNamedBufferSubDataNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void labelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar* label) {
		#if defined(glLabelObjectEXT)
			return glLabelObjectEXT(type, object, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLabelObjectEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightEnviSGIX(enums::LightEnvParameterSGIX pname, GLint param) {
		#if defined(glLightEnviSGIX)
			return glLightEnviSGIX(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightEnviSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModelf(enums::LightModelParameter pname, GLfloat param) {
		#if defined(glLightModelf)
			return glLightModelf(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModelf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModelfv(enums::LightModelParameter pname, const GLfloat* params) {
		#if defined(glLightModelfv)
			return glLightModelfv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModelfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModeli(enums::LightModelParameter pname, GLint param) {
		#if defined(glLightModeli)
			return glLightModeli(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModeli" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModeliv(enums::LightModelParameter pname, const GLint* params) {
		#if defined(glLightModeliv)
			return glLightModeliv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModeliv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModelx(enums::LightModelParameter pname, GLfixed param) {
		#if defined(glLightModelx)
			return glLightModelx(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModelx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModelxOES(enums::LightModelParameter pname, GLfixed param) {
		#if defined(glLightModelxOES)
			return glLightModelxOES(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModelxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModelxv(enums::LightModelParameter pname, const GLfixed* param) {
		#if defined(glLightModelxv)
			return glLightModelxv(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModelxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightModelxvOES(enums::LightModelParameter pname, const GLfixed* param) {
		#if defined(glLightModelxvOES)
			return glLightModelxvOES(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightModelxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightf(enums::LightName light, enums::LightParameter pname, GLfloat param) {
		#if defined(glLightf)
			return glLightf(static_cast<GLenum>(light), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightfv(enums::LightName light, enums::LightParameter pname, const GLfloat* params) {
		#if defined(glLightfv)
			return glLightfv(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lighti(enums::LightName light, enums::LightParameter pname, GLint param) {
		#if defined(glLighti)
			return glLighti(static_cast<GLenum>(light), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLighti" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightiv(enums::LightName light, enums::LightParameter pname, const GLint* params) {
		#if defined(glLightiv)
			return glLightiv(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightx(enums::LightName light, enums::LightParameter pname, GLfixed param) {
		#if defined(glLightx)
			return glLightx(static_cast<GLenum>(light), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightxOES(enums::LightName light, enums::LightParameter pname, GLfixed param) {
		#if defined(glLightxOES)
			return glLightxOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightxv(enums::LightName light, enums::LightParameter pname, const GLfixed* params) {
		#if defined(glLightxv)
			return glLightxv(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lightxvOES(enums::LightName light, enums::LightParameter pname, const GLfixed* params) {
		#if defined(glLightxvOES)
			return glLightxvOES(static_cast<GLenum>(light), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLightxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lineStipple(GLint factor, GLushort pattern) {
		#if defined(glLineStipple)
			return glLineStipple(factor, pattern);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLineStipple" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lineWidth(GLfloat width) {
		#if defined(glLineWidth)
			return glLineWidth(width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLineWidth" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lineWidthx(GLfixed width) {
		#if defined(glLineWidthx)
			return glLineWidthx(width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLineWidthx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lineWidthxOES(GLfixed width) {
		#if defined(glLineWidthxOES)
			return glLineWidthxOES(width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLineWidthxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void linkProgram(GLuint program) {
		#if defined(glLinkProgram)
			return glLinkProgram(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLinkProgram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void linkProgramARB(GLhandleARB programObj) {
		#if defined(glLinkProgramARB)
			return glLinkProgramARB(programObj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLinkProgramARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void listBase(GLuint base) {
		#if defined(glListBase)
			return glListBase(base);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glListBase" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void listDrawCommandsStatesClientNV(GLuint list, GLuint segment, const void ** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count) {
		#if defined(glListDrawCommandsStatesClientNV)
			return glListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glListDrawCommandsStatesClientNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void listParameterfSGIX(GLuint list, enums::ListParameterName pname, GLfloat param) {
		#if defined(glListParameterfSGIX)
			return glListParameterfSGIX(list, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glListParameterfSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void listParameterfvSGIX(GLuint list, enums::ListParameterName pname, const GLfloat* params) {
		#if defined(glListParameterfvSGIX)
			return glListParameterfvSGIX(list, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glListParameterfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void listParameteriSGIX(GLuint list, enums::ListParameterName pname, GLint param) {
		#if defined(glListParameteriSGIX)
			return glListParameteriSGIX(list, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glListParameteriSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void listParameterivSGIX(GLuint list, enums::ListParameterName pname, const GLint* params) {
		#if defined(glListParameterivSGIX)
			return glListParameterivSGIX(list, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glListParameterivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadIdentity() {
		#if defined(glLoadIdentity)
			return glLoadIdentity();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadIdentity" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadIdentityDeformationMapSGIX(GLbitfield mask) {
		#if defined(glLoadIdentityDeformationMapSGIX)
			return glLoadIdentityDeformationMapSGIX(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadIdentityDeformationMapSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadMatrixd(const GLdouble* m) {
		#if defined(glLoadMatrixd)
			return glLoadMatrixd(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadMatrixd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadMatrixf(const GLfloat* m) {
		#if defined(glLoadMatrixf)
			return glLoadMatrixf(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadMatrixf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadMatrixx(const GLfixed* m) {
		#if defined(glLoadMatrixx)
			return glLoadMatrixx(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadMatrixx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadMatrixxOES(const GLfixed* m) {
		#if defined(glLoadMatrixxOES)
			return glLoadMatrixxOES(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadMatrixxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadName(GLuint name) {
		#if defined(glLoadName)
			return glLoadName(name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadPaletteFromModelViewMatrixOES() {
		#if defined(glLoadPaletteFromModelViewMatrixOES)
			return glLoadPaletteFromModelViewMatrixOES();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadPaletteFromModelViewMatrixOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadProgramNV(enums::VertexAttribEnumNV target, GLuint id, GLsizei len, const GLubyte* program) {
		#if defined(glLoadProgramNV)
			return glLoadProgramNV(static_cast<GLenum>(target), id, len, program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadProgramNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadTransposeMatrixd(const GLdouble* m) {
		#if defined(glLoadTransposeMatrixd)
			return glLoadTransposeMatrixd(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadTransposeMatrixd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadTransposeMatrixdARB(const GLdouble* m) {
		#if defined(glLoadTransposeMatrixdARB)
			return glLoadTransposeMatrixdARB(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadTransposeMatrixdARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadTransposeMatrixf(const GLfloat* m) {
		#if defined(glLoadTransposeMatrixf)
			return glLoadTransposeMatrixf(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadTransposeMatrixf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadTransposeMatrixfARB(const GLfloat* m) {
		#if defined(glLoadTransposeMatrixfARB)
			return glLoadTransposeMatrixfARB(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadTransposeMatrixfARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void loadTransposeMatrixxOES(const GLfixed* m) {
		#if defined(glLoadTransposeMatrixxOES)
			return glLoadTransposeMatrixxOES(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLoadTransposeMatrixxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void lockArraysEXT(GLint first, GLsizei count) {
		#if defined(glLockArraysEXT)
			return glLockArraysEXT(first, count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLockArraysEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void logicOp(enums::LogicOp opcode) {
		#if defined(glLogicOp)
			return glLogicOp(static_cast<GLenum>(opcode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glLogicOp" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeBufferNonResidentNV(GLenum target) {
		#if defined(glMakeBufferNonResidentNV)
			return glMakeBufferNonResidentNV(target);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeBufferNonResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeBufferResidentNV(GLenum target, GLenum access) {
		#if defined(glMakeBufferResidentNV)
			return glMakeBufferResidentNV(target, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeBufferResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeImageHandleNonResidentARB(GLuint64 handle) {
		#if defined(glMakeImageHandleNonResidentARB)
			return glMakeImageHandleNonResidentARB(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeImageHandleNonResidentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeImageHandleNonResidentNV(GLuint64 handle) {
		#if defined(glMakeImageHandleNonResidentNV)
			return glMakeImageHandleNonResidentNV(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeImageHandleNonResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeImageHandleResidentARB(GLuint64 handle, GLenum access) {
		#if defined(glMakeImageHandleResidentARB)
			return glMakeImageHandleResidentARB(handle, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeImageHandleResidentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeImageHandleResidentNV(GLuint64 handle, GLenum access) {
		#if defined(glMakeImageHandleResidentNV)
			return glMakeImageHandleResidentNV(handle, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeImageHandleResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeNamedBufferNonResidentNV(GLuint buffer) {
		#if defined(glMakeNamedBufferNonResidentNV)
			return glMakeNamedBufferNonResidentNV(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeNamedBufferNonResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeNamedBufferResidentNV(GLuint buffer, GLenum access) {
		#if defined(glMakeNamedBufferResidentNV)
			return glMakeNamedBufferResidentNV(buffer, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeNamedBufferResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeTextureHandleNonResidentARB(GLuint64 handle) {
		#if defined(glMakeTextureHandleNonResidentARB)
			return glMakeTextureHandleNonResidentARB(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeTextureHandleNonResidentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeTextureHandleNonResidentNV(GLuint64 handle) {
		#if defined(glMakeTextureHandleNonResidentNV)
			return glMakeTextureHandleNonResidentNV(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeTextureHandleNonResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeTextureHandleResidentARB(GLuint64 handle) {
		#if defined(glMakeTextureHandleResidentARB)
			return glMakeTextureHandleResidentARB(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeTextureHandleResidentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void makeTextureHandleResidentNV(GLuint64 handle) {
		#if defined(glMakeTextureHandleResidentNV)
			return glMakeTextureHandleResidentNV(handle);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMakeTextureHandleResidentNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void map1d(enums::MapTarget target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points) {
		#if defined(glMap1d)
			return glMap1d(static_cast<GLenum>(target), u1, u2, stride, order, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMap1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void map1f(enums::MapTarget target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points) {
		#if defined(glMap1f)
			return glMap1f(static_cast<GLenum>(target), u1, u2, stride, order, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMap1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void map1xOES(enums::MapTarget target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points) {
		#if defined(glMap1xOES)
			return glMap1xOES(static_cast<GLenum>(target), u1, u2, stride, order, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMap1xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void map2d(enums::MapTarget target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points) {
		#if defined(glMap2d)
			return glMap2d(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMap2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void map2f(enums::MapTarget target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points) {
		#if defined(glMap2f)
			return glMap2f(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMap2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void map2xOES(enums::MapTarget target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points) {
		#if defined(glMap2xOES)
			return glMap2xOES(static_cast<GLenum>(target), u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMap2xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void * mapBuffer(enums::BufferTargetARB target, enums::BufferAccessARB access) {
		#if defined(glMapBuffer)
			return glMapBuffer(static_cast<GLenum>(target), static_cast<GLenum>(access));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapBufferARB(enums::BufferTargetARB target, enums::BufferAccessARB access) {
		#if defined(glMapBufferARB)
			return glMapBufferARB(static_cast<GLenum>(target), static_cast<GLenum>(access));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapBufferARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapBufferOES(enums::BufferTargetARB target, enums::BufferAccessARB access) {
		#if defined(glMapBufferOES)
			return glMapBufferOES(static_cast<GLenum>(target), static_cast<GLenum>(access));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapBufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapBufferRange(enums::BufferTargetARB target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
		#if defined(glMapBufferRange)
			return glMapBufferRange(static_cast<GLenum>(target), offset, length, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapBufferRangeEXT(enums::BufferTargetARB target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
		#if defined(glMapBufferRangeEXT)
			return glMapBufferRangeEXT(static_cast<GLenum>(target), offset, length, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapBufferRangeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void mapControlPointsNV(enums::EvalTargetNV target, GLuint index, enums::MapTypeNV type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void * points) {
		#if defined(glMapControlPointsNV)
			return glMapControlPointsNV(static_cast<GLenum>(target), index, static_cast<GLenum>(type), ustride, vstride, uorder, vorder, packed, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapControlPointsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapGrid1d(GLint un, GLdouble u1, GLdouble u2) {
		#if defined(glMapGrid1d)
			return glMapGrid1d(un, u1, u2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapGrid1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapGrid1f(GLint un, GLfloat u1, GLfloat u2) {
		#if defined(glMapGrid1f)
			return glMapGrid1f(un, u1, u2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapGrid1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapGrid1xOES(GLint n, GLfixed u1, GLfixed u2) {
		#if defined(glMapGrid1xOES)
			return glMapGrid1xOES(n, u1, u2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapGrid1xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) {
		#if defined(glMapGrid2d)
			return glMapGrid2d(un, u1, u2, vn, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapGrid2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) {
		#if defined(glMapGrid2f)
			return glMapGrid2f(un, u1, u2, vn, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapGrid2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapGrid2xOES(GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2) {
		#if defined(glMapGrid2xOES)
			return glMapGrid2xOES(n, u1, u2, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapGrid2xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void * mapNamedBuffer(GLuint buffer, enums::BufferAccessARB access) {
		#if defined(glMapNamedBuffer)
			return glMapNamedBuffer(buffer, static_cast<GLenum>(access));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapNamedBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapNamedBufferEXT(GLuint buffer, enums::BufferAccessARB access) {
		#if defined(glMapNamedBufferEXT)
			return glMapNamedBufferEXT(buffer, static_cast<GLenum>(access));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapNamedBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
		#if defined(glMapNamedBufferRange)
			return glMapNamedBufferRange(buffer, offset, length, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapNamedBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
		#if defined(glMapNamedBufferRangeEXT)
			return glMapNamedBufferRangeEXT(buffer, offset, length, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapNamedBufferRangeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void * mapObjectBufferATI(GLuint buffer) {
		#if defined(glMapObjectBufferATI)
			return glMapObjectBufferATI(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapObjectBufferATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void mapParameterfvNV(enums::EvalTargetNV target, enums::MapParameterNV pname, const GLfloat* params) {
		#if defined(glMapParameterfvNV)
			return glMapParameterfvNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapParameterivNV(enums::EvalTargetNV target, enums::MapParameterNV pname, const GLint* params) {
		#if defined(glMapParameterivNV)
			return glMapParameterivNV(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void * mapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum* layout) {
		#if defined(glMapTexture2DINTEL)
			return glMapTexture2DINTEL(texture, level, access, stride, layout);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapTexture2DINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void mapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points) {
		#if defined(glMapVertexAttrib1dAPPLE)
			return glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapVertexAttrib1dAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points) {
		#if defined(glMapVertexAttrib1fAPPLE)
			return glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapVertexAttrib1fAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points) {
		#if defined(glMapVertexAttrib2dAPPLE)
			return glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapVertexAttrib2dAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void mapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points) {
		#if defined(glMapVertexAttrib2fAPPLE)
			return glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMapVertexAttrib2fAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materialf(enums::TriangleFace face, enums::MaterialParameter pname, GLfloat param) {
		#if defined(glMaterialf)
			return glMaterialf(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaterialf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materialfv(enums::TriangleFace face, enums::MaterialParameter pname, const GLfloat* params) {
		#if defined(glMaterialfv)
			return glMaterialfv(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaterialfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materiali(enums::TriangleFace face, enums::MaterialParameter pname, GLint param) {
		#if defined(glMateriali)
			return glMateriali(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMateriali" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materialiv(enums::TriangleFace face, enums::MaterialParameter pname, const GLint* params) {
		#if defined(glMaterialiv)
			return glMaterialiv(static_cast<GLenum>(face), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaterialiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materialx(enums::TriangleFace face, enums::MaterialParameter pname, GLfixed param) {
		#if defined(glMaterialx)
			return glMaterialx(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaterialx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materialxOES(enums::TriangleFace face, enums::MaterialParameter pname, GLfixed param) {
		#if defined(glMaterialxOES)
			return glMaterialxOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaterialxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materialxv(enums::TriangleFace face, enums::MaterialParameter pname, const GLfixed* param) {
		#if defined(glMaterialxv)
			return glMaterialxv(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaterialxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void materialxvOES(enums::TriangleFace face, enums::MaterialParameter pname, const GLfixed* param) {
		#if defined(glMaterialxvOES)
			return glMaterialxvOES(static_cast<GLenum>(face), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaterialxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixFrustumEXT(enums::MatrixMode mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
		#if defined(glMatrixFrustumEXT)
			return glMatrixFrustumEXT(static_cast<GLenum>(mode), left, right, bottom, top, zNear, zFar);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixFrustumEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixIndexPointerARB(GLint size, enums::MatrixIndexPointerTypeARB type, GLsizei stride, const void * pointer) {
		#if defined(glMatrixIndexPointerARB)
			return glMatrixIndexPointerARB(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixIndexPointerARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixIndexPointerOES(GLint size, enums::MatrixIndexPointerTypeARB type, GLsizei stride, const void * pointer) {
		#if defined(glMatrixIndexPointerOES)
			return glMatrixIndexPointerOES(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixIndexPointerOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixIndexubvARB(GLint size, const GLubyte* indices) {
		#if defined(glMatrixIndexubvARB)
			return glMatrixIndexubvARB(size, indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixIndexubvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixIndexuivARB(GLint size, const GLuint* indices) {
		#if defined(glMatrixIndexuivARB)
			return glMatrixIndexuivARB(size, indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixIndexuivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixIndexusvARB(GLint size, const GLushort* indices) {
		#if defined(glMatrixIndexusvARB)
			return glMatrixIndexusvARB(size, indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixIndexusvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoad3x2fNV(GLenum matrixMode, const GLfloat* m) {
		#if defined(glMatrixLoad3x2fNV)
			return glMatrixLoad3x2fNV(matrixMode, m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoad3x2fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoad3x3fNV(GLenum matrixMode, const GLfloat* m) {
		#if defined(glMatrixLoad3x3fNV)
			return glMatrixLoad3x3fNV(matrixMode, m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoad3x3fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoadIdentityEXT(enums::MatrixMode mode) {
		#if defined(glMatrixLoadIdentityEXT)
			return glMatrixLoadIdentityEXT(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoadIdentityEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoadTranspose3x3fNV(GLenum matrixMode, const GLfloat* m) {
		#if defined(glMatrixLoadTranspose3x3fNV)
			return glMatrixLoadTranspose3x3fNV(matrixMode, m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoadTranspose3x3fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoadTransposedEXT(enums::MatrixMode mode, const GLdouble* m) {
		#if defined(glMatrixLoadTransposedEXT)
			return glMatrixLoadTransposedEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoadTransposedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoadTransposefEXT(enums::MatrixMode mode, const GLfloat* m) {
		#if defined(glMatrixLoadTransposefEXT)
			return glMatrixLoadTransposefEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoadTransposefEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoaddEXT(enums::MatrixMode mode, const GLdouble* m) {
		#if defined(glMatrixLoaddEXT)
			return glMatrixLoaddEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoaddEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixLoadfEXT(enums::MatrixMode mode, const GLfloat* m) {
		#if defined(glMatrixLoadfEXT)
			return glMatrixLoadfEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixLoadfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMode(enums::MatrixMode mode) {
		#if defined(glMatrixMode)
			return glMatrixMode(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMode" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMult3x2fNV(GLenum matrixMode, const GLfloat* m) {
		#if defined(glMatrixMult3x2fNV)
			return glMatrixMult3x2fNV(matrixMode, m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMult3x2fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMult3x3fNV(GLenum matrixMode, const GLfloat* m) {
		#if defined(glMatrixMult3x3fNV)
			return glMatrixMult3x3fNV(matrixMode, m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMult3x3fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMultTranspose3x3fNV(GLenum matrixMode, const GLfloat* m) {
		#if defined(glMatrixMultTranspose3x3fNV)
			return glMatrixMultTranspose3x3fNV(matrixMode, m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMultTranspose3x3fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMultTransposedEXT(enums::MatrixMode mode, const GLdouble* m) {
		#if defined(glMatrixMultTransposedEXT)
			return glMatrixMultTransposedEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMultTransposedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMultTransposefEXT(enums::MatrixMode mode, const GLfloat* m) {
		#if defined(glMatrixMultTransposefEXT)
			return glMatrixMultTransposefEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMultTransposefEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMultdEXT(enums::MatrixMode mode, const GLdouble* m) {
		#if defined(glMatrixMultdEXT)
			return glMatrixMultdEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMultdEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixMultfEXT(enums::MatrixMode mode, const GLfloat* m) {
		#if defined(glMatrixMultfEXT)
			return glMatrixMultfEXT(static_cast<GLenum>(mode), m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixMultfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixOrthoEXT(enums::MatrixMode mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
		#if defined(glMatrixOrthoEXT)
			return glMatrixOrthoEXT(static_cast<GLenum>(mode), left, right, bottom, top, zNear, zFar);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixOrthoEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixPopEXT(enums::MatrixMode mode) {
		#if defined(glMatrixPopEXT)
			return glMatrixPopEXT(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixPopEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixPushEXT(enums::MatrixMode mode) {
		#if defined(glMatrixPushEXT)
			return glMatrixPushEXT(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixPushEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixRotatedEXT(enums::MatrixMode mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glMatrixRotatedEXT)
			return glMatrixRotatedEXT(static_cast<GLenum>(mode), angle, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixRotatedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixRotatefEXT(enums::MatrixMode mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glMatrixRotatefEXT)
			return glMatrixRotatefEXT(static_cast<GLenum>(mode), angle, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixRotatefEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixScaledEXT(enums::MatrixMode mode, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glMatrixScaledEXT)
			return glMatrixScaledEXT(static_cast<GLenum>(mode), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixScaledEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixScalefEXT(enums::MatrixMode mode, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glMatrixScalefEXT)
			return glMatrixScalefEXT(static_cast<GLenum>(mode), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixScalefEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixTranslatedEXT(enums::MatrixMode mode, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glMatrixTranslatedEXT)
			return glMatrixTranslatedEXT(static_cast<GLenum>(mode), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixTranslatedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void matrixTranslatefEXT(enums::MatrixMode mode, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glMatrixTranslatefEXT)
			return glMatrixTranslatefEXT(static_cast<GLenum>(mode), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMatrixTranslatefEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void maxActiveShaderCoresARM(GLuint count) {
		#if defined(glMaxActiveShaderCoresARM)
			return glMaxActiveShaderCoresARM(count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaxActiveShaderCoresARM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void maxShaderCompilerThreadsKHR(GLuint count) {
		#if defined(glMaxShaderCompilerThreadsKHR)
			return glMaxShaderCompilerThreadsKHR(count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaxShaderCompilerThreadsKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void maxShaderCompilerThreadsARB(GLuint count) {
		#if defined(glMaxShaderCompilerThreadsARB)
			return glMaxShaderCompilerThreadsARB(count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMaxShaderCompilerThreadsARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void memoryBarrier(GLbitfield barriers) {
		#if defined(glMemoryBarrier)
			return glMemoryBarrier(barriers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMemoryBarrier" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void memoryBarrierByRegion(GLbitfield barriers) {
		#if defined(glMemoryBarrierByRegion)
			return glMemoryBarrierByRegion(barriers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMemoryBarrierByRegion" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void memoryBarrierEXT(GLbitfield barriers) {
		#if defined(glMemoryBarrierEXT)
			return glMemoryBarrierEXT(barriers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMemoryBarrierEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void memoryObjectParameterivEXT(GLuint memoryObject, enums::MemoryObjectParameterName pname, const GLint* params) {
		#if defined(glMemoryObjectParameterivEXT)
			return glMemoryObjectParameterivEXT(memoryObject, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMemoryObjectParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void minSampleShading(GLfloat value) {
		#if defined(glMinSampleShading)
			return glMinSampleShading(value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMinSampleShading" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void minSampleShadingARB(GLfloat value) {
		#if defined(glMinSampleShadingARB)
			return glMinSampleShadingARB(value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMinSampleShadingARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void minSampleShadingOES(GLfloat value) {
		#if defined(glMinSampleShadingOES)
			return glMinSampleShadingOES(value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMinSampleShadingOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void minmax(enums::MinmaxTargetEXT target, enums::InternalFormat internalformat, GLboolean sink) {
		#if defined(glMinmax)
			return glMinmax(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), sink);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMinmax" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void minmaxEXT(enums::MinmaxTargetEXT target, enums::InternalFormat internalformat, GLboolean sink) {
		#if defined(glMinmaxEXT)
			return glMinmaxEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), sink);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMinmaxEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multMatrixd(const GLdouble* m) {
		#if defined(glMultMatrixd)
			return glMultMatrixd(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultMatrixd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multMatrixf(const GLfloat* m) {
		#if defined(glMultMatrixf)
			return glMultMatrixf(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultMatrixf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multMatrixx(const GLfixed* m) {
		#if defined(glMultMatrixx)
			return glMultMatrixx(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultMatrixx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multMatrixxOES(const GLfixed* m) {
		#if defined(glMultMatrixxOES)
			return glMultMatrixxOES(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultMatrixxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multTransposeMatrixd(const GLdouble* m) {
		#if defined(glMultTransposeMatrixd)
			return glMultTransposeMatrixd(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultTransposeMatrixd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multTransposeMatrixdARB(const GLdouble* m) {
		#if defined(glMultTransposeMatrixdARB)
			return glMultTransposeMatrixdARB(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultTransposeMatrixdARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multTransposeMatrixf(const GLfloat* m) {
		#if defined(glMultTransposeMatrixf)
			return glMultTransposeMatrixf(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultTransposeMatrixf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multTransposeMatrixfARB(const GLfloat* m) {
		#if defined(glMultTransposeMatrixfARB)
			return glMultTransposeMatrixfARB(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultTransposeMatrixfARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multTransposeMatrixxOES(const GLfixed* m) {
		#if defined(glMultTransposeMatrixxOES)
			return glMultTransposeMatrixxOES(m);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultTransposeMatrixxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArrays(enums::PrimitiveType mode, const GLint* first, const GLsizei* count, GLsizei drawcount) {
		#if defined(glMultiDrawArrays)
			return glMultiDrawArrays(static_cast<GLenum>(mode), first, count, drawcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArrays" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysEXT(enums::PrimitiveType mode, const GLint* first, const GLsizei* count, GLsizei primcount) {
		#if defined(glMultiDrawArraysEXT)
			return glMultiDrawArraysEXT(static_cast<GLenum>(mode), first, count, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysIndirect(enums::PrimitiveType mode, const void * indirect, GLsizei drawcount, GLsizei stride) {
		#if defined(glMultiDrawArraysIndirect)
			return glMultiDrawArraysIndirect(static_cast<GLenum>(mode), indirect, drawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysIndirect" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysIndirectAMD(enums::PrimitiveType mode, const void * indirect, GLsizei primcount, GLsizei stride) {
		#if defined(glMultiDrawArraysIndirectAMD)
			return glMultiDrawArraysIndirectAMD(static_cast<GLenum>(mode), indirect, primcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysIndirectAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysIndirectBindlessCountNV(enums::PrimitiveType mode, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) {
		#if defined(glMultiDrawArraysIndirectBindlessCountNV)
			return glMultiDrawArraysIndirectBindlessCountNV(static_cast<GLenum>(mode), indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysIndirectBindlessCountNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysIndirectBindlessNV(enums::PrimitiveType mode, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) {
		#if defined(glMultiDrawArraysIndirectBindlessNV)
			return glMultiDrawArraysIndirectBindlessNV(static_cast<GLenum>(mode), indirect, drawCount, stride, vertexBufferCount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysIndirectBindlessNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysIndirectCount(enums::PrimitiveType mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
		#if defined(glMultiDrawArraysIndirectCount)
			return glMultiDrawArraysIndirectCount(static_cast<GLenum>(mode), indirect, drawcount, maxdrawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysIndirectCount" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysIndirectCountARB(enums::PrimitiveType mode, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
		#if defined(glMultiDrawArraysIndirectCountARB)
			return glMultiDrawArraysIndirectCountARB(static_cast<GLenum>(mode), indirect, drawcount, maxdrawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysIndirectCountARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawArraysIndirectEXT(enums::PrimitiveType mode, const void * indirect, GLsizei drawcount, GLsizei stride) {
		#if defined(glMultiDrawArraysIndirectEXT)
			return glMultiDrawArraysIndirectEXT(static_cast<GLenum>(mode), indirect, drawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawArraysIndirectEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementArrayAPPLE(enums::PrimitiveType mode, const GLint* first, const GLsizei* count, GLsizei primcount) {
		#if defined(glMultiDrawElementArrayAPPLE)
			return glMultiDrawElementArrayAPPLE(static_cast<GLenum>(mode), first, count, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementArrayAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElements(enums::PrimitiveType mode, const GLsizei* count, enums::DrawElementsType type, const void *const* indices, GLsizei drawcount) {
		#if defined(glMultiDrawElements)
			return glMultiDrawElements(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, drawcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElements" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsBaseVertex(enums::PrimitiveType mode, const GLsizei* count, enums::DrawElementsType type, const void *const* indices, GLsizei drawcount, const GLint* basevertex) {
		#if defined(glMultiDrawElementsBaseVertex)
			return glMultiDrawElementsBaseVertex(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, drawcount, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsBaseVertex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsBaseVertexEXT(enums::PrimitiveType mode, const GLsizei* count, enums::DrawElementsType type, const void *const* indices, GLsizei drawcount, const GLint* basevertex) {
		#if defined(glMultiDrawElementsBaseVertexEXT)
			return glMultiDrawElementsBaseVertexEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, drawcount, basevertex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsBaseVertexEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsEXT(enums::PrimitiveType mode, const GLsizei* count, enums::DrawElementsType type, const void *const* indices, GLsizei primcount) {
		#if defined(glMultiDrawElementsEXT)
			return glMultiDrawElementsEXT(static_cast<GLenum>(mode), count, static_cast<GLenum>(type), indices, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsIndirect(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect, GLsizei drawcount, GLsizei stride) {
		#if defined(glMultiDrawElementsIndirect)
			return glMultiDrawElementsIndirect(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, drawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsIndirect" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsIndirectAMD(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect, GLsizei primcount, GLsizei stride) {
		#if defined(glMultiDrawElementsIndirectAMD)
			return glMultiDrawElementsIndirectAMD(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, primcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsIndirectAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsIndirectBindlessCountNV(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect, GLsizei drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount) {
		#if defined(glMultiDrawElementsIndirectBindlessCountNV)
			return glMultiDrawElementsIndirectBindlessCountNV(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsIndirectBindlessCountNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsIndirectBindlessNV(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount) {
		#if defined(glMultiDrawElementsIndirectBindlessNV)
			return glMultiDrawElementsIndirectBindlessNV(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, drawCount, stride, vertexBufferCount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsIndirectBindlessNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsIndirectCount(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
		#if defined(glMultiDrawElementsIndirectCount)
			return glMultiDrawElementsIndirectCount(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, drawcount, maxdrawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsIndirectCount" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsIndirectCountARB(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
		#if defined(glMultiDrawElementsIndirectCountARB)
			return glMultiDrawElementsIndirectCountARB(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, drawcount, maxdrawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsIndirectCountARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawElementsIndirectEXT(enums::PrimitiveType mode, enums::DrawElementsType type, const void * indirect, GLsizei drawcount, GLsizei stride) {
		#if defined(glMultiDrawElementsIndirectEXT)
			return glMultiDrawElementsIndirectEXT(static_cast<GLenum>(mode), static_cast<GLenum>(type), indirect, drawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawElementsIndirectEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawMeshTasksIndirectNV(GLintptr indirect, GLsizei drawcount, GLsizei stride) {
		#if defined(glMultiDrawMeshTasksIndirectNV)
			return glMultiDrawMeshTasksIndirectNV(indirect, drawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawMeshTasksIndirectNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawMeshTasksIndirectCountNV(GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
		#if defined(glMultiDrawMeshTasksIndirectCountNV)
			return glMultiDrawMeshTasksIndirectCountNV(indirect, drawcount, maxdrawcount, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawMeshTasksIndirectCountNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiDrawRangeElementArrayAPPLE(enums::PrimitiveType mode, GLuint start, GLuint end, const GLint* first, const GLsizei* count, GLsizei primcount) {
		#if defined(glMultiDrawRangeElementArrayAPPLE)
			return glMultiDrawRangeElementArrayAPPLE(static_cast<GLenum>(mode), start, end, first, count, primcount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiDrawRangeElementArrayAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiModeDrawArraysIBM(const GLenum* mode, const GLint* first, const GLsizei* count, GLsizei primcount, GLint modestride) {
		#if defined(glMultiModeDrawArraysIBM)
			return glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiModeDrawArraysIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiModeDrawElementsIBM(const GLenum* mode, const GLsizei* count, enums::DrawElementsType type, const void *const* indices, GLsizei primcount, GLint modestride) {
		#if defined(glMultiModeDrawElementsIBM)
			return glMultiModeDrawElementsIBM(mode, count, static_cast<GLenum>(type), indices, primcount, modestride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiModeDrawElementsIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexBufferEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::InternalFormat internalformat, GLuint buffer) {
		#if defined(glMultiTexBufferEXT)
			return glMultiTexBufferEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1bOES(enums::TextureUnit texture, GLbyte s) {
		#if defined(glMultiTexCoord1bOES)
			return glMultiTexCoord1bOES(static_cast<GLenum>(texture), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1bvOES(enums::TextureUnit texture, const GLbyte* coords) {
		#if defined(glMultiTexCoord1bvOES)
			return glMultiTexCoord1bvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1d(enums::TextureUnit target, GLdouble s) {
		#if defined(glMultiTexCoord1d)
			return glMultiTexCoord1d(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1dARB(enums::TextureUnit target, GLdouble s) {
		#if defined(glMultiTexCoord1dARB)
			return glMultiTexCoord1dARB(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1dv(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord1dv)
			return glMultiTexCoord1dv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1dvARB(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord1dvARB)
			return glMultiTexCoord1dvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1f(enums::TextureUnit target, GLfloat s) {
		#if defined(glMultiTexCoord1f)
			return glMultiTexCoord1f(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1fARB(enums::TextureUnit target, GLfloat s) {
		#if defined(glMultiTexCoord1fARB)
			return glMultiTexCoord1fARB(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1fv(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord1fv)
			return glMultiTexCoord1fv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1fvARB(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord1fvARB)
			return glMultiTexCoord1fvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1hNV(enums::TextureUnit target, GLhalfNV s) {
		#if defined(glMultiTexCoord1hNV)
			return glMultiTexCoord1hNV(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1hvNV(enums::TextureUnit target, const GLhalfNV* v) {
		#if defined(glMultiTexCoord1hvNV)
			return glMultiTexCoord1hvNV(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1i(enums::TextureUnit target, GLint s) {
		#if defined(glMultiTexCoord1i)
			return glMultiTexCoord1i(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1iARB(enums::TextureUnit target, GLint s) {
		#if defined(glMultiTexCoord1iARB)
			return glMultiTexCoord1iARB(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1iv(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord1iv)
			return glMultiTexCoord1iv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1ivARB(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord1ivARB)
			return glMultiTexCoord1ivARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1s(enums::TextureUnit target, GLshort s) {
		#if defined(glMultiTexCoord1s)
			return glMultiTexCoord1s(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1sARB(enums::TextureUnit target, GLshort s) {
		#if defined(glMultiTexCoord1sARB)
			return glMultiTexCoord1sARB(static_cast<GLenum>(target), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1sv(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord1sv)
			return glMultiTexCoord1sv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1svARB(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord1svARB)
			return glMultiTexCoord1svARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1xOES(enums::TextureUnit texture, GLfixed s) {
		#if defined(glMultiTexCoord1xOES)
			return glMultiTexCoord1xOES(static_cast<GLenum>(texture), s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord1xvOES(enums::TextureUnit texture, const GLfixed* coords) {
		#if defined(glMultiTexCoord1xvOES)
			return glMultiTexCoord1xvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord1xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2bOES(enums::TextureUnit texture, GLbyte s, GLbyte t) {
		#if defined(glMultiTexCoord2bOES)
			return glMultiTexCoord2bOES(static_cast<GLenum>(texture), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2bvOES(enums::TextureUnit texture, const GLbyte* coords) {
		#if defined(glMultiTexCoord2bvOES)
			return glMultiTexCoord2bvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2d(enums::TextureUnit target, GLdouble s, GLdouble t) {
		#if defined(glMultiTexCoord2d)
			return glMultiTexCoord2d(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2dARB(enums::TextureUnit target, GLdouble s, GLdouble t) {
		#if defined(glMultiTexCoord2dARB)
			return glMultiTexCoord2dARB(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2dv(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord2dv)
			return glMultiTexCoord2dv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2dvARB(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord2dvARB)
			return glMultiTexCoord2dvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2f(enums::TextureUnit target, GLfloat s, GLfloat t) {
		#if defined(glMultiTexCoord2f)
			return glMultiTexCoord2f(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2fARB(enums::TextureUnit target, GLfloat s, GLfloat t) {
		#if defined(glMultiTexCoord2fARB)
			return glMultiTexCoord2fARB(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2fv(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord2fv)
			return glMultiTexCoord2fv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2fvARB(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord2fvARB)
			return glMultiTexCoord2fvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2hNV(enums::TextureUnit target, GLhalfNV s, GLhalfNV t) {
		#if defined(glMultiTexCoord2hNV)
			return glMultiTexCoord2hNV(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2hvNV(enums::TextureUnit target, const GLhalfNV* v) {
		#if defined(glMultiTexCoord2hvNV)
			return glMultiTexCoord2hvNV(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2i(enums::TextureUnit target, GLint s, GLint t) {
		#if defined(glMultiTexCoord2i)
			return glMultiTexCoord2i(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2iARB(enums::TextureUnit target, GLint s, GLint t) {
		#if defined(glMultiTexCoord2iARB)
			return glMultiTexCoord2iARB(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2iv(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord2iv)
			return glMultiTexCoord2iv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2ivARB(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord2ivARB)
			return glMultiTexCoord2ivARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2s(enums::TextureUnit target, GLshort s, GLshort t) {
		#if defined(glMultiTexCoord2s)
			return glMultiTexCoord2s(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2sARB(enums::TextureUnit target, GLshort s, GLshort t) {
		#if defined(glMultiTexCoord2sARB)
			return glMultiTexCoord2sARB(static_cast<GLenum>(target), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2sv(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord2sv)
			return glMultiTexCoord2sv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2svARB(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord2svARB)
			return glMultiTexCoord2svARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2xOES(enums::TextureUnit texture, GLfixed s, GLfixed t) {
		#if defined(glMultiTexCoord2xOES)
			return glMultiTexCoord2xOES(static_cast<GLenum>(texture), s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord2xvOES(enums::TextureUnit texture, const GLfixed* coords) {
		#if defined(glMultiTexCoord2xvOES)
			return glMultiTexCoord2xvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord2xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3bOES(enums::TextureUnit texture, GLbyte s, GLbyte t, GLbyte r) {
		#if defined(glMultiTexCoord3bOES)
			return glMultiTexCoord3bOES(static_cast<GLenum>(texture), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3bvOES(enums::TextureUnit texture, const GLbyte* coords) {
		#if defined(glMultiTexCoord3bvOES)
			return glMultiTexCoord3bvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3d(enums::TextureUnit target, GLdouble s, GLdouble t, GLdouble r) {
		#if defined(glMultiTexCoord3d)
			return glMultiTexCoord3d(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3dARB(enums::TextureUnit target, GLdouble s, GLdouble t, GLdouble r) {
		#if defined(glMultiTexCoord3dARB)
			return glMultiTexCoord3dARB(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3dv(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord3dv)
			return glMultiTexCoord3dv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3dvARB(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord3dvARB)
			return glMultiTexCoord3dvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3f(enums::TextureUnit target, GLfloat s, GLfloat t, GLfloat r) {
		#if defined(glMultiTexCoord3f)
			return glMultiTexCoord3f(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3fARB(enums::TextureUnit target, GLfloat s, GLfloat t, GLfloat r) {
		#if defined(glMultiTexCoord3fARB)
			return glMultiTexCoord3fARB(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3fv(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord3fv)
			return glMultiTexCoord3fv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3fvARB(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord3fvARB)
			return glMultiTexCoord3fvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3hNV(enums::TextureUnit target, GLhalfNV s, GLhalfNV t, GLhalfNV r) {
		#if defined(glMultiTexCoord3hNV)
			return glMultiTexCoord3hNV(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3hvNV(enums::TextureUnit target, const GLhalfNV* v) {
		#if defined(glMultiTexCoord3hvNV)
			return glMultiTexCoord3hvNV(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3i(enums::TextureUnit target, GLint s, GLint t, GLint r) {
		#if defined(glMultiTexCoord3i)
			return glMultiTexCoord3i(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3iARB(enums::TextureUnit target, GLint s, GLint t, GLint r) {
		#if defined(glMultiTexCoord3iARB)
			return glMultiTexCoord3iARB(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3iv(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord3iv)
			return glMultiTexCoord3iv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3ivARB(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord3ivARB)
			return glMultiTexCoord3ivARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3s(enums::TextureUnit target, GLshort s, GLshort t, GLshort r) {
		#if defined(glMultiTexCoord3s)
			return glMultiTexCoord3s(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3sARB(enums::TextureUnit target, GLshort s, GLshort t, GLshort r) {
		#if defined(glMultiTexCoord3sARB)
			return glMultiTexCoord3sARB(static_cast<GLenum>(target), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3sv(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord3sv)
			return glMultiTexCoord3sv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3svARB(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord3svARB)
			return glMultiTexCoord3svARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3xOES(enums::TextureUnit texture, GLfixed s, GLfixed t, GLfixed r) {
		#if defined(glMultiTexCoord3xOES)
			return glMultiTexCoord3xOES(static_cast<GLenum>(texture), s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord3xvOES(enums::TextureUnit texture, const GLfixed* coords) {
		#if defined(glMultiTexCoord3xvOES)
			return glMultiTexCoord3xvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord3xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4bOES(enums::TextureUnit texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q) {
		#if defined(glMultiTexCoord4bOES)
			return glMultiTexCoord4bOES(static_cast<GLenum>(texture), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4bvOES(enums::TextureUnit texture, const GLbyte* coords) {
		#if defined(glMultiTexCoord4bvOES)
			return glMultiTexCoord4bvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4d(enums::TextureUnit target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
		#if defined(glMultiTexCoord4d)
			return glMultiTexCoord4d(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4dARB(enums::TextureUnit target, GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
		#if defined(glMultiTexCoord4dARB)
			return glMultiTexCoord4dARB(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4dv(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord4dv)
			return glMultiTexCoord4dv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4dvARB(enums::TextureUnit target, const GLdouble* v) {
		#if defined(glMultiTexCoord4dvARB)
			return glMultiTexCoord4dvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4f(enums::TextureUnit target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
		#if defined(glMultiTexCoord4f)
			return glMultiTexCoord4f(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4fARB(enums::TextureUnit target, GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
		#if defined(glMultiTexCoord4fARB)
			return glMultiTexCoord4fARB(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4fv(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord4fv)
			return glMultiTexCoord4fv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4fvARB(enums::TextureUnit target, const GLfloat* v) {
		#if defined(glMultiTexCoord4fvARB)
			return glMultiTexCoord4fvARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4hNV(enums::TextureUnit target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
		#if defined(glMultiTexCoord4hNV)
			return glMultiTexCoord4hNV(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4hvNV(enums::TextureUnit target, const GLhalfNV* v) {
		#if defined(glMultiTexCoord4hvNV)
			return glMultiTexCoord4hvNV(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4i(enums::TextureUnit target, GLint s, GLint t, GLint r, GLint q) {
		#if defined(glMultiTexCoord4i)
			return glMultiTexCoord4i(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4iARB(enums::TextureUnit target, GLint s, GLint t, GLint r, GLint q) {
		#if defined(glMultiTexCoord4iARB)
			return glMultiTexCoord4iARB(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4iv(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord4iv)
			return glMultiTexCoord4iv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4ivARB(enums::TextureUnit target, const GLint* v) {
		#if defined(glMultiTexCoord4ivARB)
			return glMultiTexCoord4ivARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4s(enums::TextureUnit target, GLshort s, GLshort t, GLshort r, GLshort q) {
		#if defined(glMultiTexCoord4s)
			return glMultiTexCoord4s(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4sARB(enums::TextureUnit target, GLshort s, GLshort t, GLshort r, GLshort q) {
		#if defined(glMultiTexCoord4sARB)
			return glMultiTexCoord4sARB(static_cast<GLenum>(target), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4sv(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord4sv)
			return glMultiTexCoord4sv(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4svARB(enums::TextureUnit target, const GLshort* v) {
		#if defined(glMultiTexCoord4svARB)
			return glMultiTexCoord4svARB(static_cast<GLenum>(target), v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4x(enums::TextureUnit texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) {
		#if defined(glMultiTexCoord4x)
			return glMultiTexCoord4x(static_cast<GLenum>(texture), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4x" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4xOES(enums::TextureUnit texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q) {
		#if defined(glMultiTexCoord4xOES)
			return glMultiTexCoord4xOES(static_cast<GLenum>(texture), s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoord4xvOES(enums::TextureUnit texture, const GLfixed* coords) {
		#if defined(glMultiTexCoord4xvOES)
			return glMultiTexCoord4xvOES(static_cast<GLenum>(texture), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoord4xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP1ui(enums::TextureUnit texture, enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glMultiTexCoordP1ui)
			return glMultiTexCoordP1ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP1ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP1uiv(enums::TextureUnit texture, enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glMultiTexCoordP1uiv)
			return glMultiTexCoordP1uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP1uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP2ui(enums::TextureUnit texture, enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glMultiTexCoordP2ui)
			return glMultiTexCoordP2ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP2ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP2uiv(enums::TextureUnit texture, enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glMultiTexCoordP2uiv)
			return glMultiTexCoordP2uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP2uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP3ui(enums::TextureUnit texture, enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glMultiTexCoordP3ui)
			return glMultiTexCoordP3ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP3uiv(enums::TextureUnit texture, enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glMultiTexCoordP3uiv)
			return glMultiTexCoordP3uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP4ui(enums::TextureUnit texture, enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glMultiTexCoordP4ui)
			return glMultiTexCoordP4ui(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordP4uiv(enums::TextureUnit texture, enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glMultiTexCoordP4uiv)
			return glMultiTexCoordP4uiv(static_cast<GLenum>(texture), static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordP4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexCoordPointerEXT(enums::TextureUnit texunit, GLint size, enums::TexCoordPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glMultiTexCoordPointerEXT)
			return glMultiTexCoordPointerEXT(static_cast<GLenum>(texunit), size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexCoordPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexEnvfEXT(enums::TextureUnit texunit, enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfloat param) {
		#if defined(glMultiTexEnvfEXT)
			return glMultiTexEnvfEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexEnvfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexEnvfvEXT(enums::TextureUnit texunit, enums::TextureEnvTarget target, enums::TextureEnvParameter pname, const GLfloat* params) {
		#if defined(glMultiTexEnvfvEXT)
			return glMultiTexEnvfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexEnvfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexEnviEXT(enums::TextureUnit texunit, enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLint param) {
		#if defined(glMultiTexEnviEXT)
			return glMultiTexEnviEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexEnviEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexEnvivEXT(enums::TextureUnit texunit, enums::TextureEnvTarget target, enums::TextureEnvParameter pname, const GLint* params) {
		#if defined(glMultiTexEnvivEXT)
			return glMultiTexEnvivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexEnvivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexGendEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, GLdouble param) {
		#if defined(glMultiTexGendEXT)
			return glMultiTexGendEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexGendEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexGendvEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLdouble* params) {
		#if defined(glMultiTexGendvEXT)
			return glMultiTexGendvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexGendvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexGenfEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfloat param) {
		#if defined(glMultiTexGenfEXT)
			return glMultiTexGenfEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexGenfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexGenfvEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLfloat* params) {
		#if defined(glMultiTexGenfvEXT)
			return glMultiTexGenfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexGenfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexGeniEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, GLint param) {
		#if defined(glMultiTexGeniEXT)
			return glMultiTexGeniEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexGeniEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexGenivEXT(enums::TextureUnit texunit, enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLint* params) {
		#if defined(glMultiTexGenivEXT)
			return glMultiTexGenivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexGenivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexImage1DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glMultiTexImage1DEXT)
			return glMultiTexImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, width, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexImage2DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glMultiTexImage2DEXT)
			return glMultiTexImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, width, height, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexImage3DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glMultiTexImage3DEXT)
			return glMultiTexImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, internalformat, width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexParameterIivEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glMultiTexParameterIivEXT)
			return glMultiTexParameterIivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexParameterIuivEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::TextureParameterName pname, const GLuint* params) {
		#if defined(glMultiTexParameterIuivEXT)
			return glMultiTexParameterIuivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexParameterfEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::TextureParameterName pname, GLfloat param) {
		#if defined(glMultiTexParameterfEXT)
			return glMultiTexParameterfEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexParameterfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexParameterfvEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::TextureParameterName pname, const GLfloat* params) {
		#if defined(glMultiTexParameterfvEXT)
			return glMultiTexParameterfvEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexParameteriEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::TextureParameterName pname, GLint param) {
		#if defined(glMultiTexParameteriEXT)
			return glMultiTexParameteriEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexParameteriEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexParameterivEXT(enums::TextureUnit texunit, enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glMultiTexParameterivEXT)
			return glMultiTexParameterivEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexRenderbufferEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLuint renderbuffer) {
		#if defined(glMultiTexRenderbufferEXT)
			return glMultiTexRenderbufferEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexRenderbufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexSubImage1DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glMultiTexSubImage1DEXT)
			return glMultiTexSubImage1DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexSubImage2DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glMultiTexSubImage2DEXT)
			return glMultiTexSubImage2DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multiTexSubImage3DEXT(enums::TextureUnit texunit, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glMultiTexSubImage3DEXT)
			return glMultiTexSubImage3DEXT(static_cast<GLenum>(texunit), static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMultiTexSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastBarrierNV() {
		#if defined(glMulticastBarrierNV)
			return glMulticastBarrierNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastBarrierNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastBlitFramebufferNV(GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
		#if defined(glMulticastBlitFramebufferNV)
			return glMulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastBlitFramebufferNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastBufferSubDataNV(GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data) {
		#if defined(glMulticastBufferSubDataNV)
			return glMulticastBufferSubDataNV(gpuMask, buffer, offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastBufferSubDataNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastCopyBufferSubDataNV(GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
		#if defined(glMulticastCopyBufferSubDataNV)
			return glMulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastCopyBufferSubDataNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastCopyImageSubDataNV(GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
		#if defined(glMulticastCopyImageSubDataNV)
			return glMulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastCopyImageSubDataNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastFramebufferSampleLocationsfvNV(GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v) {
		#if defined(glMulticastFramebufferSampleLocationsfvNV)
			return glMulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastFramebufferSampleLocationsfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastGetQueryObjecti64vNV(GLuint gpu, GLuint id, GLenum pname, GLint64* params) {
		#if defined(glMulticastGetQueryObjecti64vNV)
			return glMulticastGetQueryObjecti64vNV(gpu, id, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastGetQueryObjecti64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastGetQueryObjectivNV(GLuint gpu, GLuint id, GLenum pname, GLint* params) {
		#if defined(glMulticastGetQueryObjectivNV)
			return glMulticastGetQueryObjectivNV(gpu, id, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastGetQueryObjectivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastGetQueryObjectui64vNV(GLuint gpu, GLuint id, GLenum pname, GLuint64* params) {
		#if defined(glMulticastGetQueryObjectui64vNV)
			return glMulticastGetQueryObjectui64vNV(gpu, id, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastGetQueryObjectui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastGetQueryObjectuivNV(GLuint gpu, GLuint id, GLenum pname, GLuint* params) {
		#if defined(glMulticastGetQueryObjectuivNV)
			return glMulticastGetQueryObjectuivNV(gpu, id, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastGetQueryObjectuivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastScissorArrayvNVX(GLuint gpu, GLuint first, GLsizei count, const GLint* v) {
		#if defined(glMulticastScissorArrayvNVX)
			return glMulticastScissorArrayvNVX(gpu, first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastScissorArrayvNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastViewportArrayvNVX(GLuint gpu, GLuint first, GLsizei count, const GLfloat* v) {
		#if defined(glMulticastViewportArrayvNVX)
			return glMulticastViewportArrayvNVX(gpu, first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastViewportArrayvNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastViewportPositionWScaleNVX(GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff) {
		#if defined(glMulticastViewportPositionWScaleNVX)
			return glMulticastViewportPositionWScaleNVX(gpu, index, xcoeff, ycoeff);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastViewportPositionWScaleNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void multicastWaitSyncNV(GLuint signalGpu, GLbitfield waitGpuMask) {
		#if defined(glMulticastWaitSyncNV)
			return glMulticastWaitSyncNV(signalGpu, waitGpuMask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glMulticastWaitSyncNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferAttachMemoryNV(GLuint buffer, GLuint memory, GLuint64 offset) {
		#if defined(glNamedBufferAttachMemoryNV)
			return glNamedBufferAttachMemoryNV(buffer, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferAttachMemoryNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferData(GLuint buffer, GLsizeiptr size, const void * data, enums::VertexBufferObjectUsage usage) {
		#if defined(glNamedBufferData)
			return glNamedBufferData(buffer, size, data, static_cast<GLenum>(usage));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferDataEXT(GLuint buffer, GLsizeiptr size, const void * data, enums::VertexBufferObjectUsage usage) {
		#if defined(glNamedBufferDataEXT)
			return glNamedBufferDataEXT(buffer, size, data, static_cast<GLenum>(usage));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferDataEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferPageCommitmentARB(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) {
		#if defined(glNamedBufferPageCommitmentARB)
			return glNamedBufferPageCommitmentARB(buffer, offset, size, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferPageCommitmentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferPageCommitmentEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLboolean commit) {
		#if defined(glNamedBufferPageCommitmentEXT)
			return glNamedBufferPageCommitmentEXT(buffer, offset, size, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferPageCommitmentEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferPageCommitmentMemNV(GLuint buffer, GLintptr offset, GLsizeiptr size, GLuint memory, GLuint64 memOffset, GLboolean commit) {
		#if defined(glNamedBufferPageCommitmentMemNV)
			return glNamedBufferPageCommitmentMemNV(buffer, offset, size, memory, memOffset, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferPageCommitmentMemNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferStorage(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags) {
		#if defined(glNamedBufferStorage)
			return glNamedBufferStorage(buffer, size, data, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferStorage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferStorageExternalEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags) {
		#if defined(glNamedBufferStorageExternalEXT)
			return glNamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferStorageExternalEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const void * data, GLbitfield flags) {
		#if defined(glNamedBufferStorageEXT)
			return glNamedBufferStorageEXT(buffer, size, data, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferStorageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferStorageMemEXT(GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset) {
		#if defined(glNamedBufferStorageMemEXT)
			return glNamedBufferStorageMemEXT(buffer, size, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferStorageMemEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data) {
		#if defined(glNamedBufferSubData)
			return glNamedBufferSubData(buffer, offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferSubData" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const void * data) {
		#if defined(glNamedBufferSubDataEXT)
			return glNamedBufferSubDataEXT(buffer, offset, size, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedBufferSubDataEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
		#if defined(glNamedCopyBufferSubDataEXT)
			return glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedCopyBufferSubDataEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferDrawBuffer(GLuint framebuffer, enums::ColorBuffer buf) {
		#if defined(glNamedFramebufferDrawBuffer)
			return glNamedFramebufferDrawBuffer(framebuffer, static_cast<GLenum>(buf));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferDrawBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum* bufs) {
		#if defined(glNamedFramebufferDrawBuffers)
			return glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferDrawBuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferParameteri(GLuint framebuffer, enums::FramebufferParameterName pname, GLint param) {
		#if defined(glNamedFramebufferParameteri)
			return glNamedFramebufferParameteri(framebuffer, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferParameteriEXT(GLuint framebuffer, enums::FramebufferParameterName pname, GLint param) {
		#if defined(glNamedFramebufferParameteriEXT)
			return glNamedFramebufferParameteriEXT(framebuffer, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferParameteriEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferReadBuffer(GLuint framebuffer, enums::ColorBuffer src) {
		#if defined(glNamedFramebufferReadBuffer)
			return glNamedFramebufferReadBuffer(framebuffer, static_cast<GLenum>(src));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferReadBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferRenderbuffer(GLuint framebuffer, enums::FramebufferAttachment attachment, enums::RenderbufferTarget renderbuffertarget, GLuint renderbuffer) {
		#if defined(glNamedFramebufferRenderbuffer)
			return glNamedFramebufferRenderbuffer(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferRenderbuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferRenderbufferEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, enums::RenderbufferTarget renderbuffertarget, GLuint renderbuffer) {
		#if defined(glNamedFramebufferRenderbufferEXT)
			return glNamedFramebufferRenderbufferEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(renderbuffertarget), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferRenderbufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferSampleLocationsfvARB(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v) {
		#if defined(glNamedFramebufferSampleLocationsfvARB)
			return glNamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferSampleLocationsfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferSampleLocationsfvNV(GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v) {
		#if defined(glNamedFramebufferSampleLocationsfvNV)
			return glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferSampleLocationsfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTexture(GLuint framebuffer, enums::FramebufferAttachment attachment, GLuint texture, GLint level) {
		#if defined(glNamedFramebufferTexture)
			return glNamedFramebufferTexture(framebuffer, static_cast<GLenum>(attachment), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTexture" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferSamplePositionsfvAMD(GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat* values) {
		#if defined(glNamedFramebufferSamplePositionsfvAMD)
			return glNamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferSamplePositionsfvAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTexture1DEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level) {
		#if defined(glNamedFramebufferTexture1DEXT)
			return glNamedFramebufferTexture1DEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTexture1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTexture2DEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level) {
		#if defined(glNamedFramebufferTexture2DEXT)
			return glNamedFramebufferTexture2DEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTexture2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTexture3DEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, enums::TextureTarget textarget, GLuint texture, GLint level, GLint zoffset) {
		#if defined(glNamedFramebufferTexture3DEXT)
			return glNamedFramebufferTexture3DEXT(framebuffer, static_cast<GLenum>(attachment), static_cast<GLenum>(textarget), texture, level, zoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTexture3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTextureEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, GLuint texture, GLint level) {
		#if defined(glNamedFramebufferTextureEXT)
			return glNamedFramebufferTextureEXT(framebuffer, static_cast<GLenum>(attachment), texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTextureEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTextureFaceEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, GLuint texture, GLint level, enums::TextureTarget face) {
		#if defined(glNamedFramebufferTextureFaceEXT)
			return glNamedFramebufferTextureFaceEXT(framebuffer, static_cast<GLenum>(attachment), texture, level, static_cast<GLenum>(face));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTextureFaceEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTextureLayer(GLuint framebuffer, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint layer) {
		#if defined(glNamedFramebufferTextureLayer)
			return glNamedFramebufferTextureLayer(framebuffer, static_cast<GLenum>(attachment), texture, level, layer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTextureLayer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTextureLayerEXT(GLuint framebuffer, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint layer) {
		#if defined(glNamedFramebufferTextureLayerEXT)
			return glNamedFramebufferTextureLayerEXT(framebuffer, static_cast<GLenum>(attachment), texture, level, layer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTextureLayerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedFramebufferTextureMultiviewOVR(GLuint framebuffer, enums::FramebufferAttachment attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews) {
		#if defined(glNamedFramebufferTextureMultiviewOVR)
			return glNamedFramebufferTextureMultiviewOVR(framebuffer, static_cast<GLenum>(attachment), texture, level, baseViewIndex, numViews);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedFramebufferTextureMultiviewOVR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameter4dEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glNamedProgramLocalParameter4dEXT)
			return glNamedProgramLocalParameter4dEXT(program, static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameter4dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameter4dvEXT(GLuint program, enums::ProgramTarget target, GLuint index, const GLdouble* params) {
		#if defined(glNamedProgramLocalParameter4dvEXT)
			return glNamedProgramLocalParameter4dvEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameter4dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameter4fEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glNamedProgramLocalParameter4fEXT)
			return glNamedProgramLocalParameter4fEXT(program, static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameter4fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameter4fvEXT(GLuint program, enums::ProgramTarget target, GLuint index, const GLfloat* params) {
		#if defined(glNamedProgramLocalParameter4fvEXT)
			return glNamedProgramLocalParameter4fvEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameter4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameterI4iEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
		#if defined(glNamedProgramLocalParameterI4iEXT)
			return glNamedProgramLocalParameterI4iEXT(program, static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameterI4iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameterI4ivEXT(GLuint program, enums::ProgramTarget target, GLuint index, const GLint* params) {
		#if defined(glNamedProgramLocalParameterI4ivEXT)
			return glNamedProgramLocalParameterI4ivEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameterI4ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameterI4uiEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
		#if defined(glNamedProgramLocalParameterI4uiEXT)
			return glNamedProgramLocalParameterI4uiEXT(program, static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameterI4uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameterI4uivEXT(GLuint program, enums::ProgramTarget target, GLuint index, const GLuint* params) {
		#if defined(glNamedProgramLocalParameterI4uivEXT)
			return glNamedProgramLocalParameterI4uivEXT(program, static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameterI4uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParameters4fvEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLsizei count, const GLfloat* params) {
		#if defined(glNamedProgramLocalParameters4fvEXT)
			return glNamedProgramLocalParameters4fvEXT(program, static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParameters4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParametersI4ivEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLsizei count, const GLint* params) {
		#if defined(glNamedProgramLocalParametersI4ivEXT)
			return glNamedProgramLocalParametersI4ivEXT(program, static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParametersI4ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramLocalParametersI4uivEXT(GLuint program, enums::ProgramTarget target, GLuint index, GLsizei count, const GLuint* params) {
		#if defined(glNamedProgramLocalParametersI4uivEXT)
			return glNamedProgramLocalParametersI4uivEXT(program, static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramLocalParametersI4uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedProgramStringEXT(GLuint program, enums::ProgramTarget target, enums::ProgramFormat format, GLsizei len, const void * string) {
		#if defined(glNamedProgramStringEXT)
			return glNamedProgramStringEXT(program, static_cast<GLenum>(target), static_cast<GLenum>(format), len, string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedProgramStringEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedRenderbufferStorage(GLuint renderbuffer, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glNamedRenderbufferStorage)
			return glNamedRenderbufferStorage(renderbuffer, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedRenderbufferStorage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedRenderbufferStorageEXT(GLuint renderbuffer, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glNamedRenderbufferStorageEXT)
			return glNamedRenderbufferStorageEXT(renderbuffer, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedRenderbufferStorageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glNamedRenderbufferStorageMultisample)
			return glNamedRenderbufferStorageMultisample(renderbuffer, samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedRenderbufferStorageMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedRenderbufferStorageMultisampleAdvancedAMD(GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glNamedRenderbufferStorageMultisampleAdvancedAMD)
			return glNamedRenderbufferStorageMultisampleAdvancedAMD(renderbuffer, samples, storageSamples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedRenderbufferStorageMultisampleAdvancedAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glNamedRenderbufferStorageMultisampleCoverageEXT)
			return glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedRenderbufferStorageMultisampleCoverageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glNamedRenderbufferStorageMultisampleEXT)
			return glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedRenderbufferStorageMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void namedStringARB(GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar* string) {
		#if defined(glNamedStringARB)
			return glNamedStringARB(type, namelen, name, stringlen, string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNamedStringARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void newList(GLuint list, enums::ListMode mode) {
		#if defined(glNewList)
			return glNewList(list, static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNewList" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLuint newObjectBufferATI(GLsizei size, const void * pointer, enums::ArrayObjectUsageATI usage) {
		#if defined(glNewObjectBufferATI)
			return glNewObjectBufferATI(size, pointer, static_cast<GLenum>(usage));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNewObjectBufferATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void normal3b(GLbyte nx, GLbyte ny, GLbyte nz) {
		#if defined(glNormal3b)
			return glNormal3b(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3b" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3bv(const GLbyte* v) {
		#if defined(glNormal3bv)
			return glNormal3bv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3bv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3d(GLdouble nx, GLdouble ny, GLdouble nz) {
		#if defined(glNormal3d)
			return glNormal3d(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3dv(const GLdouble* v) {
		#if defined(glNormal3dv)
			return glNormal3dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3f(GLfloat nx, GLfloat ny, GLfloat nz) {
		#if defined(glNormal3f)
			return glNormal3f(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glNormal3fVertex3fSUN)
			return glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3fVertex3fvSUN(const GLfloat* n, const GLfloat* v) {
		#if defined(glNormal3fVertex3fvSUN)
			return glNormal3fVertex3fvSUN(n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3fv(const GLfloat* v) {
		#if defined(glNormal3fv)
			return glNormal3fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz) {
		#if defined(glNormal3hNV)
			return glNormal3hNV(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3hvNV(const GLhalfNV* v) {
		#if defined(glNormal3hvNV)
			return glNormal3hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3i(GLint nx, GLint ny, GLint nz) {
		#if defined(glNormal3i)
			return glNormal3i(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3iv(const GLint* v) {
		#if defined(glNormal3iv)
			return glNormal3iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3s(GLshort nx, GLshort ny, GLshort nz) {
		#if defined(glNormal3s)
			return glNormal3s(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3sv(const GLshort* v) {
		#if defined(glNormal3sv)
			return glNormal3sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3x(GLfixed nx, GLfixed ny, GLfixed nz) {
		#if defined(glNormal3x)
			return glNormal3x(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3x" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3xOES(GLfixed nx, GLfixed ny, GLfixed nz) {
		#if defined(glNormal3xOES)
			return glNormal3xOES(nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normal3xvOES(const GLfixed* coords) {
		#if defined(glNormal3xvOES)
			return glNormal3xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormal3xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalFormatNV(GLenum type, GLsizei stride) {
		#if defined(glNormalFormatNV)
			return glNormalFormatNV(type, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalP3ui(enums::NormalPointerType type, GLuint coords) {
		#if defined(glNormalP3ui)
			return glNormalP3ui(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalP3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalP3uiv(enums::NormalPointerType type, const GLuint* coords) {
		#if defined(glNormalP3uiv)
			return glNormalP3uiv(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalP3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalPointer(enums::NormalPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glNormalPointer)
			return glNormalPointer(static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalPointerEXT(enums::NormalPointerType type, GLsizei stride, GLsizei count, const void * pointer) {
		#if defined(glNormalPointerEXT)
			return glNormalPointerEXT(static_cast<GLenum>(type), stride, count, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalPointerListIBM(enums::NormalPointerType type, GLint stride, const void ** pointer, GLint ptrstride) {
		#if defined(glNormalPointerListIBM)
			return glNormalPointerListIBM(static_cast<GLenum>(type), stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalPointervINTEL(enums::NormalPointerType type, const void ** pointer) {
		#if defined(glNormalPointervINTEL)
			return glNormalPointervINTEL(static_cast<GLenum>(type), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalPointervINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3bATI(enums::VertexStreamATI stream, GLbyte nx, GLbyte ny, GLbyte nz) {
		#if defined(glNormalStream3bATI)
			return glNormalStream3bATI(static_cast<GLenum>(stream), nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3bATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3bvATI(enums::VertexStreamATI stream, const GLbyte* coords) {
		#if defined(glNormalStream3bvATI)
			return glNormalStream3bvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3bvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3dATI(enums::VertexStreamATI stream, GLdouble nx, GLdouble ny, GLdouble nz) {
		#if defined(glNormalStream3dATI)
			return glNormalStream3dATI(static_cast<GLenum>(stream), nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3dATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3dvATI(enums::VertexStreamATI stream, const GLdouble* coords) {
		#if defined(glNormalStream3dvATI)
			return glNormalStream3dvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3dvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3fATI(enums::VertexStreamATI stream, GLfloat nx, GLfloat ny, GLfloat nz) {
		#if defined(glNormalStream3fATI)
			return glNormalStream3fATI(static_cast<GLenum>(stream), nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3fATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3fvATI(enums::VertexStreamATI stream, const GLfloat* coords) {
		#if defined(glNormalStream3fvATI)
			return glNormalStream3fvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3fvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3iATI(enums::VertexStreamATI stream, GLint nx, GLint ny, GLint nz) {
		#if defined(glNormalStream3iATI)
			return glNormalStream3iATI(static_cast<GLenum>(stream), nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3iATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3ivATI(enums::VertexStreamATI stream, const GLint* coords) {
		#if defined(glNormalStream3ivATI)
			return glNormalStream3ivATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3ivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3sATI(enums::VertexStreamATI stream, GLshort nx, GLshort ny, GLshort nz) {
		#if defined(glNormalStream3sATI)
			return glNormalStream3sATI(static_cast<GLenum>(stream), nx, ny, nz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3sATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void normalStream3svATI(enums::VertexStreamATI stream, const GLshort* coords) {
		#if defined(glNormalStream3svATI)
			return glNormalStream3svATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glNormalStream3svATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void objectLabel(enums::ObjectIdentifier identifier, GLuint name, GLsizei length, const GLchar* label) {
		#if defined(glObjectLabel)
			return glObjectLabel(static_cast<GLenum>(identifier), name, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glObjectLabel" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void objectLabelKHR(enums::ObjectIdentifier identifier, GLuint name, GLsizei length, const GLchar* label) {
		#if defined(glObjectLabelKHR)
			return glObjectLabelKHR(static_cast<GLenum>(identifier), name, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glObjectLabelKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void objectPtrLabel(const void * ptr, GLsizei length, const GLchar* label) {
		#if defined(glObjectPtrLabel)
			return glObjectPtrLabel(ptr, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glObjectPtrLabel" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void objectPtrLabelKHR(const void * ptr, GLsizei length, const GLchar* label) {
		#if defined(glObjectPtrLabelKHR)
			return glObjectPtrLabelKHR(ptr, length, label);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glObjectPtrLabelKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLenum objectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
		#if defined(glObjectPurgeableAPPLE)
			return glObjectPurgeableAPPLE(objectType, name, option);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glObjectPurgeableAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum objectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option) {
		#if defined(glObjectUnpurgeableAPPLE)
			return glObjectUnpurgeableAPPLE(objectType, name, option);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glObjectUnpurgeableAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void ortho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) {
		#if defined(glOrtho)
			return glOrtho(left, right, bottom, top, zNear, zFar);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glOrtho" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void orthof(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
		#if defined(glOrthof)
			return glOrthof(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glOrthof" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void orthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f) {
		#if defined(glOrthofOES)
			return glOrthofOES(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glOrthofOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void orthox(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) {
		#if defined(glOrthox)
			return glOrthox(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glOrthox" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void orthoxOES(GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f) {
		#if defined(glOrthoxOES)
			return glOrthoxOES(l, r, b, t, n, f);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glOrthoxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pNTrianglesfATI(enums::PNTrianglesPNameATI pname, GLfloat param) {
		#if defined(glPNTrianglesfATI)
			return glPNTrianglesfATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPNTrianglesfATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pNTrianglesiATI(enums::PNTrianglesPNameATI pname, GLint param) {
		#if defined(glPNTrianglesiATI)
			return glPNTrianglesiATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPNTrianglesiATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void passTexCoordATI(GLuint dst, GLuint coord, enums::SwizzleOpATI swizzle) {
		#if defined(glPassTexCoordATI)
			return glPassTexCoordATI(dst, coord, static_cast<GLenum>(swizzle));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPassTexCoordATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void passThrough(GLfloat token) {
		#if defined(glPassThrough)
			return glPassThrough(token);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPassThrough" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void passThroughxOES(GLfixed token) {
		#if defined(glPassThroughxOES)
			return glPassThroughxOES(token);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPassThroughxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void patchParameterfv(enums::PatchParameterName pname, const GLfloat* values) {
		#if defined(glPatchParameterfv)
			return glPatchParameterfv(static_cast<GLenum>(pname), values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPatchParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void patchParameteri(enums::PatchParameterName pname, GLint value) {
		#if defined(glPatchParameteri)
			return glPatchParameteri(static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPatchParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void patchParameteriEXT(enums::PatchParameterName pname, GLint value) {
		#if defined(glPatchParameteriEXT)
			return glPatchParameteriEXT(static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPatchParameteriEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void patchParameteriOES(enums::PatchParameterName pname, GLint value) {
		#if defined(glPatchParameteriOES)
			return glPatchParameteriOES(static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPatchParameteriOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathColorGenNV(enums::PathColor color, enums::PathGenMode genMode, enums::PathColorFormat colorFormat, const GLfloat* coeffs) {
		#if defined(glPathColorGenNV)
			return glPathColorGenNV(static_cast<GLenum>(color), static_cast<GLenum>(genMode), static_cast<GLenum>(colorFormat), coeffs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathColorGenNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, enums::PathCoordType coordType, const void * coords) {
		#if defined(glPathCommandsNV)
			return glPathCommandsNV(path, numCommands, commands, numCoords, static_cast<GLenum>(coordType), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathCommandsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathCoordsNV(GLuint path, GLsizei numCoords, enums::PathCoordType coordType, const void * coords) {
		#if defined(glPathCoordsNV)
			return glPathCoordsNV(path, numCoords, static_cast<GLenum>(coordType), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathCoordsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathCoverDepthFuncNV(enums::DepthFunction func) {
		#if defined(glPathCoverDepthFuncNV)
			return glPathCoverDepthFuncNV(static_cast<GLenum>(func));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathCoverDepthFuncNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat* dashArray) {
		#if defined(glPathDashArrayNV)
			return glPathDashArrayNV(path, dashCount, dashArray);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathDashArrayNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathFogGenNV(enums::PathGenMode genMode) {
		#if defined(glPathFogGenNV)
			return glPathFogGenNV(static_cast<GLenum>(genMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathFogGenNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLenum pathGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
		#if defined(glPathGlyphIndexArrayNV)
			return glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathGlyphIndexArrayNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLenum pathGlyphIndexRangeNV(GLenum fontTarget, const void * fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint* baseAndCount) {
		#if defined(glPathGlyphIndexRangeNV)
			return glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathGlyphIndexRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void pathGlyphRangeNV(GLuint firstPathName, enums::PathFontTarget fontTarget, const void * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, enums::PathHandleMissingGlyphs handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
		#if defined(glPathGlyphRangeNV)
			return glPathGlyphRangeNV(firstPathName, static_cast<GLenum>(fontTarget), fontName, fontStyle, firstGlyph, numGlyphs, static_cast<GLenum>(handleMissingGlyphs), pathParameterTemplate, emScale);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathGlyphRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathGlyphsNV(GLuint firstPathName, enums::PathFontTarget fontTarget, const void * fontName, GLbitfield fontStyle, GLsizei numGlyphs, enums::PathElementType type, const void * charcodes, enums::PathHandleMissingGlyphs handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
		#if defined(glPathGlyphsNV)
			return glPathGlyphsNV(firstPathName, static_cast<GLenum>(fontTarget), fontName, fontStyle, numGlyphs, static_cast<GLenum>(type), charcodes, static_cast<GLenum>(handleMissingGlyphs), pathParameterTemplate, emScale);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathGlyphsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLenum pathMemoryGlyphIndexArrayNV(GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void * fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale) {
		#if defined(glPathMemoryGlyphIndexArrayNV)
			return glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathMemoryGlyphIndexArrayNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void pathParameterfNV(GLuint path, enums::PathParameter pname, GLfloat value) {
		#if defined(glPathParameterfNV)
			return glPathParameterfNV(path, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathParameterfNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathParameterfvNV(GLuint path, enums::PathParameter pname, const GLfloat* value) {
		#if defined(glPathParameterfvNV)
			return glPathParameterfvNV(path, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathParameteriNV(GLuint path, enums::PathParameter pname, GLint value) {
		#if defined(glPathParameteriNV)
			return glPathParameteriNV(path, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathParameteriNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathParameterivNV(GLuint path, enums::PathParameter pname, const GLint* value) {
		#if defined(glPathParameterivNV)
			return glPathParameterivNV(path, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathStencilDepthOffsetNV(GLfloat factor, GLfloat units) {
		#if defined(glPathStencilDepthOffsetNV)
			return glPathStencilDepthOffsetNV(factor, units);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathStencilDepthOffsetNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathStencilFuncNV(enums::StencilFunction func, GLint ref, GLuint mask) {
		#if defined(glPathStencilFuncNV)
			return glPathStencilFuncNV(static_cast<GLenum>(func), ref, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathStencilFuncNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathStringNV(GLuint path, enums::PathStringFormat format, GLsizei length, const void * pathString) {
		#if defined(glPathStringNV)
			return glPathStringNV(path, static_cast<GLenum>(format), length, pathString);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathStringNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, enums::PathCoordType coordType, const void * coords) {
		#if defined(glPathSubCommandsNV)
			return glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, static_cast<GLenum>(coordType), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathSubCommandsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, enums::PathCoordType coordType, const void * coords) {
		#if defined(glPathSubCoordsNV)
			return glPathSubCoordsNV(path, coordStart, numCoords, static_cast<GLenum>(coordType), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathSubCoordsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pathTexGenNV(enums::PathColor texCoordSet, enums::PathGenMode genMode, GLint components, const GLfloat* coeffs) {
		#if defined(glPathTexGenNV)
			return glPathTexGenNV(static_cast<GLenum>(texCoordSet), static_cast<GLenum>(genMode), components, coeffs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPathTexGenNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pauseTransformFeedback() {
		#if defined(glPauseTransformFeedback)
			return glPauseTransformFeedback();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPauseTransformFeedback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pauseTransformFeedbackNV() {
		#if defined(glPauseTransformFeedbackNV)
			return glPauseTransformFeedbackNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPauseTransformFeedbackNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelDataRangeNV(enums::PixelDataRangeTargetNV target, GLsizei length, const void * pointer) {
		#if defined(glPixelDataRangeNV)
			return glPixelDataRangeNV(static_cast<GLenum>(target), length, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelDataRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelMapfv(enums::PixelMap map, GLsizei mapsize, const GLfloat* values) {
		#if defined(glPixelMapfv)
			return glPixelMapfv(static_cast<GLenum>(map), mapsize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelMapfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelMapuiv(enums::PixelMap map, GLsizei mapsize, const GLuint* values) {
		#if defined(glPixelMapuiv)
			return glPixelMapuiv(static_cast<GLenum>(map), mapsize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelMapuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelMapusv(enums::PixelMap map, GLsizei mapsize, const GLushort* values) {
		#if defined(glPixelMapusv)
			return glPixelMapusv(static_cast<GLenum>(map), mapsize, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelMapusv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelMapx(enums::PixelMap map, GLint size, const GLfixed* values) {
		#if defined(glPixelMapx)
			return glPixelMapx(static_cast<GLenum>(map), size, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelMapx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelStoref(enums::PixelStoreParameter pname, GLfloat param) {
		#if defined(glPixelStoref)
			return glPixelStoref(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelStoref" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelStorei(enums::PixelStoreParameter pname, GLint param) {
		#if defined(glPixelStorei)
			return glPixelStorei(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelStorei" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelStorex(enums::PixelStoreParameter pname, GLfixed param) {
		#if defined(glPixelStorex)
			return glPixelStorex(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelStorex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTexGenParameterfSGIS(enums::PixelTexGenParameterNameSGIS pname, GLfloat param) {
		#if defined(glPixelTexGenParameterfSGIS)
			return glPixelTexGenParameterfSGIS(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTexGenParameterfSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTexGenParameterfvSGIS(enums::PixelTexGenParameterNameSGIS pname, const GLfloat* params) {
		#if defined(glPixelTexGenParameterfvSGIS)
			return glPixelTexGenParameterfvSGIS(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTexGenParameterfvSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTexGenParameteriSGIS(enums::PixelTexGenParameterNameSGIS pname, GLint param) {
		#if defined(glPixelTexGenParameteriSGIS)
			return glPixelTexGenParameteriSGIS(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTexGenParameteriSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTexGenParameterivSGIS(enums::PixelTexGenParameterNameSGIS pname, const GLint* params) {
		#if defined(glPixelTexGenParameterivSGIS)
			return glPixelTexGenParameterivSGIS(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTexGenParameterivSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTexGenSGIX(enums::PixelTexGenModeSGIX mode) {
		#if defined(glPixelTexGenSGIX)
			return glPixelTexGenSGIX(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTexGenSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTransferf(enums::PixelTransferParameter pname, GLfloat param) {
		#if defined(glPixelTransferf)
			return glPixelTransferf(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTransferf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTransferi(enums::PixelTransferParameter pname, GLint param) {
		#if defined(glPixelTransferi)
			return glPixelTransferi(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTransferi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTransferxOES(enums::PixelTransferParameter pname, GLfixed param) {
		#if defined(glPixelTransferxOES)
			return glPixelTransferxOES(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTransferxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTransformParameterfEXT(enums::PixelTransformTargetEXT target, enums::PixelTransformPNameEXT pname, GLfloat param) {
		#if defined(glPixelTransformParameterfEXT)
			return glPixelTransformParameterfEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTransformParameterfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTransformParameterfvEXT(enums::PixelTransformTargetEXT target, enums::PixelTransformPNameEXT pname, const GLfloat* params) {
		#if defined(glPixelTransformParameterfvEXT)
			return glPixelTransformParameterfvEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTransformParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTransformParameteriEXT(enums::PixelTransformTargetEXT target, enums::PixelTransformPNameEXT pname, GLint param) {
		#if defined(glPixelTransformParameteriEXT)
			return glPixelTransformParameteriEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTransformParameteriEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelTransformParameterivEXT(enums::PixelTransformTargetEXT target, enums::PixelTransformPNameEXT pname, const GLint* params) {
		#if defined(glPixelTransformParameterivEXT)
			return glPixelTransformParameterivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelTransformParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelZoom(GLfloat xfactor, GLfloat yfactor) {
		#if defined(glPixelZoom)
			return glPixelZoom(xfactor, yfactor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelZoom" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pixelZoomxOES(GLfixed xfactor, GLfixed yfactor) {
		#if defined(glPixelZoomxOES)
			return glPixelZoomxOES(xfactor, yfactor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPixelZoomxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean pointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat* y, GLfloat* tangentX, GLfloat* tangentY) {
		#if defined(glPointAlongPathNV)
			return glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointAlongPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void pointParameterf(enums::PointParameterNameARB pname, GLfloat param) {
		#if defined(glPointParameterf)
			return glPointParameterf(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterfARB(enums::PointParameterNameARB pname, GLfloat param) {
		#if defined(glPointParameterfARB)
			return glPointParameterfARB(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterfARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterfEXT(enums::PointParameterNameARB pname, GLfloat param) {
		#if defined(glPointParameterfEXT)
			return glPointParameterfEXT(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterfSGIS(enums::PointParameterNameARB pname, GLfloat param) {
		#if defined(glPointParameterfSGIS)
			return glPointParameterfSGIS(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterfSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterfv(enums::PointParameterNameARB pname, const GLfloat* params) {
		#if defined(glPointParameterfv)
			return glPointParameterfv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterfvARB(enums::PointParameterNameARB pname, const GLfloat* params) {
		#if defined(glPointParameterfvARB)
			return glPointParameterfvARB(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterfvEXT(enums::PointParameterNameARB pname, const GLfloat* params) {
		#if defined(glPointParameterfvEXT)
			return glPointParameterfvEXT(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterfvSGIS(enums::PointParameterNameARB pname, const GLfloat* params) {
		#if defined(glPointParameterfvSGIS)
			return glPointParameterfvSGIS(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterfvSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameteri(enums::PointParameterNameARB pname, GLint param) {
		#if defined(glPointParameteri)
			return glPointParameteri(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameteriNV(enums::PointParameterNameARB pname, GLint param) {
		#if defined(glPointParameteriNV)
			return glPointParameteriNV(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameteriNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameteriv(enums::PointParameterNameARB pname, const GLint* params) {
		#if defined(glPointParameteriv)
			return glPointParameteriv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterivNV(enums::PointParameterNameARB pname, const GLint* params) {
		#if defined(glPointParameterivNV)
			return glPointParameterivNV(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterx(enums::PointParameterNameARB pname, GLfixed param) {
		#if defined(glPointParameterx)
			return glPointParameterx(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterxOES(enums::PointParameterNameARB pname, GLfixed param) {
		#if defined(glPointParameterxOES)
			return glPointParameterxOES(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterxv(enums::PointParameterNameARB pname, const GLfixed* params) {
		#if defined(glPointParameterxv)
			return glPointParameterxv(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointParameterxvOES(enums::PointParameterNameARB pname, const GLfixed* params) {
		#if defined(glPointParameterxvOES)
			return glPointParameterxvOES(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointParameterxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointSize(GLfloat size) {
		#if defined(glPointSize)
			return glPointSize(size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointSize" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointSizePointerOES(GLenum type, GLsizei stride, const void * pointer) {
		#if defined(glPointSizePointerOES)
			return glPointSizePointerOES(type, stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointSizePointerOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointSizex(GLfixed size) {
		#if defined(glPointSizex)
			return glPointSizex(size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointSizex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pointSizexOES(GLfixed size) {
		#if defined(glPointSizexOES)
			return glPointSizexOES(size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPointSizexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint pollAsyncSGIX(GLuint* markerp) {
		#if defined(glPollAsyncSGIX)
			return glPollAsyncSGIX(markerp);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPollAsyncSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLint pollInstrumentsSGIX(GLint* marker_p) {
		#if defined(glPollInstrumentsSGIX)
			return glPollInstrumentsSGIX(marker_p);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPollInstrumentsSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void polygonMode(enums::TriangleFace face, enums::PolygonMode mode) {
		#if defined(glPolygonMode)
			return glPolygonMode(static_cast<GLenum>(face), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonMode" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonModeNV(enums::TriangleFace face, enums::PolygonMode mode) {
		#if defined(glPolygonModeNV)
			return glPolygonModeNV(static_cast<GLenum>(face), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonModeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonOffset(GLfloat factor, GLfloat units) {
		#if defined(glPolygonOffset)
			return glPolygonOffset(factor, units);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonOffset" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp) {
		#if defined(glPolygonOffsetClamp)
			return glPolygonOffsetClamp(factor, units, clamp);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonOffsetClamp" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonOffsetClampEXT(GLfloat factor, GLfloat units, GLfloat clamp) {
		#if defined(glPolygonOffsetClampEXT)
			return glPolygonOffsetClampEXT(factor, units, clamp);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonOffsetClampEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonOffsetEXT(GLfloat factor, GLfloat bias) {
		#if defined(glPolygonOffsetEXT)
			return glPolygonOffsetEXT(factor, bias);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonOffsetx(GLfixed factor, GLfixed units) {
		#if defined(glPolygonOffsetx)
			return glPolygonOffsetx(factor, units);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonOffsetx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonOffsetxOES(GLfixed factor, GLfixed units) {
		#if defined(glPolygonOffsetxOES)
			return glPolygonOffsetxOES(factor, units);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonOffsetxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void polygonStipple(const GLubyte* mask) {
		#if defined(glPolygonStipple)
			return glPolygonStipple(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPolygonStipple" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void popAttrib() {
		#if defined(glPopAttrib)
			return glPopAttrib();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPopAttrib" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void popClientAttrib() {
		#if defined(glPopClientAttrib)
			return glPopClientAttrib();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPopClientAttrib" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void popDebugGroup() {
		#if defined(glPopDebugGroup)
			return glPopDebugGroup();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPopDebugGroup" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void popDebugGroupKHR() {
		#if defined(glPopDebugGroupKHR)
			return glPopDebugGroupKHR();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPopDebugGroupKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void popGroupMarkerEXT() {
		#if defined(glPopGroupMarkerEXT)
			return glPopGroupMarkerEXT();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPopGroupMarkerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void popMatrix() {
		#if defined(glPopMatrix)
			return glPopMatrix();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPopMatrix" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void popName() {
		#if defined(glPopName)
			return glPopName();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPopName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void presentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3) {
		#if defined(glPresentFrameDualFillNV)
			return glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPresentFrameDualFillNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void presentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1) {
		#if defined(glPresentFrameKeyedNV)
			return glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPresentFrameKeyedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void primitiveBoundingBox(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
		#if defined(glPrimitiveBoundingBox)
			return glPrimitiveBoundingBox(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrimitiveBoundingBox" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void primitiveBoundingBoxARB(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
		#if defined(glPrimitiveBoundingBoxARB)
			return glPrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrimitiveBoundingBoxARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void primitiveBoundingBoxEXT(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
		#if defined(glPrimitiveBoundingBoxEXT)
			return glPrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrimitiveBoundingBoxEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void primitiveBoundingBoxOES(GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW) {
		#if defined(glPrimitiveBoundingBoxOES)
			return glPrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrimitiveBoundingBoxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void primitiveRestartIndex(GLuint index) {
		#if defined(glPrimitiveRestartIndex)
			return glPrimitiveRestartIndex(index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrimitiveRestartIndex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void primitiveRestartIndexNV(GLuint index) {
		#if defined(glPrimitiveRestartIndexNV)
			return glPrimitiveRestartIndexNV(index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrimitiveRestartIndexNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void primitiveRestartNV() {
		#if defined(glPrimitiveRestartNV)
			return glPrimitiveRestartNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrimitiveRestartNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void prioritizeTextures(GLsizei n, const GLuint* textures, const GLfloat* priorities) {
		#if defined(glPrioritizeTextures)
			return glPrioritizeTextures(n, textures, priorities);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrioritizeTextures" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void prioritizeTexturesEXT(GLsizei n, const GLuint* textures, const GLclampf* priorities) {
		#if defined(glPrioritizeTexturesEXT)
			return glPrioritizeTexturesEXT(n, textures, priorities);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrioritizeTexturesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void prioritizeTexturesxOES(GLsizei n, const GLuint* textures, const GLfixed* priorities) {
		#if defined(glPrioritizeTexturesxOES)
			return glPrioritizeTexturesxOES(n, textures, priorities);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPrioritizeTexturesxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programBinary(GLuint program, GLenum binaryFormat, const void * binary, GLsizei length) {
		#if defined(glProgramBinary)
			return glProgramBinary(program, binaryFormat, binary, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramBinary" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programBinaryOES(GLuint program, GLenum binaryFormat, const void * binary, GLint length) {
		#if defined(glProgramBinaryOES)
			return glProgramBinaryOES(program, binaryFormat, binary, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramBinaryOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programBufferParametersIivNV(enums::ProgramTarget target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint* params) {
		#if defined(glProgramBufferParametersIivNV)
			return glProgramBufferParametersIivNV(static_cast<GLenum>(target), bindingIndex, wordIndex, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramBufferParametersIivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programBufferParametersIuivNV(enums::ProgramTarget target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint* params) {
		#if defined(glProgramBufferParametersIuivNV)
			return glProgramBufferParametersIuivNV(static_cast<GLenum>(target), bindingIndex, wordIndex, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramBufferParametersIuivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programBufferParametersfvNV(enums::ProgramTarget target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat* params) {
		#if defined(glProgramBufferParametersfvNV)
			return glProgramBufferParametersfvNV(static_cast<GLenum>(target), bindingIndex, wordIndex, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramBufferParametersfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameter4dARB(enums::ProgramTarget target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glProgramEnvParameter4dARB)
			return glProgramEnvParameter4dARB(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameter4dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameter4dvARB(enums::ProgramTarget target, GLuint index, const GLdouble* params) {
		#if defined(glProgramEnvParameter4dvARB)
			return glProgramEnvParameter4dvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameter4dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameter4fARB(enums::ProgramTarget target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glProgramEnvParameter4fARB)
			return glProgramEnvParameter4fARB(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameter4fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameter4fvARB(enums::ProgramTarget target, GLuint index, const GLfloat* params) {
		#if defined(glProgramEnvParameter4fvARB)
			return glProgramEnvParameter4fvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameter4fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameterI4iNV(enums::ProgramTarget target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
		#if defined(glProgramEnvParameterI4iNV)
			return glProgramEnvParameterI4iNV(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameterI4iNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameterI4ivNV(enums::ProgramTarget target, GLuint index, const GLint* params) {
		#if defined(glProgramEnvParameterI4ivNV)
			return glProgramEnvParameterI4ivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameterI4ivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameterI4uiNV(enums::ProgramTarget target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
		#if defined(glProgramEnvParameterI4uiNV)
			return glProgramEnvParameterI4uiNV(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameterI4uiNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameterI4uivNV(enums::ProgramTarget target, GLuint index, const GLuint* params) {
		#if defined(glProgramEnvParameterI4uivNV)
			return glProgramEnvParameterI4uivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameterI4uivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParameters4fvEXT(enums::ProgramTarget target, GLuint index, GLsizei count, const GLfloat* params) {
		#if defined(glProgramEnvParameters4fvEXT)
			return glProgramEnvParameters4fvEXT(static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParameters4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParametersI4ivNV(enums::ProgramTarget target, GLuint index, GLsizei count, const GLint* params) {
		#if defined(glProgramEnvParametersI4ivNV)
			return glProgramEnvParametersI4ivNV(static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParametersI4ivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programEnvParametersI4uivNV(enums::ProgramTarget target, GLuint index, GLsizei count, const GLuint* params) {
		#if defined(glProgramEnvParametersI4uivNV)
			return glProgramEnvParametersI4uivNV(static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramEnvParametersI4uivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameter4dARB(enums::ProgramTarget target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glProgramLocalParameter4dARB)
			return glProgramLocalParameter4dARB(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameter4dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameter4dvARB(enums::ProgramTarget target, GLuint index, const GLdouble* params) {
		#if defined(glProgramLocalParameter4dvARB)
			return glProgramLocalParameter4dvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameter4dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameter4fARB(enums::ProgramTarget target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glProgramLocalParameter4fARB)
			return glProgramLocalParameter4fARB(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameter4fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameter4fvARB(enums::ProgramTarget target, GLuint index, const GLfloat* params) {
		#if defined(glProgramLocalParameter4fvARB)
			return glProgramLocalParameter4fvARB(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameter4fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameterI4iNV(enums::ProgramTarget target, GLuint index, GLint x, GLint y, GLint z, GLint w) {
		#if defined(glProgramLocalParameterI4iNV)
			return glProgramLocalParameterI4iNV(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameterI4iNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameterI4ivNV(enums::ProgramTarget target, GLuint index, const GLint* params) {
		#if defined(glProgramLocalParameterI4ivNV)
			return glProgramLocalParameterI4ivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameterI4ivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameterI4uiNV(enums::ProgramTarget target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
		#if defined(glProgramLocalParameterI4uiNV)
			return glProgramLocalParameterI4uiNV(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameterI4uiNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameterI4uivNV(enums::ProgramTarget target, GLuint index, const GLuint* params) {
		#if defined(glProgramLocalParameterI4uivNV)
			return glProgramLocalParameterI4uivNV(static_cast<GLenum>(target), index, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameterI4uivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParameters4fvEXT(enums::ProgramTarget target, GLuint index, GLsizei count, const GLfloat* params) {
		#if defined(glProgramLocalParameters4fvEXT)
			return glProgramLocalParameters4fvEXT(static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParameters4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParametersI4ivNV(enums::ProgramTarget target, GLuint index, GLsizei count, const GLint* params) {
		#if defined(glProgramLocalParametersI4ivNV)
			return glProgramLocalParametersI4ivNV(static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParametersI4ivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programLocalParametersI4uivNV(enums::ProgramTarget target, GLuint index, GLsizei count, const GLuint* params) {
		#if defined(glProgramLocalParametersI4uivNV)
			return glProgramLocalParametersI4uivNV(static_cast<GLenum>(target), index, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramLocalParametersI4uivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glProgramNamedParameter4dNV)
			return glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramNamedParameter4dNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte* name, const GLdouble* v) {
		#if defined(glProgramNamedParameter4dvNV)
			return glProgramNamedParameter4dvNV(id, len, name, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramNamedParameter4dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glProgramNamedParameter4fNV)
			return glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramNamedParameter4fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte* name, const GLfloat* v) {
		#if defined(glProgramNamedParameter4fvNV)
			return glProgramNamedParameter4fvNV(id, len, name, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramNamedParameter4fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameter4dNV(enums::VertexAttribEnumNV target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glProgramParameter4dNV)
			return glProgramParameter4dNV(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameter4dNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameter4dvNV(enums::VertexAttribEnumNV target, GLuint index, const GLdouble* v) {
		#if defined(glProgramParameter4dvNV)
			return glProgramParameter4dvNV(static_cast<GLenum>(target), index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameter4dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameter4fNV(enums::VertexAttribEnumNV target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glProgramParameter4fNV)
			return glProgramParameter4fNV(static_cast<GLenum>(target), index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameter4fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameter4fvNV(enums::VertexAttribEnumNV target, GLuint index, const GLfloat* v) {
		#if defined(glProgramParameter4fvNV)
			return glProgramParameter4fvNV(static_cast<GLenum>(target), index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameter4fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameteri(GLuint program, enums::ProgramParameterPName pname, GLint value) {
		#if defined(glProgramParameteri)
			return glProgramParameteri(program, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameteriARB(GLuint program, enums::ProgramParameterPName pname, GLint value) {
		#if defined(glProgramParameteriARB)
			return glProgramParameteriARB(program, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameteriARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameteriEXT(GLuint program, enums::ProgramParameterPName pname, GLint value) {
		#if defined(glProgramParameteriEXT)
			return glProgramParameteriEXT(program, static_cast<GLenum>(pname), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameteriEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameters4dvNV(enums::VertexAttribEnumNV target, GLuint index, GLsizei count, const GLdouble* v) {
		#if defined(glProgramParameters4dvNV)
			return glProgramParameters4dvNV(static_cast<GLenum>(target), index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameters4dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programParameters4fvNV(enums::VertexAttribEnumNV target, GLuint index, GLsizei count, const GLfloat* v) {
		#if defined(glProgramParameters4fvNV)
			return glProgramParameters4fvNV(static_cast<GLenum>(target), index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramParameters4fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programPathFragmentInputGenNV(GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs) {
		#if defined(glProgramPathFragmentInputGenNV)
			return glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramPathFragmentInputGenNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programStringARB(enums::ProgramTarget target, enums::ProgramFormat format, GLsizei len, const void * string) {
		#if defined(glProgramStringARB)
			return glProgramStringARB(static_cast<GLenum>(target), static_cast<GLenum>(format), len, string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramStringARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint* params) {
		#if defined(glProgramSubroutineParametersuivNV)
			return glProgramSubroutineParametersuivNV(target, count, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramSubroutineParametersuivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1d(GLuint program, GLint location, GLdouble v0) {
		#if defined(glProgramUniform1d)
			return glProgramUniform1d(program, location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1dEXT(GLuint program, GLint location, GLdouble x) {
		#if defined(glProgramUniform1dEXT)
			return glProgramUniform1dEXT(program, location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform1dv)
			return glProgramUniform1dv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform1dvEXT)
			return glProgramUniform1dvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1f(GLuint program, GLint location, GLfloat v0) {
		#if defined(glProgramUniform1f)
			return glProgramUniform1f(program, location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1fEXT(GLuint program, GLint location, GLfloat v0) {
		#if defined(glProgramUniform1fEXT)
			return glProgramUniform1fEXT(program, location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform1fv)
			return glProgramUniform1fv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform1fvEXT)
			return glProgramUniform1fvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1i(GLuint program, GLint location, GLint v0) {
		#if defined(glProgramUniform1i)
			return glProgramUniform1i(program, location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1i64ARB(GLuint program, GLint location, GLint64 x) {
		#if defined(glProgramUniform1i64ARB)
			return glProgramUniform1i64ARB(program, location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1i64NV(GLuint program, GLint location, GLint64EXT x) {
		#if defined(glProgramUniform1i64NV)
			return glProgramUniform1i64NV(program, location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) {
		#if defined(glProgramUniform1i64vARB)
			return glProgramUniform1i64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glProgramUniform1i64vNV)
			return glProgramUniform1i64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1iEXT(GLuint program, GLint location, GLint v0) {
		#if defined(glProgramUniform1iEXT)
			return glProgramUniform1iEXT(program, location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1iv(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform1iv)
			return glProgramUniform1iv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform1ivEXT)
			return glProgramUniform1ivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1ui(GLuint program, GLint location, GLuint v0) {
		#if defined(glProgramUniform1ui)
			return glProgramUniform1ui(program, location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1ui64ARB(GLuint program, GLint location, GLuint64 x) {
		#if defined(glProgramUniform1ui64ARB)
			return glProgramUniform1ui64ARB(program, location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x) {
		#if defined(glProgramUniform1ui64NV)
			return glProgramUniform1ui64NV(program, location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glProgramUniform1ui64vARB)
			return glProgramUniform1ui64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glProgramUniform1ui64vNV)
			return glProgramUniform1ui64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1uiEXT(GLuint program, GLint location, GLuint v0) {
		#if defined(glProgramUniform1uiEXT)
			return glProgramUniform1uiEXT(program, location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform1uiv)
			return glProgramUniform1uiv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform1uivEXT)
			return glProgramUniform1uivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform1uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) {
		#if defined(glProgramUniform2d)
			return glProgramUniform2d(program, location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y) {
		#if defined(glProgramUniform2dEXT)
			return glProgramUniform2dEXT(program, location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform2dv)
			return glProgramUniform2dv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform2dvEXT)
			return glProgramUniform2dvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
		#if defined(glProgramUniform2f)
			return glProgramUniform2f(program, location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
		#if defined(glProgramUniform2fEXT)
			return glProgramUniform2fEXT(program, location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform2fv)
			return glProgramUniform2fv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform2fvEXT)
			return glProgramUniform2fvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2i(GLuint program, GLint location, GLint v0, GLint v1) {
		#if defined(glProgramUniform2i)
			return glProgramUniform2i(program, location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y) {
		#if defined(glProgramUniform2i64ARB)
			return glProgramUniform2i64ARB(program, location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y) {
		#if defined(glProgramUniform2i64NV)
			return glProgramUniform2i64NV(program, location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) {
		#if defined(glProgramUniform2i64vARB)
			return glProgramUniform2i64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glProgramUniform2i64vNV)
			return glProgramUniform2i64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1) {
		#if defined(glProgramUniform2iEXT)
			return glProgramUniform2iEXT(program, location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2iv(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform2iv)
			return glProgramUniform2iv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform2ivEXT)
			return glProgramUniform2ivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1) {
		#if defined(glProgramUniform2ui)
			return glProgramUniform2ui(program, location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y) {
		#if defined(glProgramUniform2ui64ARB)
			return glProgramUniform2ui64ARB(program, location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y) {
		#if defined(glProgramUniform2ui64NV)
			return glProgramUniform2ui64NV(program, location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glProgramUniform2ui64vARB)
			return glProgramUniform2ui64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glProgramUniform2ui64vNV)
			return glProgramUniform2ui64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1) {
		#if defined(glProgramUniform2uiEXT)
			return glProgramUniform2uiEXT(program, location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform2uiv)
			return glProgramUniform2uiv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform2uivEXT)
			return glProgramUniform2uivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform2uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) {
		#if defined(glProgramUniform3d)
			return glProgramUniform3d(program, location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glProgramUniform3dEXT)
			return glProgramUniform3dEXT(program, location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform3dv)
			return glProgramUniform3dv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform3dvEXT)
			return glProgramUniform3dvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
		#if defined(glProgramUniform3f)
			return glProgramUniform3f(program, location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
		#if defined(glProgramUniform3fEXT)
			return glProgramUniform3fEXT(program, location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform3fv)
			return glProgramUniform3fv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform3fvEXT)
			return glProgramUniform3fvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
		#if defined(glProgramUniform3i)
			return glProgramUniform3i(program, location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z) {
		#if defined(glProgramUniform3i64ARB)
			return glProgramUniform3i64ARB(program, location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
		#if defined(glProgramUniform3i64NV)
			return glProgramUniform3i64NV(program, location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) {
		#if defined(glProgramUniform3i64vARB)
			return glProgramUniform3i64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glProgramUniform3i64vNV)
			return glProgramUniform3i64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
		#if defined(glProgramUniform3iEXT)
			return glProgramUniform3iEXT(program, location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3iv(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform3iv)
			return glProgramUniform3iv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform3ivEXT)
			return glProgramUniform3ivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
		#if defined(glProgramUniform3ui)
			return glProgramUniform3ui(program, location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z) {
		#if defined(glProgramUniform3ui64ARB)
			return glProgramUniform3ui64ARB(program, location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
		#if defined(glProgramUniform3ui64NV)
			return glProgramUniform3ui64NV(program, location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glProgramUniform3ui64vARB)
			return glProgramUniform3ui64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glProgramUniform3ui64vNV)
			return glProgramUniform3ui64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
		#if defined(glProgramUniform3uiEXT)
			return glProgramUniform3uiEXT(program, location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform3uiv)
			return glProgramUniform3uiv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform3uivEXT)
			return glProgramUniform3uivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform3uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) {
		#if defined(glProgramUniform4d)
			return glProgramUniform4d(program, location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glProgramUniform4dEXT)
			return glProgramUniform4dEXT(program, location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform4dv)
			return glProgramUniform4dv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glProgramUniform4dvEXT)
			return glProgramUniform4dvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
		#if defined(glProgramUniform4f)
			return glProgramUniform4f(program, location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
		#if defined(glProgramUniform4fEXT)
			return glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform4fv)
			return glProgramUniform4fv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glProgramUniform4fvEXT)
			return glProgramUniform4fvEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
		#if defined(glProgramUniform4i)
			return glProgramUniform4i(program, location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4i64ARB(GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) {
		#if defined(glProgramUniform4i64ARB)
			return glProgramUniform4i64ARB(program, location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
		#if defined(glProgramUniform4i64NV)
			return glProgramUniform4i64NV(program, location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4i64vARB(GLuint program, GLint location, GLsizei count, const GLint64* value) {
		#if defined(glProgramUniform4i64vARB)
			return glProgramUniform4i64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glProgramUniform4i64vNV)
			return glProgramUniform4i64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
		#if defined(glProgramUniform4iEXT)
			return glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4iv(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform4iv)
			return glProgramUniform4iv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint* value) {
		#if defined(glProgramUniform4ivEXT)
			return glProgramUniform4ivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
		#if defined(glProgramUniform4ui)
			return glProgramUniform4ui(program, location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4ui64ARB(GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) {
		#if defined(glProgramUniform4ui64ARB)
			return glProgramUniform4ui64ARB(program, location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
		#if defined(glProgramUniform4ui64NV)
			return glProgramUniform4ui64NV(program, location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4ui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glProgramUniform4ui64vARB)
			return glProgramUniform4ui64vARB(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glProgramUniform4ui64vNV)
			return glProgramUniform4ui64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
		#if defined(glProgramUniform4uiEXT)
			return glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform4uiv)
			return glProgramUniform4uiv(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint* value) {
		#if defined(glProgramUniform4uivEXT)
			return glProgramUniform4uivEXT(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniform4uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value) {
		#if defined(glProgramUniformHandleui64ARB)
			return glProgramUniformHandleui64ARB(program, location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformHandleui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformHandleui64IMG(GLuint program, GLint location, GLuint64 value) {
		#if defined(glProgramUniformHandleui64IMG)
			return glProgramUniformHandleui64IMG(program, location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformHandleui64IMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformHandleui64NV(GLuint program, GLint location, GLuint64 value) {
		#if defined(glProgramUniformHandleui64NV)
			return glProgramUniformHandleui64NV(program, location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformHandleui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64* values) {
		#if defined(glProgramUniformHandleui64vARB)
			return glProgramUniformHandleui64vARB(program, location, count, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformHandleui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformHandleui64vIMG(GLuint program, GLint location, GLsizei count, const GLuint64* values) {
		#if defined(glProgramUniformHandleui64vIMG)
			return glProgramUniformHandleui64vIMG(program, location, count, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformHandleui64vIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64* values) {
		#if defined(glProgramUniformHandleui64vNV)
			return glProgramUniformHandleui64vNV(program, location, count, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformHandleui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix2dv)
			return glProgramUniformMatrix2dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix2dvEXT)
			return glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix2fv)
			return glProgramUniformMatrix2fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix2fvEXT)
			return glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix2x3dv)
			return glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix2x3dvEXT)
			return glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix2x3fv)
			return glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix2x3fvEXT)
			return glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x3fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix2x4dv)
			return glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix2x4dvEXT)
			return glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x4dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix2x4fv)
			return glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix2x4fvEXT)
			return glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix2x4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix3dv)
			return glProgramUniformMatrix3dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix3dvEXT)
			return glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix3fv)
			return glProgramUniformMatrix3fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix3fvEXT)
			return glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix3x2dv)
			return glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix3x2dvEXT)
			return glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x2dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix3x2fv)
			return glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix3x2fvEXT)
			return glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x2fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix3x4dv)
			return glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix3x4dvEXT)
			return glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x4dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix3x4fv)
			return glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix3x4fvEXT)
			return glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix3x4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix4dv)
			return glProgramUniformMatrix4dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix4dvEXT)
			return glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix4fv)
			return glProgramUniformMatrix4fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix4fvEXT)
			return glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix4x2dv)
			return glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix4x2dvEXT)
			return glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x2dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix4x2fv)
			return glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix4x2fvEXT)
			return glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x2fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix4x3dv)
			return glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glProgramUniformMatrix4x3dvEXT)
			return glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix4x3fv)
			return glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glProgramUniformMatrix4x3fvEXT)
			return glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformMatrix4x3fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformui64NV(GLuint program, GLint location, GLuint64EXT value) {
		#if defined(glProgramUniformui64NV)
			return glProgramUniformui64NV(program, location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glProgramUniformui64vNV)
			return glProgramUniformui64vNV(program, location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramUniformui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void programVertexLimitNV(enums::ProgramTarget target, GLint limit) {
		#if defined(glProgramVertexLimitNV)
			return glProgramVertexLimitNV(static_cast<GLenum>(target), limit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProgramVertexLimitNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void provokingVertex(enums::VertexProvokingMode mode) {
		#if defined(glProvokingVertex)
			return glProvokingVertex(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProvokingVertex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void provokingVertexEXT(enums::VertexProvokingMode mode) {
		#if defined(glProvokingVertexEXT)
			return glProvokingVertexEXT(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glProvokingVertexEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushAttrib(GLbitfield mask) {
		#if defined(glPushAttrib)
			return glPushAttrib(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushAttrib" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushClientAttrib(GLbitfield mask) {
		#if defined(glPushClientAttrib)
			return glPushClientAttrib(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushClientAttrib" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushClientAttribDefaultEXT(GLbitfield mask) {
		#if defined(glPushClientAttribDefaultEXT)
			return glPushClientAttribDefaultEXT(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushClientAttribDefaultEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushDebugGroup(enums::DebugSource source, GLuint id, GLsizei length, const GLchar* message) {
		#if defined(glPushDebugGroup)
			return glPushDebugGroup(static_cast<GLenum>(source), id, length, message);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushDebugGroup" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushDebugGroupKHR(enums::DebugSource source, GLuint id, GLsizei length, const GLchar* message) {
		#if defined(glPushDebugGroupKHR)
			return glPushDebugGroupKHR(static_cast<GLenum>(source), id, length, message);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushDebugGroupKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushGroupMarkerEXT(GLsizei length, const GLchar* marker) {
		#if defined(glPushGroupMarkerEXT)
			return glPushGroupMarkerEXT(length, marker);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushGroupMarkerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushMatrix() {
		#if defined(glPushMatrix)
			return glPushMatrix();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushMatrix" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void pushName(GLuint name) {
		#if defined(glPushName)
			return glPushName(name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glPushName" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void queryCounter(GLuint id, enums::QueryCounterTarget target) {
		#if defined(glQueryCounter)
			return glQueryCounter(id, static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glQueryCounter" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void queryCounterEXT(GLuint id, enums::QueryCounterTarget target) {
		#if defined(glQueryCounterEXT)
			return glQueryCounterEXT(id, static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glQueryCounterEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLbitfield queryMatrixxOES(GLfixed* mantissa, GLint* exponent) {
		#if defined(glQueryMatrixxOES)
			return glQueryMatrixxOES(mantissa, exponent);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glQueryMatrixxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void queryObjectParameteruiAMD(enums::QueryTarget target, GLuint id, GLenum pname, GLuint param) {
		#if defined(glQueryObjectParameteruiAMD)
			return glQueryObjectParameteruiAMD(static_cast<GLenum>(target), id, pname, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glQueryObjectParameteruiAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint queryResourceNV(GLenum queryType, GLint tagId, GLuint count, GLint* buffer) {
		#if defined(glQueryResourceNV)
			return glQueryResourceNV(queryType, tagId, count, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glQueryResourceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void queryResourceTagNV(GLint tagId, const GLchar* tagString) {
		#if defined(glQueryResourceTagNV)
			return glQueryResourceTagNV(tagId, tagString);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glQueryResourceTagNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2d(GLdouble x, GLdouble y) {
		#if defined(glRasterPos2d)
			return glRasterPos2d(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2dv(const GLdouble* v) {
		#if defined(glRasterPos2dv)
			return glRasterPos2dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2f(GLfloat x, GLfloat y) {
		#if defined(glRasterPos2f)
			return glRasterPos2f(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2fv(const GLfloat* v) {
		#if defined(glRasterPos2fv)
			return glRasterPos2fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2i(GLint x, GLint y) {
		#if defined(glRasterPos2i)
			return glRasterPos2i(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2iv(const GLint* v) {
		#if defined(glRasterPos2iv)
			return glRasterPos2iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2s(GLshort x, GLshort y) {
		#if defined(glRasterPos2s)
			return glRasterPos2s(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2sv(const GLshort* v) {
		#if defined(glRasterPos2sv)
			return glRasterPos2sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2xOES(GLfixed x, GLfixed y) {
		#if defined(glRasterPos2xOES)
			return glRasterPos2xOES(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos2xvOES(const GLfixed* coords) {
		#if defined(glRasterPos2xvOES)
			return glRasterPos2xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos2xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3d(GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glRasterPos3d)
			return glRasterPos3d(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3dv(const GLdouble* v) {
		#if defined(glRasterPos3dv)
			return glRasterPos3dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3f(GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glRasterPos3f)
			return glRasterPos3f(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3fv(const GLfloat* v) {
		#if defined(glRasterPos3fv)
			return glRasterPos3fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3i(GLint x, GLint y, GLint z) {
		#if defined(glRasterPos3i)
			return glRasterPos3i(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3iv(const GLint* v) {
		#if defined(glRasterPos3iv)
			return glRasterPos3iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3s(GLshort x, GLshort y, GLshort z) {
		#if defined(glRasterPos3s)
			return glRasterPos3s(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3sv(const GLshort* v) {
		#if defined(glRasterPos3sv)
			return glRasterPos3sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3xOES(GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glRasterPos3xOES)
			return glRasterPos3xOES(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos3xvOES(const GLfixed* coords) {
		#if defined(glRasterPos3xvOES)
			return glRasterPos3xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos3xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glRasterPos4d)
			return glRasterPos4d(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4dv(const GLdouble* v) {
		#if defined(glRasterPos4dv)
			return glRasterPos4dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glRasterPos4f)
			return glRasterPos4f(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4fv(const GLfloat* v) {
		#if defined(glRasterPos4fv)
			return glRasterPos4fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4i(GLint x, GLint y, GLint z, GLint w) {
		#if defined(glRasterPos4i)
			return glRasterPos4i(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4iv(const GLint* v) {
		#if defined(glRasterPos4iv)
			return glRasterPos4iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w) {
		#if defined(glRasterPos4s)
			return glRasterPos4s(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4sv(const GLshort* v) {
		#if defined(glRasterPos4sv)
			return glRasterPos4sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4xOES(GLfixed x, GLfixed y, GLfixed z, GLfixed w) {
		#if defined(glRasterPos4xOES)
			return glRasterPos4xOES(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterPos4xvOES(const GLfixed* coords) {
		#if defined(glRasterPos4xvOES)
			return glRasterPos4xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterPos4xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rasterSamplesEXT(GLuint samples, GLboolean fixedsamplelocations) {
		#if defined(glRasterSamplesEXT)
			return glRasterSamplesEXT(samples, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRasterSamplesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readBuffer(enums::ReadBufferMode src) {
		#if defined(glReadBuffer)
			return glReadBuffer(static_cast<GLenum>(src));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readBufferIndexedEXT(enums::ReadBufferMode src, GLint index) {
		#if defined(glReadBufferIndexedEXT)
			return glReadBufferIndexedEXT(static_cast<GLenum>(src), index);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadBufferIndexedEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readBufferNV(GLenum mode) {
		#if defined(glReadBufferNV)
			return glReadBufferNV(mode);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadBufferNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readInstrumentsSGIX(GLint marker) {
		#if defined(glReadInstrumentsSGIX)
			return glReadInstrumentsSGIX(marker);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadInstrumentsSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readPixels(GLint x, GLint y, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, void * pixels) {
		#if defined(glReadPixels)
			return glReadPixels(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadPixels" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readnPixels(GLint x, GLint y, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * data) {
		#if defined(glReadnPixels)
			return glReadnPixels(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadnPixels" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * data) {
		#if defined(glReadnPixelsARB)
			return glReadnPixelsARB(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadnPixelsARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * data) {
		#if defined(glReadnPixelsEXT)
			return glReadnPixelsEXT(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadnPixelsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void readnPixelsKHR(GLint x, GLint y, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, GLsizei bufSize, void * data) {
		#if defined(glReadnPixelsKHR)
			return glReadnPixelsKHR(x, y, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), bufSize, data);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReadnPixelsKHR" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean releaseKeyedMutexWin32EXT(GLuint memory, GLuint64 key) {
		#if defined(glReleaseKeyedMutexWin32EXT)
			return glReleaseKeyedMutexWin32EXT(memory, key);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReleaseKeyedMutexWin32EXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void rectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) {
		#if defined(glRectd)
			return glRectd(x1, y1, x2, y2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectd" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rectdv(const GLdouble* v1, const GLdouble* v2) {
		#if defined(glRectdv)
			return glRectdv(v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectdv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) {
		#if defined(glRectf)
			return glRectf(x1, y1, x2, y2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rectfv(const GLfloat* v1, const GLfloat* v2) {
		#if defined(glRectfv)
			return glRectfv(v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void recti(GLint x1, GLint y1, GLint x2, GLint y2) {
		#if defined(glRecti)
			return glRecti(x1, y1, x2, y2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRecti" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rectiv(const GLint* v1, const GLint* v2) {
		#if defined(glRectiv)
			return glRectiv(v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rects(GLshort x1, GLshort y1, GLshort x2, GLshort y2) {
		#if defined(glRects)
			return glRects(x1, y1, x2, y2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRects" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rectsv(const GLshort* v1, const GLshort* v2) {
		#if defined(glRectsv)
			return glRectsv(v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectsv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rectxOES(GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2) {
		#if defined(glRectxOES)
			return glRectxOES(x1, y1, x2, y2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rectxvOES(const GLfixed* v1, const GLfixed* v2) {
		#if defined(glRectxvOES)
			return glRectxvOES(v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRectxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void referencePlaneSGIX(const GLdouble* equation) {
		#if defined(glReferencePlaneSGIX)
			return glReferencePlaneSGIX(equation);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReferencePlaneSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void releaseShaderCompiler() {
		#if defined(glReleaseShaderCompiler)
			return glReleaseShaderCompiler();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReleaseShaderCompiler" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderGpuMaskNV(GLbitfield mask) {
		#if defined(glRenderGpuMaskNV)
			return glRenderGpuMaskNV(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderGpuMaskNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLint renderMode(enums::RenderingMode mode) {
		#if defined(glRenderMode)
			return glRenderMode(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderMode" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void renderbufferStorage(enums::RenderbufferTarget target, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorage)
			return glRenderbufferStorage(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageEXT(enums::RenderbufferTarget target, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageEXT)
			return glRenderbufferStorageEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisample(enums::RenderbufferTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisample)
			return glRenderbufferStorageMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisampleANGLE(enums::RenderbufferTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisampleANGLE)
			return glRenderbufferStorageMultisampleANGLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisampleANGLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisampleAPPLE(enums::RenderbufferTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisampleAPPLE)
			return glRenderbufferStorageMultisampleAPPLE(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisampleAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisampleAdvancedAMD(enums::RenderbufferTarget target, GLsizei samples, GLsizei storageSamples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisampleAdvancedAMD)
			return glRenderbufferStorageMultisampleAdvancedAMD(static_cast<GLenum>(target), samples, storageSamples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisampleAdvancedAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisampleCoverageNV(enums::RenderbufferTarget target, GLsizei coverageSamples, GLsizei colorSamples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisampleCoverageNV)
			return glRenderbufferStorageMultisampleCoverageNV(static_cast<GLenum>(target), coverageSamples, colorSamples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisampleCoverageNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisampleEXT(enums::RenderbufferTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisampleEXT)
			return glRenderbufferStorageMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisampleIMG(enums::RenderbufferTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisampleIMG)
			return glRenderbufferStorageMultisampleIMG(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisampleIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageMultisampleNV(enums::RenderbufferTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageMultisampleNV)
			return glRenderbufferStorageMultisampleNV(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageMultisampleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void renderbufferStorageOES(enums::RenderbufferTarget target, enums::InternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glRenderbufferStorageOES)
			return glRenderbufferStorageOES(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRenderbufferStorageOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodePointerSUN(enums::ReplacementCodeTypeSUN type, GLsizei stride, const void ** pointer) {
		#if defined(glReplacementCodePointerSUN)
			return glReplacementCodePointerSUN(static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodePointerSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeubSUN(GLubyte code) {
		#if defined(glReplacementCodeubSUN)
			return glReplacementCodeubSUN(code);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeubSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeubvSUN(const GLubyte* code) {
		#if defined(glReplacementCodeubvSUN)
			return glReplacementCodeubvSUN(code);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeubvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiColor3fVertex3fSUN)
			return glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiColor3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiColor3fVertex3fvSUN(const GLuint* rc, const GLfloat* c, const GLfloat* v) {
		#if defined(glReplacementCodeuiColor3fVertex3fvSUN)
			return glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiColor3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiColor4fNormal3fVertex3fSUN)
			return glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiColor4fNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* c, const GLfloat* n, const GLfloat* v) {
		#if defined(glReplacementCodeuiColor4fNormal3fVertex3fvSUN)
			return glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiColor4fNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiColor4ubVertex3fSUN)
			return glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiColor4ubVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiColor4ubVertex3fvSUN(const GLuint* rc, const GLubyte* c, const GLfloat* v) {
		#if defined(glReplacementCodeuiColor4ubVertex3fvSUN)
			return glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiColor4ubVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiNormal3fVertex3fSUN)
			return glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* n, const GLfloat* v) {
		#if defined(glReplacementCodeuiNormal3fVertex3fvSUN)
			return glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiSUN(GLuint code) {
		#if defined(glReplacementCodeuiSUN)
			return glReplacementCodeuiSUN(code);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN)
			return glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) {
		#if defined(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN)
			return glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN)
			return glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* n, const GLfloat* v) {
		#if defined(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN)
			return glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiTexCoord2fVertex3fSUN)
			return glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiTexCoord2fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiTexCoord2fVertex3fvSUN(const GLuint* rc, const GLfloat* tc, const GLfloat* v) {
		#if defined(glReplacementCodeuiTexCoord2fVertex3fvSUN)
			return glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiTexCoord2fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glReplacementCodeuiVertex3fSUN)
			return glReplacementCodeuiVertex3fSUN(rc, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuiVertex3fvSUN(const GLuint* rc, const GLfloat* v) {
		#if defined(glReplacementCodeuiVertex3fvSUN)
			return glReplacementCodeuiVertex3fvSUN(rc, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuiVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeuivSUN(const GLuint* code) {
		#if defined(glReplacementCodeuivSUN)
			return glReplacementCodeuivSUN(code);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeuivSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeusSUN(GLushort code) {
		#if defined(glReplacementCodeusSUN)
			return glReplacementCodeusSUN(code);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeusSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void replacementCodeusvSUN(const GLushort* code) {
		#if defined(glReplacementCodeusvSUN)
			return glReplacementCodeusvSUN(code);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glReplacementCodeusvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void requestResidentProgramsNV(GLsizei n, const GLuint* programs) {
		#if defined(glRequestResidentProgramsNV)
			return glRequestResidentProgramsNV(n, programs);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRequestResidentProgramsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resetHistogram(enums::HistogramTargetEXT target) {
		#if defined(glResetHistogram)
			return glResetHistogram(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResetHistogram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resetHistogramEXT(enums::HistogramTargetEXT target) {
		#if defined(glResetHistogramEXT)
			return glResetHistogramEXT(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResetHistogramEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resetMemoryObjectParameterNV(GLuint memory, GLenum pname) {
		#if defined(glResetMemoryObjectParameterNV)
			return glResetMemoryObjectParameterNV(memory, pname);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResetMemoryObjectParameterNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resetMinmax(enums::MinmaxTargetEXT target) {
		#if defined(glResetMinmax)
			return glResetMinmax(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResetMinmax" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resetMinmaxEXT(enums::MinmaxTargetEXT target) {
		#if defined(glResetMinmaxEXT)
			return glResetMinmaxEXT(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResetMinmaxEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resizeBuffersMESA() {
		#if defined(glResizeBuffersMESA)
			return glResizeBuffersMESA();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResizeBuffersMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resolveDepthValuesNV() {
		#if defined(glResolveDepthValuesNV)
			return glResolveDepthValuesNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResolveDepthValuesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resolveMultisampleFramebufferAPPLE() {
		#if defined(glResolveMultisampleFramebufferAPPLE)
			return glResolveMultisampleFramebufferAPPLE();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResolveMultisampleFramebufferAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resumeTransformFeedback() {
		#if defined(glResumeTransformFeedback)
			return glResumeTransformFeedback();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResumeTransformFeedback" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void resumeTransformFeedbackNV() {
		#if defined(glResumeTransformFeedbackNV)
			return glResumeTransformFeedbackNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glResumeTransformFeedbackNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glRotated)
			return glRotated(angle, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRotated" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glRotatef)
			return glRotatef(angle, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRotatef" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glRotatex)
			return glRotatex(angle, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRotatex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void rotatexOES(GLfixed angle, GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glRotatexOES)
			return glRotatexOES(angle, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glRotatexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleCoverage(GLfloat value, GLboolean invert) {
		#if defined(glSampleCoverage)
			return glSampleCoverage(value, invert);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleCoverage" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleCoverageARB(GLfloat value, GLboolean invert) {
		#if defined(glSampleCoverageARB)
			return glSampleCoverageARB(value, invert);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleCoverageARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleCoveragex(GLclampx value, GLboolean invert) {
		#if defined(glSampleCoveragex)
			return glSampleCoveragex(value, invert);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleCoveragex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleCoveragexOES(GLclampx value, GLboolean invert) {
		#if defined(glSampleCoveragexOES)
			return glSampleCoveragexOES(value, invert);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleCoveragexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleMapATI(GLuint dst, GLuint interp, enums::SwizzleOpATI swizzle) {
		#if defined(glSampleMapATI)
			return glSampleMapATI(dst, interp, static_cast<GLenum>(swizzle));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleMapATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleMaskEXT(GLclampf value, GLboolean invert) {
		#if defined(glSampleMaskEXT)
			return glSampleMaskEXT(value, invert);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleMaskEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleMaskIndexedNV(GLuint index, GLbitfield mask) {
		#if defined(glSampleMaskIndexedNV)
			return glSampleMaskIndexedNV(index, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleMaskIndexedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleMaskSGIS(GLclampf value, GLboolean invert) {
		#if defined(glSampleMaskSGIS)
			return glSampleMaskSGIS(value, invert);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleMaskSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sampleMaski(GLuint maskNumber, GLbitfield mask) {
		#if defined(glSampleMaski)
			return glSampleMaski(maskNumber, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSampleMaski" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplePatternEXT(enums::SamplePatternEXT pattern) {
		#if defined(glSamplePatternEXT)
			return glSamplePatternEXT(static_cast<GLenum>(pattern));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplePatternEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplePatternSGIS(enums::SamplePatternSGIS pattern) {
		#if defined(glSamplePatternSGIS)
			return glSamplePatternSGIS(static_cast<GLenum>(pattern));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplePatternSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterIiv(GLuint sampler, enums::SamplerParameterI pname, const GLint* param) {
		#if defined(glSamplerParameterIiv)
			return glSamplerParameterIiv(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterIiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterIivEXT(GLuint sampler, enums::SamplerParameterI pname, const GLint* param) {
		#if defined(glSamplerParameterIivEXT)
			return glSamplerParameterIivEXT(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterIivOES(GLuint sampler, enums::SamplerParameterI pname, const GLint* param) {
		#if defined(glSamplerParameterIivOES)
			return glSamplerParameterIivOES(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterIivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterIuiv(GLuint sampler, enums::SamplerParameterI pname, const GLuint* param) {
		#if defined(glSamplerParameterIuiv)
			return glSamplerParameterIuiv(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterIuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterIuivEXT(GLuint sampler, enums::SamplerParameterI pname, const GLuint* param) {
		#if defined(glSamplerParameterIuivEXT)
			return glSamplerParameterIuivEXT(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterIuivOES(GLuint sampler, enums::SamplerParameterI pname, const GLuint* param) {
		#if defined(glSamplerParameterIuivOES)
			return glSamplerParameterIuivOES(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterIuivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterf(GLuint sampler, enums::SamplerParameterF pname, GLfloat param) {
		#if defined(glSamplerParameterf)
			return glSamplerParameterf(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameterfv(GLuint sampler, enums::SamplerParameterF pname, const GLfloat* param) {
		#if defined(glSamplerParameterfv)
			return glSamplerParameterfv(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameteri(GLuint sampler, enums::SamplerParameterI pname, GLint param) {
		#if defined(glSamplerParameteri)
			return glSamplerParameteri(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void samplerParameteriv(GLuint sampler, enums::SamplerParameterI pname, const GLint* param) {
		#if defined(glSamplerParameteriv)
			return glSamplerParameteriv(sampler, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSamplerParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scaled(GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glScaled)
			return glScaled(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScaled" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scalef(GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glScalef)
			return glScalef(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScalef" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scalex(GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glScalex)
			return glScalex(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScalex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scalexOES(GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glScalexOES)
			return glScalexOES(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScalexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissor(GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glScissor)
			return glScissor(x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissor" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorArrayv(GLuint first, GLsizei count, const GLint* v) {
		#if defined(glScissorArrayv)
			return glScissorArrayv(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorArrayv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorArrayvNV(GLuint first, GLsizei count, const GLint* v) {
		#if defined(glScissorArrayvNV)
			return glScissorArrayvNV(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorArrayvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorArrayvOES(GLuint first, GLsizei count, const GLint* v) {
		#if defined(glScissorArrayvOES)
			return glScissorArrayvOES(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorArrayvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorExclusiveArrayvNV(GLuint first, GLsizei count, const GLint* v) {
		#if defined(glScissorExclusiveArrayvNV)
			return glScissorExclusiveArrayvNV(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorExclusiveArrayvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorExclusiveNV(GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glScissorExclusiveNV)
			return glScissorExclusiveNV(x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorExclusiveNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) {
		#if defined(glScissorIndexed)
			return glScissorIndexed(index, left, bottom, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorIndexed" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorIndexedNV(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) {
		#if defined(glScissorIndexedNV)
			return glScissorIndexedNV(index, left, bottom, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorIndexedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorIndexedOES(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) {
		#if defined(glScissorIndexedOES)
			return glScissorIndexedOES(index, left, bottom, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorIndexedOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorIndexedv(GLuint index, const GLint* v) {
		#if defined(glScissorIndexedv)
			return glScissorIndexedv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorIndexedv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorIndexedvNV(GLuint index, const GLint* v) {
		#if defined(glScissorIndexedvNV)
			return glScissorIndexedvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorIndexedvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void scissorIndexedvOES(GLuint index, const GLint* v) {
		#if defined(glScissorIndexedvOES)
			return glScissorIndexedvOES(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glScissorIndexedvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3b(GLbyte red, GLbyte green, GLbyte blue) {
		#if defined(glSecondaryColor3b)
			return glSecondaryColor3b(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3b" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue) {
		#if defined(glSecondaryColor3bEXT)
			return glSecondaryColor3bEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3bEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3bv(const GLbyte* v) {
		#if defined(glSecondaryColor3bv)
			return glSecondaryColor3bv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3bv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3bvEXT(const GLbyte* v) {
		#if defined(glSecondaryColor3bvEXT)
			return glSecondaryColor3bvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3bvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3d(GLdouble red, GLdouble green, GLdouble blue) {
		#if defined(glSecondaryColor3d)
			return glSecondaryColor3d(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue) {
		#if defined(glSecondaryColor3dEXT)
			return glSecondaryColor3dEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3dv(const GLdouble* v) {
		#if defined(glSecondaryColor3dv)
			return glSecondaryColor3dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3dvEXT(const GLdouble* v) {
		#if defined(glSecondaryColor3dvEXT)
			return glSecondaryColor3dvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3f(GLfloat red, GLfloat green, GLfloat blue) {
		#if defined(glSecondaryColor3f)
			return glSecondaryColor3f(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue) {
		#if defined(glSecondaryColor3fEXT)
			return glSecondaryColor3fEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3fv(const GLfloat* v) {
		#if defined(glSecondaryColor3fv)
			return glSecondaryColor3fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3fvEXT(const GLfloat* v) {
		#if defined(glSecondaryColor3fvEXT)
			return glSecondaryColor3fvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue) {
		#if defined(glSecondaryColor3hNV)
			return glSecondaryColor3hNV(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3hvNV(const GLhalfNV* v) {
		#if defined(glSecondaryColor3hvNV)
			return glSecondaryColor3hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3i(GLint red, GLint green, GLint blue) {
		#if defined(glSecondaryColor3i)
			return glSecondaryColor3i(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3iEXT(GLint red, GLint green, GLint blue) {
		#if defined(glSecondaryColor3iEXT)
			return glSecondaryColor3iEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3iv(const GLint* v) {
		#if defined(glSecondaryColor3iv)
			return glSecondaryColor3iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3ivEXT(const GLint* v) {
		#if defined(glSecondaryColor3ivEXT)
			return glSecondaryColor3ivEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3s(GLshort red, GLshort green, GLshort blue) {
		#if defined(glSecondaryColor3s)
			return glSecondaryColor3s(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3sEXT(GLshort red, GLshort green, GLshort blue) {
		#if defined(glSecondaryColor3sEXT)
			return glSecondaryColor3sEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3sEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3sv(const GLshort* v) {
		#if defined(glSecondaryColor3sv)
			return glSecondaryColor3sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3svEXT(const GLshort* v) {
		#if defined(glSecondaryColor3svEXT)
			return glSecondaryColor3svEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3svEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue) {
		#if defined(glSecondaryColor3ub)
			return glSecondaryColor3ub(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3ub" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue) {
		#if defined(glSecondaryColor3ubEXT)
			return glSecondaryColor3ubEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3ubEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3ubv(const GLubyte* v) {
		#if defined(glSecondaryColor3ubv)
			return glSecondaryColor3ubv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3ubv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3ubvEXT(const GLubyte* v) {
		#if defined(glSecondaryColor3ubvEXT)
			return glSecondaryColor3ubvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3ubvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3ui(GLuint red, GLuint green, GLuint blue) {
		#if defined(glSecondaryColor3ui)
			return glSecondaryColor3ui(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue) {
		#if defined(glSecondaryColor3uiEXT)
			return glSecondaryColor3uiEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3uiv(const GLuint* v) {
		#if defined(glSecondaryColor3uiv)
			return glSecondaryColor3uiv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3uivEXT(const GLuint* v) {
		#if defined(glSecondaryColor3uivEXT)
			return glSecondaryColor3uivEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3us(GLushort red, GLushort green, GLushort blue) {
		#if defined(glSecondaryColor3us)
			return glSecondaryColor3us(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3us" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3usEXT(GLushort red, GLushort green, GLushort blue) {
		#if defined(glSecondaryColor3usEXT)
			return glSecondaryColor3usEXT(red, green, blue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3usEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3usv(const GLushort* v) {
		#if defined(glSecondaryColor3usv)
			return glSecondaryColor3usv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3usv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColor3usvEXT(const GLushort* v) {
		#if defined(glSecondaryColor3usvEXT)
			return glSecondaryColor3usvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColor3usvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColorFormatNV(GLint size, enums::ColorPointerType type, GLsizei stride) {
		#if defined(glSecondaryColorFormatNV)
			return glSecondaryColorFormatNV(size, static_cast<GLenum>(type), stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColorFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColorP3ui(enums::ColorPointerType type, GLuint color) {
		#if defined(glSecondaryColorP3ui)
			return glSecondaryColorP3ui(static_cast<GLenum>(type), color);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColorP3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColorP3uiv(enums::ColorPointerType type, const GLuint* color) {
		#if defined(glSecondaryColorP3uiv)
			return glSecondaryColorP3uiv(static_cast<GLenum>(type), color);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColorP3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColorPointer(GLint size, enums::ColorPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glSecondaryColorPointer)
			return glSecondaryColorPointer(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColorPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColorPointerEXT(GLint size, enums::ColorPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glSecondaryColorPointerEXT)
			return glSecondaryColorPointerEXT(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColorPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void secondaryColorPointerListIBM(GLint size, enums::SecondaryColorPointerTypeIBM type, GLint stride, const void ** pointer, GLint ptrstride) {
		#if defined(glSecondaryColorPointerListIBM)
			return glSecondaryColorPointerListIBM(size, static_cast<GLenum>(type), stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSecondaryColorPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void selectBuffer(GLsizei size, GLuint* buffer) {
		#if defined(glSelectBuffer)
			return glSelectBuffer(size, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSelectBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void selectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList) {
		#if defined(glSelectPerfMonitorCountersAMD)
			return glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSelectPerfMonitorCountersAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void semaphoreParameterivNV(GLuint semaphore, enums::SemaphoreParameterName pname, const GLint* params) {
		#if defined(glSemaphoreParameterivNV)
			return glSemaphoreParameterivNV(semaphore, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSemaphoreParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void semaphoreParameterui64vEXT(GLuint semaphore, enums::SemaphoreParameterName pname, const GLuint64* params) {
		#if defined(glSemaphoreParameterui64vEXT)
			return glSemaphoreParameterui64vEXT(semaphore, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSemaphoreParameterui64vEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void separableFilter2D(enums::SeparableTargetEXT target, enums::InternalFormat internalformat, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * row, const void * column) {
		#if defined(glSeparableFilter2D)
			return glSeparableFilter2D(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), row, column);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSeparableFilter2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void separableFilter2DEXT(enums::SeparableTargetEXT target, enums::InternalFormat internalformat, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * row, const void * column) {
		#if defined(glSeparableFilter2DEXT)
			return glSeparableFilter2DEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), row, column);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSeparableFilter2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void setFenceAPPLE(GLuint fence) {
		#if defined(glSetFenceAPPLE)
			return glSetFenceAPPLE(fence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSetFenceAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void setFenceNV(GLuint fence, enums::FenceConditionNV condition) {
		#if defined(glSetFenceNV)
			return glSetFenceNV(fence, static_cast<GLenum>(condition));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSetFenceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void setFragmentShaderConstantATI(GLuint dst, const GLfloat* value) {
		#if defined(glSetFragmentShaderConstantATI)
			return glSetFragmentShaderConstantATI(dst, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSetFragmentShaderConstantATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void setInvariantEXT(GLuint id, enums::ScalarType type, const void * addr) {
		#if defined(glSetInvariantEXT)
			return glSetInvariantEXT(id, static_cast<GLenum>(type), addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSetInvariantEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void setLocalConstantEXT(GLuint id, enums::ScalarType type, const void * addr) {
		#if defined(glSetLocalConstantEXT)
			return glSetLocalConstantEXT(id, static_cast<GLenum>(type), addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSetLocalConstantEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void setMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat* val) {
		#if defined(glSetMultisamplefvAMD)
			return glSetMultisamplefvAMD(pname, index, val);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSetMultisamplefvAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadeModel(enums::ShadingModel mode) {
		#if defined(glShadeModel)
			return glShadeModel(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadeModel" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shaderBinary(GLsizei count, const GLuint* shaders, enums::ShaderBinaryFormat binaryFormat, const void * binary, GLsizei length) {
		#if defined(glShaderBinary)
			return glShaderBinary(count, shaders, static_cast<GLenum>(binaryFormat), binary, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShaderBinary" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shaderOp1EXT(enums::VertexShaderOpEXT op, GLuint res, GLuint arg1) {
		#if defined(glShaderOp1EXT)
			return glShaderOp1EXT(static_cast<GLenum>(op), res, arg1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShaderOp1EXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shaderOp2EXT(enums::VertexShaderOpEXT op, GLuint res, GLuint arg1, GLuint arg2) {
		#if defined(glShaderOp2EXT)
			return glShaderOp2EXT(static_cast<GLenum>(op), res, arg1, arg2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShaderOp2EXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shaderOp3EXT(enums::VertexShaderOpEXT op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3) {
		#if defined(glShaderOp3EXT)
			return glShaderOp3EXT(static_cast<GLenum>(op), res, arg1, arg2, arg3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShaderOp3EXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shaderSource(GLuint shader, GLsizei count, const GLchar*const* string, const GLint* length) {
		#if defined(glShaderSource)
			return glShaderSource(shader, count, string, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShaderSource" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB** string, const GLint* length) {
		#if defined(glShaderSourceARB)
			return glShaderSourceARB(shaderObj, count, string, length);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShaderSourceARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) {
		#if defined(glShaderStorageBlockBinding)
			return glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShaderStorageBlockBinding" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadingRateEXT(enums::ShadingRate rate) {
		#if defined(glShadingRateEXT)
			return glShadingRateEXT(static_cast<GLenum>(rate));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadingRateEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadingRateCombinerOpsEXT(enums::ShadingRateCombinerOp combinerOp0, enums::ShadingRateCombinerOp combinerOp1) {
		#if defined(glShadingRateCombinerOpsEXT)
			return glShadingRateCombinerOpsEXT(static_cast<GLenum>(combinerOp0), static_cast<GLenum>(combinerOp1));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadingRateCombinerOpsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadingRateImageBarrierNV(GLboolean synchronize) {
		#if defined(glShadingRateImageBarrierNV)
			return glShadingRateImageBarrierNV(synchronize);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadingRateImageBarrierNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadingRateQCOM(enums::ShadingRateQCOM rate) {
		#if defined(glShadingRateQCOM)
			return glShadingRateQCOM(static_cast<GLenum>(rate));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadingRateQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadingRateImagePaletteNV(GLuint viewport, GLuint first, GLsizei count, const GLenum* rates) {
		#if defined(glShadingRateImagePaletteNV)
			return glShadingRateImagePaletteNV(viewport, first, count, rates);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadingRateImagePaletteNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadingRateSampleOrderNV(GLenum order) {
		#if defined(glShadingRateSampleOrderNV)
			return glShadingRateSampleOrderNV(order);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadingRateSampleOrderNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void shadingRateSampleOrderCustomNV(GLenum rate, GLuint samples, const GLint* locations) {
		#if defined(glShadingRateSampleOrderCustomNV)
			return glShadingRateSampleOrderCustomNV(rate, samples, locations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glShadingRateSampleOrderCustomNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void sharpenTexFuncSGIS(enums::TextureTarget target, GLsizei n, const GLfloat* points) {
		#if defined(glSharpenTexFuncSGIS)
			return glSharpenTexFuncSGIS(static_cast<GLenum>(target), n, points);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSharpenTexFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void signalSemaphoreEXT(GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint* textures, const GLenum* dstLayouts) {
		#if defined(glSignalSemaphoreEXT)
			return glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSignalSemaphoreEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void signalSemaphoreui64NVX(GLuint signalGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64* fenceValueArray) {
		#if defined(glSignalSemaphoreui64NVX)
			return glSignalSemaphoreui64NVX(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSignalSemaphoreui64NVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void specializeShader(GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue) {
		#if defined(glSpecializeShader)
			return glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSpecializeShader" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void specializeShaderARB(GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue) {
		#if defined(glSpecializeShaderARB)
			return glSpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSpecializeShaderARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void spriteParameterfSGIX(enums::SpriteParameterNameSGIX pname, GLfloat param) {
		#if defined(glSpriteParameterfSGIX)
			return glSpriteParameterfSGIX(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSpriteParameterfSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void spriteParameterfvSGIX(enums::SpriteParameterNameSGIX pname, const GLfloat* params) {
		#if defined(glSpriteParameterfvSGIX)
			return glSpriteParameterfvSGIX(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSpriteParameterfvSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void spriteParameteriSGIX(enums::SpriteParameterNameSGIX pname, GLint param) {
		#if defined(glSpriteParameteriSGIX)
			return glSpriteParameteriSGIX(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSpriteParameteriSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void spriteParameterivSGIX(enums::SpriteParameterNameSGIX pname, const GLint* params) {
		#if defined(glSpriteParameterivSGIX)
			return glSpriteParameterivSGIX(static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSpriteParameterivSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void startInstrumentsSGIX() {
		#if defined(glStartInstrumentsSGIX)
			return glStartInstrumentsSGIX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStartInstrumentsSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void startTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask) {
		#if defined(glStartTilingQCOM)
			return glStartTilingQCOM(x, y, width, height, preserveMask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStartTilingQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stateCaptureNV(GLuint state, GLenum mode) {
		#if defined(glStateCaptureNV)
			return glStateCaptureNV(state, mode);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStateCaptureNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag) {
		#if defined(glStencilClearTagEXT)
			return glStencilClearTagEXT(stencilTagBits, stencilClearTag);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilClearTagEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilFillPathInstancedNV(GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, enums::PathFillMode fillMode, GLuint mask, enums::PathTransformType transformType, const GLfloat* transformValues) {
		#if defined(glStencilFillPathInstancedNV)
			return glStencilFillPathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, static_cast<GLenum>(fillMode), mask, static_cast<GLenum>(transformType), transformValues);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilFillPathInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilFillPathNV(GLuint path, enums::PathFillMode fillMode, GLuint mask) {
		#if defined(glStencilFillPathNV)
			return glStencilFillPathNV(path, static_cast<GLenum>(fillMode), mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilFillPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilFunc(enums::StencilFunction func, GLint ref, GLuint mask) {
		#if defined(glStencilFunc)
			return glStencilFunc(static_cast<GLenum>(func), ref, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilFunc" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilFuncSeparate(enums::TriangleFace face, enums::StencilFunction func, GLint ref, GLuint mask) {
		#if defined(glStencilFuncSeparate)
			return glStencilFuncSeparate(static_cast<GLenum>(face), static_cast<GLenum>(func), ref, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilFuncSeparate" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilFuncSeparateATI(enums::StencilFunction frontfunc, enums::StencilFunction backfunc, GLint ref, GLuint mask) {
		#if defined(glStencilFuncSeparateATI)
			return glStencilFuncSeparateATI(static_cast<GLenum>(frontfunc), static_cast<GLenum>(backfunc), ref, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilFuncSeparateATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilMask(GLuint mask) {
		#if defined(glStencilMask)
			return glStencilMask(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilMask" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilMaskSeparate(enums::TriangleFace face, GLuint mask) {
		#if defined(glStencilMaskSeparate)
			return glStencilMaskSeparate(static_cast<GLenum>(face), mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilMaskSeparate" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilOp(enums::StencilOp fail, enums::StencilOp zfail, enums::StencilOp zpass) {
		#if defined(glStencilOp)
			return glStencilOp(static_cast<GLenum>(fail), static_cast<GLenum>(zfail), static_cast<GLenum>(zpass));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilOp" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilOpSeparate(enums::TriangleFace face, enums::StencilOp sfail, enums::StencilOp dpfail, enums::StencilOp dppass) {
		#if defined(glStencilOpSeparate)
			return glStencilOpSeparate(static_cast<GLenum>(face), static_cast<GLenum>(sfail), static_cast<GLenum>(dpfail), static_cast<GLenum>(dppass));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilOpSeparate" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilOpSeparateATI(enums::TriangleFace face, enums::StencilOp sfail, enums::StencilOp dpfail, enums::StencilOp dppass) {
		#if defined(glStencilOpSeparateATI)
			return glStencilOpSeparateATI(static_cast<GLenum>(face), static_cast<GLenum>(sfail), static_cast<GLenum>(dpfail), static_cast<GLenum>(dppass));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilOpSeparateATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilOpValueAMD(enums::TriangleFace face, GLuint value) {
		#if defined(glStencilOpValueAMD)
			return glStencilOpValueAMD(static_cast<GLenum>(face), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilOpValueAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilStrokePathInstancedNV(GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, enums::PathTransformType transformType, const GLfloat* transformValues) {
		#if defined(glStencilStrokePathInstancedNV)
			return glStencilStrokePathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, reference, mask, static_cast<GLenum>(transformType), transformValues);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilStrokePathInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilStrokePathNV(GLuint path, GLint reference, GLuint mask) {
		#if defined(glStencilStrokePathNV)
			return glStencilStrokePathNV(path, reference, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilStrokePathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilThenCoverFillPathInstancedNV(GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, enums::PathFillMode fillMode, GLuint mask, enums::InstancedPathCoverMode coverMode, enums::PathTransformType transformType, const GLfloat* transformValues) {
		#if defined(glStencilThenCoverFillPathInstancedNV)
			return glStencilThenCoverFillPathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, static_cast<GLenum>(fillMode), mask, static_cast<GLenum>(coverMode), static_cast<GLenum>(transformType), transformValues);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilThenCoverFillPathInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilThenCoverFillPathNV(GLuint path, enums::PathFillMode fillMode, GLuint mask, enums::PathCoverMode coverMode) {
		#if defined(glStencilThenCoverFillPathNV)
			return glStencilThenCoverFillPathNV(path, static_cast<GLenum>(fillMode), mask, static_cast<GLenum>(coverMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilThenCoverFillPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilThenCoverStrokePathInstancedNV(GLsizei numPaths, enums::PathElementType pathNameType, const void * paths, GLuint pathBase, GLint reference, GLuint mask, enums::InstancedPathCoverMode coverMode, enums::PathTransformType transformType, const GLfloat* transformValues) {
		#if defined(glStencilThenCoverStrokePathInstancedNV)
			return glStencilThenCoverStrokePathInstancedNV(numPaths, static_cast<GLenum>(pathNameType), paths, pathBase, reference, mask, static_cast<GLenum>(coverMode), static_cast<GLenum>(transformType), transformValues);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilThenCoverStrokePathInstancedNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stencilThenCoverStrokePathNV(GLuint path, GLint reference, GLuint mask, enums::PathCoverMode coverMode) {
		#if defined(glStencilThenCoverStrokePathNV)
			return glStencilThenCoverStrokePathNV(path, reference, mask, static_cast<GLenum>(coverMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStencilThenCoverStrokePathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stopInstrumentsSGIX(GLint marker) {
		#if defined(glStopInstrumentsSGIX)
			return glStopInstrumentsSGIX(marker);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStopInstrumentsSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void stringMarkerGREMEDY(GLsizei len, const void * string) {
		#if defined(glStringMarkerGREMEDY)
			return glStringMarkerGREMEDY(len, string);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glStringMarkerGREMEDY" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void subpixelPrecisionBiasNV(GLuint xbits, GLuint ybits) {
		#if defined(glSubpixelPrecisionBiasNV)
			return glSubpixelPrecisionBiasNV(xbits, ybits);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSubpixelPrecisionBiasNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void swizzleEXT(GLuint res, GLuint in, enums::VertexShaderCoordOutEXT outX, enums::VertexShaderCoordOutEXT outY, enums::VertexShaderCoordOutEXT outZ, enums::VertexShaderCoordOutEXT outW) {
		#if defined(glSwizzleEXT)
			return glSwizzleEXT(res, in, static_cast<GLenum>(outX), static_cast<GLenum>(outY), static_cast<GLenum>(outZ), static_cast<GLenum>(outW));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSwizzleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void syncTextureINTEL(GLuint texture) {
		#if defined(glSyncTextureINTEL)
			return glSyncTextureINTEL(texture);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSyncTextureINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tagSampleBufferSGIX() {
		#if defined(glTagSampleBufferSGIX)
			return glTagSampleBufferSGIX();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTagSampleBufferSGIX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz) {
		#if defined(glTangent3bEXT)
			return glTangent3bEXT(tx, ty, tz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3bEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3bvEXT(const GLbyte* v) {
		#if defined(glTangent3bvEXT)
			return glTangent3bvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3bvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz) {
		#if defined(glTangent3dEXT)
			return glTangent3dEXT(tx, ty, tz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3dvEXT(const GLdouble* v) {
		#if defined(glTangent3dvEXT)
			return glTangent3dvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz) {
		#if defined(glTangent3fEXT)
			return glTangent3fEXT(tx, ty, tz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3fEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3fvEXT(const GLfloat* v) {
		#if defined(glTangent3fvEXT)
			return glTangent3fvEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3fvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3iEXT(GLint tx, GLint ty, GLint tz) {
		#if defined(glTangent3iEXT)
			return glTangent3iEXT(tx, ty, tz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3ivEXT(const GLint* v) {
		#if defined(glTangent3ivEXT)
			return glTangent3ivEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3sEXT(GLshort tx, GLshort ty, GLshort tz) {
		#if defined(glTangent3sEXT)
			return glTangent3sEXT(tx, ty, tz);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3sEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangent3svEXT(const GLshort* v) {
		#if defined(glTangent3svEXT)
			return glTangent3svEXT(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangent3svEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tangentPointerEXT(enums::TangentPointerTypeEXT type, GLsizei stride, const void * pointer) {
		#if defined(glTangentPointerEXT)
			return glTangentPointerEXT(static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTangentPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tbufferMask3DFX(GLuint mask) {
		#if defined(glTbufferMask3DFX)
			return glTbufferMask3DFX(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTbufferMask3DFX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tessellationFactorAMD(GLfloat factor) {
		#if defined(glTessellationFactorAMD)
			return glTessellationFactorAMD(factor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTessellationFactorAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void tessellationModeAMD(GLenum mode) {
		#if defined(glTessellationModeAMD)
			return glTessellationModeAMD(mode);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTessellationModeAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean testFenceAPPLE(GLuint fence) {
		#if defined(glTestFenceAPPLE)
			return glTestFenceAPPLE(fence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTestFenceAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean testFenceNV(GLuint fence) {
		#if defined(glTestFenceNV)
			return glTestFenceNV(fence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTestFenceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean testObjectAPPLE(enums::ObjectTypeAPPLE object, GLuint name) {
		#if defined(glTestObjectAPPLE)
			return glTestObjectAPPLE(static_cast<GLenum>(object), name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTestObjectAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void texAttachMemoryNV(enums::TextureTarget target, GLuint memory, GLuint64 offset) {
		#if defined(glTexAttachMemoryNV)
			return glTexAttachMemoryNV(static_cast<GLenum>(target), memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexAttachMemoryNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBuffer(enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer) {
		#if defined(glTexBuffer)
			return glTexBuffer(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBufferARB(enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer) {
		#if defined(glTexBufferARB)
			return glTexBufferARB(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBufferARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBufferEXT(enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer) {
		#if defined(glTexBufferEXT)
			return glTexBufferEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBufferOES(enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer) {
		#if defined(glTexBufferOES)
			return glTexBufferOES(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBufferRange(enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glTexBufferRange)
			return glTexBufferRange(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBufferRangeEXT(enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glTexBufferRangeEXT)
			return glTexBufferRangeEXT(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBufferRangeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBufferRangeOES(enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glTexBufferRangeOES)
			return glTexBufferRangeOES(static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBufferRangeOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBumpParameterfvATI(enums::TexBumpParameterATI pname, const GLfloat* param) {
		#if defined(glTexBumpParameterfvATI)
			return glTexBumpParameterfvATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBumpParameterfvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texBumpParameterivATI(enums::TexBumpParameterATI pname, const GLint* param) {
		#if defined(glTexBumpParameterivATI)
			return glTexBumpParameterivATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexBumpParameterivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1bOES(GLbyte s) {
		#if defined(glTexCoord1bOES)
			return glTexCoord1bOES(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1bvOES(const GLbyte* coords) {
		#if defined(glTexCoord1bvOES)
			return glTexCoord1bvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1d(GLdouble s) {
		#if defined(glTexCoord1d)
			return glTexCoord1d(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1dv(const GLdouble* v) {
		#if defined(glTexCoord1dv)
			return glTexCoord1dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1f(GLfloat s) {
		#if defined(glTexCoord1f)
			return glTexCoord1f(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1fv(const GLfloat* v) {
		#if defined(glTexCoord1fv)
			return glTexCoord1fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1hNV(GLhalfNV s) {
		#if defined(glTexCoord1hNV)
			return glTexCoord1hNV(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1hvNV(const GLhalfNV* v) {
		#if defined(glTexCoord1hvNV)
			return glTexCoord1hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1i(GLint s) {
		#if defined(glTexCoord1i)
			return glTexCoord1i(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1iv(const GLint* v) {
		#if defined(glTexCoord1iv)
			return glTexCoord1iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1s(GLshort s) {
		#if defined(glTexCoord1s)
			return glTexCoord1s(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1sv(const GLshort* v) {
		#if defined(glTexCoord1sv)
			return glTexCoord1sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1xOES(GLfixed s) {
		#if defined(glTexCoord1xOES)
			return glTexCoord1xOES(s);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord1xvOES(const GLfixed* coords) {
		#if defined(glTexCoord1xvOES)
			return glTexCoord1xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord1xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2bOES(GLbyte s, GLbyte t) {
		#if defined(glTexCoord2bOES)
			return glTexCoord2bOES(s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2bvOES(const GLbyte* coords) {
		#if defined(glTexCoord2bvOES)
			return glTexCoord2bvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2d(GLdouble s, GLdouble t) {
		#if defined(glTexCoord2d)
			return glTexCoord2d(s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2dv(const GLdouble* v) {
		#if defined(glTexCoord2dv)
			return glTexCoord2dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2f(GLfloat s, GLfloat t) {
		#if defined(glTexCoord2f)
			return glTexCoord2f(s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glTexCoord2fColor3fVertex3fSUN)
			return glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fColor3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fColor3fVertex3fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* v) {
		#if defined(glTexCoord2fColor3fVertex3fvSUN)
			return glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fColor3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glTexCoord2fColor4fNormal3fVertex3fSUN)
			return glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fColor4fNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) {
		#if defined(glTexCoord2fColor4fNormal3fVertex3fvSUN)
			return glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fColor4fNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glTexCoord2fColor4ubVertex3fSUN)
			return glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fColor4ubVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fColor4ubVertex3fvSUN(const GLfloat* tc, const GLubyte* c, const GLfloat* v) {
		#if defined(glTexCoord2fColor4ubVertex3fvSUN)
			return glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fColor4ubVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glTexCoord2fNormal3fVertex3fSUN)
			return glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fNormal3fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fNormal3fVertex3fvSUN(const GLfloat* tc, const GLfloat* n, const GLfloat* v) {
		#if defined(glTexCoord2fNormal3fVertex3fvSUN)
			return glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fNormal3fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glTexCoord2fVertex3fSUN)
			return glTexCoord2fVertex3fSUN(s, t, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fVertex3fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fVertex3fvSUN(const GLfloat* tc, const GLfloat* v) {
		#if defined(glTexCoord2fVertex3fvSUN)
			return glTexCoord2fVertex3fvSUN(tc, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fVertex3fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2fv(const GLfloat* v) {
		#if defined(glTexCoord2fv)
			return glTexCoord2fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2hNV(GLhalfNV s, GLhalfNV t) {
		#if defined(glTexCoord2hNV)
			return glTexCoord2hNV(s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2hvNV(const GLhalfNV* v) {
		#if defined(glTexCoord2hvNV)
			return glTexCoord2hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2i(GLint s, GLint t) {
		#if defined(glTexCoord2i)
			return glTexCoord2i(s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2iv(const GLint* v) {
		#if defined(glTexCoord2iv)
			return glTexCoord2iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2s(GLshort s, GLshort t) {
		#if defined(glTexCoord2s)
			return glTexCoord2s(s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2sv(const GLshort* v) {
		#if defined(glTexCoord2sv)
			return glTexCoord2sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2xOES(GLfixed s, GLfixed t) {
		#if defined(glTexCoord2xOES)
			return glTexCoord2xOES(s, t);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord2xvOES(const GLfixed* coords) {
		#if defined(glTexCoord2xvOES)
			return glTexCoord2xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord2xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3bOES(GLbyte s, GLbyte t, GLbyte r) {
		#if defined(glTexCoord3bOES)
			return glTexCoord3bOES(s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3bvOES(const GLbyte* coords) {
		#if defined(glTexCoord3bvOES)
			return glTexCoord3bvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3d(GLdouble s, GLdouble t, GLdouble r) {
		#if defined(glTexCoord3d)
			return glTexCoord3d(s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3dv(const GLdouble* v) {
		#if defined(glTexCoord3dv)
			return glTexCoord3dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3f(GLfloat s, GLfloat t, GLfloat r) {
		#if defined(glTexCoord3f)
			return glTexCoord3f(s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3fv(const GLfloat* v) {
		#if defined(glTexCoord3fv)
			return glTexCoord3fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r) {
		#if defined(glTexCoord3hNV)
			return glTexCoord3hNV(s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3hvNV(const GLhalfNV* v) {
		#if defined(glTexCoord3hvNV)
			return glTexCoord3hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3i(GLint s, GLint t, GLint r) {
		#if defined(glTexCoord3i)
			return glTexCoord3i(s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3iv(const GLint* v) {
		#if defined(glTexCoord3iv)
			return glTexCoord3iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3s(GLshort s, GLshort t, GLshort r) {
		#if defined(glTexCoord3s)
			return glTexCoord3s(s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3sv(const GLshort* v) {
		#if defined(glTexCoord3sv)
			return glTexCoord3sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3xOES(GLfixed s, GLfixed t, GLfixed r) {
		#if defined(glTexCoord3xOES)
			return glTexCoord3xOES(s, t, r);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord3xvOES(const GLfixed* coords) {
		#if defined(glTexCoord3xvOES)
			return glTexCoord3xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord3xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4bOES(GLbyte s, GLbyte t, GLbyte r, GLbyte q) {
		#if defined(glTexCoord4bOES)
			return glTexCoord4bOES(s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4bvOES(const GLbyte* coords) {
		#if defined(glTexCoord4bvOES)
			return glTexCoord4bvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q) {
		#if defined(glTexCoord4d)
			return glTexCoord4d(s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4dv(const GLdouble* v) {
		#if defined(glTexCoord4dv)
			return glTexCoord4dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q) {
		#if defined(glTexCoord4f)
			return glTexCoord4f(s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glTexCoord4fColor4fNormal3fVertex4fSUN)
			return glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4fColor4fNormal3fVertex4fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat* tc, const GLfloat* c, const GLfloat* n, const GLfloat* v) {
		#if defined(glTexCoord4fColor4fNormal3fVertex4fvSUN)
			return glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4fColor4fNormal3fVertex4fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glTexCoord4fVertex4fSUN)
			return glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4fVertex4fSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4fVertex4fvSUN(const GLfloat* tc, const GLfloat* v) {
		#if defined(glTexCoord4fVertex4fvSUN)
			return glTexCoord4fVertex4fvSUN(tc, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4fVertex4fvSUN" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4fv(const GLfloat* v) {
		#if defined(glTexCoord4fv)
			return glTexCoord4fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q) {
		#if defined(glTexCoord4hNV)
			return glTexCoord4hNV(s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4hvNV(const GLhalfNV* v) {
		#if defined(glTexCoord4hvNV)
			return glTexCoord4hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4i(GLint s, GLint t, GLint r, GLint q) {
		#if defined(glTexCoord4i)
			return glTexCoord4i(s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4iv(const GLint* v) {
		#if defined(glTexCoord4iv)
			return glTexCoord4iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4s(GLshort s, GLshort t, GLshort r, GLshort q) {
		#if defined(glTexCoord4s)
			return glTexCoord4s(s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4sv(const GLshort* v) {
		#if defined(glTexCoord4sv)
			return glTexCoord4sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4xOES(GLfixed s, GLfixed t, GLfixed r, GLfixed q) {
		#if defined(glTexCoord4xOES)
			return glTexCoord4xOES(s, t, r, q);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoord4xvOES(const GLfixed* coords) {
		#if defined(glTexCoord4xvOES)
			return glTexCoord4xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoord4xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordFormatNV(GLint size, GLenum type, GLsizei stride) {
		#if defined(glTexCoordFormatNV)
			return glTexCoordFormatNV(size, type, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP1ui(enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glTexCoordP1ui)
			return glTexCoordP1ui(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP1ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP1uiv(enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glTexCoordP1uiv)
			return glTexCoordP1uiv(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP1uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP2ui(enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glTexCoordP2ui)
			return glTexCoordP2ui(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP2ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP2uiv(enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glTexCoordP2uiv)
			return glTexCoordP2uiv(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP2uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP3ui(enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glTexCoordP3ui)
			return glTexCoordP3ui(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP3uiv(enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glTexCoordP3uiv)
			return glTexCoordP3uiv(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP4ui(enums::TexCoordPointerType type, GLuint coords) {
		#if defined(glTexCoordP4ui)
			return glTexCoordP4ui(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordP4uiv(enums::TexCoordPointerType type, const GLuint* coords) {
		#if defined(glTexCoordP4uiv)
			return glTexCoordP4uiv(static_cast<GLenum>(type), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordP4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordPointer(GLint size, enums::TexCoordPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glTexCoordPointer)
			return glTexCoordPointer(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordPointerEXT(GLint size, enums::TexCoordPointerType type, GLsizei stride, GLsizei count, const void * pointer) {
		#if defined(glTexCoordPointerEXT)
			return glTexCoordPointerEXT(size, static_cast<GLenum>(type), stride, count, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordPointerListIBM(GLint size, enums::TexCoordPointerType type, GLint stride, const void ** pointer, GLint ptrstride) {
		#if defined(glTexCoordPointerListIBM)
			return glTexCoordPointerListIBM(size, static_cast<GLenum>(type), stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texCoordPointervINTEL(GLint size, enums::VertexPointerType type, const void ** pointer) {
		#if defined(glTexCoordPointervINTEL)
			return glTexCoordPointervINTEL(size, static_cast<GLenum>(type), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexCoordPointervINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnvf(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfloat param) {
		#if defined(glTexEnvf)
			return glTexEnvf(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnvf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnvfv(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, const GLfloat* params) {
		#if defined(glTexEnvfv)
			return glTexEnvfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnvfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnvi(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLint param) {
		#if defined(glTexEnvi)
			return glTexEnvi(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnvi" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnviv(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, const GLint* params) {
		#if defined(glTexEnviv)
			return glTexEnviv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnviv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnvx(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfixed param) {
		#if defined(glTexEnvx)
			return glTexEnvx(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnvx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnvxOES(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, GLfixed param) {
		#if defined(glTexEnvxOES)
			return glTexEnvxOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnvxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnvxv(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, const GLfixed* params) {
		#if defined(glTexEnvxv)
			return glTexEnvxv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnvxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEnvxvOES(enums::TextureEnvTarget target, enums::TextureEnvParameter pname, const GLfixed* params) {
		#if defined(glTexEnvxvOES)
			return glTexEnvxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEnvxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEstimateMotionQCOM(GLuint ref, GLuint target, GLuint output) {
		#if defined(glTexEstimateMotionQCOM)
			return glTexEstimateMotionQCOM(ref, target, output);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEstimateMotionQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texEstimateMotionRegionsQCOM(GLuint ref, GLuint target, GLuint output, GLuint mask) {
		#if defined(glTexEstimateMotionRegionsQCOM)
			return glTexEstimateMotionRegionsQCOM(ref, target, output, mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexEstimateMotionRegionsQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void extrapolateTex2DQCOM(GLuint src1, GLuint src2, GLuint output, GLfloat scaleFactor) {
		#if defined(glExtrapolateTex2DQCOM)
			return glExtrapolateTex2DQCOM(src1, src2, output, scaleFactor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glExtrapolateTex2DQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texFilterFuncSGIS(enums::TextureTarget target, enums::TextureFilterSGIS filter, GLsizei n, const GLfloat* weights) {
		#if defined(glTexFilterFuncSGIS)
			return glTexFilterFuncSGIS(static_cast<GLenum>(target), static_cast<GLenum>(filter), n, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexFilterFuncSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGend(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLdouble param) {
		#if defined(glTexGend)
			return glTexGend(static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGend" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGendv(enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLdouble* params) {
		#if defined(glTexGendv)
			return glTexGendv(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGendv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGenf(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfloat param) {
		#if defined(glTexGenf)
			return glTexGenf(static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGenf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGenfOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfloat param) {
		#if defined(glTexGenfOES)
			return glTexGenfOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGenfOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGenfv(enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLfloat* params) {
		#if defined(glTexGenfv)
			return glTexGenfv(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGenfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGenfvOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLfloat* params) {
		#if defined(glTexGenfvOES)
			return glTexGenfvOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGenfvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGeni(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLint param) {
		#if defined(glTexGeni)
			return glTexGeni(static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGeni" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGeniOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLint param) {
		#if defined(glTexGeniOES)
			return glTexGeniOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGeniOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGeniv(enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLint* params) {
		#if defined(glTexGeniv)
			return glTexGeniv(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGeniv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGenivOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLint* params) {
		#if defined(glTexGenivOES)
			return glTexGenivOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGenivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGenxOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, GLfixed param) {
		#if defined(glTexGenxOES)
			return glTexGenxOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGenxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texGenxvOES(enums::TextureCoordName coord, enums::TextureGenParameter pname, const GLfixed* params) {
		#if defined(glTexGenxvOES)
			return glTexGenxvOES(static_cast<GLenum>(coord), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexGenxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage1D(enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexImage1D)
			return glTexImage1D(static_cast<GLenum>(target), level, internalformat, width, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage2D(enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexImage2D)
			return glTexImage2D(static_cast<GLenum>(target), level, internalformat, width, height, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage2DMultisample(enums::TextureTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
		#if defined(glTexImage2DMultisample)
			return glTexImage2DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage2DMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage2DMultisampleCoverageNV(enums::TextureTarget target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
		#if defined(glTexImage2DMultisampleCoverageNV)
			return glTexImage2DMultisampleCoverageNV(static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage2DMultisampleCoverageNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage3D(enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexImage3D)
			return glTexImage3D(static_cast<GLenum>(target), level, internalformat, width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage3DEXT(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexImage3DEXT)
			return glTexImage3DEXT(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage3DMultisample(enums::TextureTarget target, GLsizei samples, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
		#if defined(glTexImage3DMultisample)
			return glTexImage3DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height, depth, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage3DMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage3DMultisampleCoverageNV(enums::TextureTarget target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
		#if defined(glTexImage3DMultisampleCoverageNV)
			return glTexImage3DMultisampleCoverageNV(static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage3DMultisampleCoverageNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage3DOES(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexImage3DOES)
			return glTexImage3DOES(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage3DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texImage4DSGIS(enums::TextureTarget target, GLint level, enums::InternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexImage4DSGIS)
			return glTexImage4DSGIS(static_cast<GLenum>(target), level, static_cast<GLenum>(internalformat), width, height, depth, size4d, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexImage4DSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) {
		#if defined(glTexPageCommitmentARB)
			return glTexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexPageCommitmentARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texPageCommitmentEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) {
		#if defined(glTexPageCommitmentEXT)
			return glTexPageCommitmentEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexPageCommitmentEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texPageCommitmentMemNV(enums::TextureTarget target, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit) {
		#if defined(glTexPageCommitmentMemNV)
			return glTexPageCommitmentMemNV(static_cast<GLenum>(target), layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexPageCommitmentMemNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterIiv(enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glTexParameterIiv)
			return glTexParameterIiv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterIiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterIivEXT(enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glTexParameterIivEXT)
			return glTexParameterIivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterIivOES(enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glTexParameterIivOES)
			return glTexParameterIivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterIivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterIuiv(enums::TextureTarget target, enums::TextureParameterName pname, const GLuint* params) {
		#if defined(glTexParameterIuiv)
			return glTexParameterIuiv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterIuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterIuivEXT(enums::TextureTarget target, enums::TextureParameterName pname, const GLuint* params) {
		#if defined(glTexParameterIuivEXT)
			return glTexParameterIuivEXT(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterIuivOES(enums::TextureTarget target, enums::TextureParameterName pname, const GLuint* params) {
		#if defined(glTexParameterIuivOES)
			return glTexParameterIuivOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterIuivOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterf(enums::TextureTarget target, enums::TextureParameterName pname, GLfloat param) {
		#if defined(glTexParameterf)
			return glTexParameterf(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterfv(enums::TextureTarget target, enums::TextureParameterName pname, const GLfloat* params) {
		#if defined(glTexParameterfv)
			return glTexParameterfv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameteri(enums::TextureTarget target, enums::TextureParameterName pname, GLint param) {
		#if defined(glTexParameteri)
			return glTexParameteri(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameteriv(enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glTexParameteriv)
			return glTexParameteriv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterx(enums::TextureTarget target, enums::GetTextureParameter pname, GLfixed param) {
		#if defined(glTexParameterx)
			return glTexParameterx(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterx" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterxOES(enums::TextureTarget target, enums::GetTextureParameter pname, GLfixed param) {
		#if defined(glTexParameterxOES)
			return glTexParameterxOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterxOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterxv(enums::TextureTarget target, enums::GetTextureParameter pname, const GLfixed* params) {
		#if defined(glTexParameterxv)
			return glTexParameterxv(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterxv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texParameterxvOES(enums::TextureTarget target, enums::GetTextureParameter pname, const GLfixed* params) {
		#if defined(glTexParameterxvOES)
			return glTexParameterxvOES(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexParameterxvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texRenderbufferNV(enums::TextureTarget target, GLuint renderbuffer) {
		#if defined(glTexRenderbufferNV)
			return glTexRenderbufferNV(static_cast<GLenum>(target), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexRenderbufferNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage1D(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width) {
		#if defined(glTexStorage1D)
			return glTexStorage1D(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage1DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width) {
		#if defined(glTexStorage1DEXT)
			return glTexStorage1DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage2D(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glTexStorage2D)
			return glTexStorage2D(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage2DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glTexStorage2DEXT)
			return glTexStorage2DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage2DMultisample(enums::TextureTarget target, GLsizei samples, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
		#if defined(glTexStorage2DMultisample)
			return glTexStorage2DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage2DMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage3D(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth) {
		#if defined(glTexStorage3D)
			return glTexStorage3D(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage3DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth) {
		#if defined(glTexStorage3DEXT)
			return glTexStorage3DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage3DMultisample(enums::TextureTarget target, GLsizei samples, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
		#if defined(glTexStorage3DMultisample)
			return glTexStorage3DMultisample(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height, depth, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage3DMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorage3DMultisampleOES(enums::TextureTarget target, GLsizei samples, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
		#if defined(glTexStorage3DMultisampleOES)
			return glTexStorage3DMultisampleOES(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height, depth, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorage3DMultisampleOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageAttribs2DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, const GLint* attrib_list) {
		#if defined(glTexStorageAttribs2DEXT)
			return glTexStorageAttribs2DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height, attrib_list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageAttribs2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageAttribs3DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, const GLint* attrib_list) {
		#if defined(glTexStorageAttribs3DEXT)
			return glTexStorageAttribs3DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalformat), width, height, depth, attrib_list);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageAttribs3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageMem1DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalFormat, GLsizei width, GLuint memory, GLuint64 offset) {
		#if defined(glTexStorageMem1DEXT)
			return glTexStorageMem1DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalFormat), width, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageMem1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageMem2DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset) {
		#if defined(glTexStorageMem2DEXT)
			return glTexStorageMem2DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalFormat), width, height, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageMem2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageMem2DMultisampleEXT(enums::TextureTarget target, GLsizei samples, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset) {
		#if defined(glTexStorageMem2DMultisampleEXT)
			return glTexStorageMem2DMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalFormat), width, height, fixedSampleLocations, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageMem2DMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageMem3DEXT(enums::TextureTarget target, GLsizei levels, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset) {
		#if defined(glTexStorageMem3DEXT)
			return glTexStorageMem3DEXT(static_cast<GLenum>(target), levels, static_cast<GLenum>(internalFormat), width, height, depth, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageMem3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageMem3DMultisampleEXT(enums::TextureTarget target, GLsizei samples, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset) {
		#if defined(glTexStorageMem3DMultisampleEXT)
			return glTexStorageMem3DMultisampleEXT(static_cast<GLenum>(target), samples, static_cast<GLenum>(internalFormat), width, height, depth, fixedSampleLocations, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageMem3DMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texStorageSparseAMD(enums::TextureTarget target, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) {
		#if defined(glTexStorageSparseAMD)
			return glTexStorageSparseAMD(static_cast<GLenum>(target), static_cast<GLenum>(internalFormat), width, height, depth, layers, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexStorageSparseAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage1D(enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage1D)
			return glTexSubImage1D(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage1DEXT(enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage1DEXT)
			return glTexSubImage1DEXT(static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage2D(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage2D)
			return glTexSubImage2D(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage2DEXT(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage2DEXT)
			return glTexSubImage2DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage3D(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage3D)
			return glTexSubImage3D(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage3DEXT(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage3DEXT)
			return glTexSubImage3DEXT(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage3DOES(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage3DOES)
			return glTexSubImage3DOES(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage3DOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texSubImage4DSGIS(enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTexSubImage4DSGIS)
			return glTexSubImage4DSGIS(static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexSubImage4DSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureAttachMemoryNV(GLuint texture, GLuint memory, GLuint64 offset) {
		#if defined(glTextureAttachMemoryNV)
			return glTextureAttachMemoryNV(texture, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureAttachMemoryNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureBarrier() {
		#if defined(glTextureBarrier)
			return glTextureBarrier();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureBarrier" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureBarrierNV() {
		#if defined(glTextureBarrierNV)
			return glTextureBarrierNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureBarrierNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureBuffer(GLuint texture, enums::SizedInternalFormat internalformat, GLuint buffer) {
		#if defined(glTextureBuffer)
			return glTextureBuffer(texture, static_cast<GLenum>(internalformat), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureBufferEXT(GLuint texture, enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer) {
		#if defined(glTextureBufferEXT)
			return glTextureBufferEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureBufferRange(GLuint texture, enums::SizedInternalFormat internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glTextureBufferRange)
			return glTextureBufferRange(texture, static_cast<GLenum>(internalformat), buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureBufferRangeEXT(GLuint texture, enums::TextureTarget target, enums::SizedInternalFormat internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glTextureBufferRangeEXT)
			return glTextureBufferRangeEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(internalformat), buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureBufferRangeEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
		#if defined(glTextureColorMaskSGIS)
			return glTextureColorMaskSGIS(red, green, blue, alpha);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureColorMaskSGIS" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureFoveationParametersQCOM(GLuint texture, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea) {
		#if defined(glTextureFoveationParametersQCOM)
			return glTextureFoveationParametersQCOM(texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureFoveationParametersQCOM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureImage1DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureImage1DEXT)
			return glTextureImage1DEXT(texture, static_cast<GLenum>(target), level, internalformat, width, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureImage2DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureImage2DEXT)
			return glTextureImage2DEXT(texture, static_cast<GLenum>(target), level, internalformat, width, height, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureImage2DMultisampleCoverageNV(GLuint texture, enums::TextureTarget target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
		#if defined(glTextureImage2DMultisampleCoverageNV)
			return glTextureImage2DMultisampleCoverageNV(texture, static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureImage2DMultisampleCoverageNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureImage2DMultisampleNV(GLuint texture, enums::TextureTarget target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations) {
		#if defined(glTextureImage2DMultisampleNV)
			return glTextureImage2DMultisampleNV(texture, static_cast<GLenum>(target), samples, internalFormat, width, height, fixedSampleLocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureImage2DMultisampleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureImage3DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureImage3DEXT)
			return glTextureImage3DEXT(texture, static_cast<GLenum>(target), level, internalformat, width, height, depth, border, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureImage3DMultisampleCoverageNV(GLuint texture, enums::TextureTarget target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
		#if defined(glTextureImage3DMultisampleCoverageNV)
			return glTextureImage3DMultisampleCoverageNV(texture, static_cast<GLenum>(target), coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureImage3DMultisampleCoverageNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureImage3DMultisampleNV(GLuint texture, enums::TextureTarget target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations) {
		#if defined(glTextureImage3DMultisampleNV)
			return glTextureImage3DMultisampleNV(texture, static_cast<GLenum>(target), samples, internalFormat, width, height, depth, fixedSampleLocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureImage3DMultisampleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureLightEXT(enums::LightTexturePNameEXT pname) {
		#if defined(glTextureLightEXT)
			return glTextureLightEXT(static_cast<GLenum>(pname));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureLightEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureMaterialEXT(enums::TriangleFace face, enums::MaterialParameter mode) {
		#if defined(glTextureMaterialEXT)
			return glTextureMaterialEXT(static_cast<GLenum>(face), static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureMaterialEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureNormalEXT(enums::TextureNormalModeEXT mode) {
		#if defined(glTextureNormalEXT)
			return glTextureNormalEXT(static_cast<GLenum>(mode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureNormalEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texturePageCommitmentEXT(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit) {
		#if defined(glTexturePageCommitmentEXT)
			return glTexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexturePageCommitmentEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void texturePageCommitmentMemNV(GLuint texture, GLint layer, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset, GLboolean commit) {
		#if defined(glTexturePageCommitmentMemNV)
			return glTexturePageCommitmentMemNV(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTexturePageCommitmentMemNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterIiv(GLuint texture, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glTextureParameterIiv)
			return glTextureParameterIiv(texture, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterIiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterIivEXT(GLuint texture, enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glTextureParameterIivEXT)
			return glTextureParameterIivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterIivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterIuiv(GLuint texture, enums::TextureParameterName pname, const GLuint* params) {
		#if defined(glTextureParameterIuiv)
			return glTextureParameterIuiv(texture, static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterIuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterIuivEXT(GLuint texture, enums::TextureTarget target, enums::TextureParameterName pname, const GLuint* params) {
		#if defined(glTextureParameterIuivEXT)
			return glTextureParameterIuivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterIuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterf(GLuint texture, enums::TextureParameterName pname, GLfloat param) {
		#if defined(glTextureParameterf)
			return glTextureParameterf(texture, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterfEXT(GLuint texture, enums::TextureTarget target, enums::TextureParameterName pname, GLfloat param) {
		#if defined(glTextureParameterfEXT)
			return glTextureParameterfEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterfv(GLuint texture, enums::TextureParameterName pname, const GLfloat* param) {
		#if defined(glTextureParameterfv)
			return glTextureParameterfv(texture, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterfvEXT(GLuint texture, enums::TextureTarget target, enums::TextureParameterName pname, const GLfloat* params) {
		#if defined(glTextureParameterfvEXT)
			return glTextureParameterfvEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameteri(GLuint texture, enums::TextureParameterName pname, GLint param) {
		#if defined(glTextureParameteri)
			return glTextureParameteri(texture, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameteri" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameteriEXT(GLuint texture, enums::TextureTarget target, enums::TextureParameterName pname, GLint param) {
		#if defined(glTextureParameteriEXT)
			return glTextureParameteriEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameteriEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameteriv(GLuint texture, enums::TextureParameterName pname, const GLint* param) {
		#if defined(glTextureParameteriv)
			return glTextureParameteriv(texture, static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameteriv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureParameterivEXT(GLuint texture, enums::TextureTarget target, enums::TextureParameterName pname, const GLint* params) {
		#if defined(glTextureParameterivEXT)
			return glTextureParameterivEXT(texture, static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureParameterivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureRangeAPPLE(GLenum target, GLsizei length, const void * pointer) {
		#if defined(glTextureRangeAPPLE)
			return glTextureRangeAPPLE(target, length, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureRangeAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureRenderbufferEXT(GLuint texture, enums::TextureTarget target, GLuint renderbuffer) {
		#if defined(glTextureRenderbufferEXT)
			return glTextureRenderbufferEXT(texture, static_cast<GLenum>(target), renderbuffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureRenderbufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage1D(GLuint texture, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width) {
		#if defined(glTextureStorage1D)
			return glTextureStorage1D(texture, levels, static_cast<GLenum>(internalformat), width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width) {
		#if defined(glTextureStorage1DEXT)
			return glTextureStorage1DEXT(texture, target, levels, static_cast<GLenum>(internalformat), width);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage2D(GLuint texture, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glTextureStorage2D)
			return glTextureStorage2D(texture, levels, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height) {
		#if defined(glTextureStorage2DEXT)
			return glTextureStorage2DEXT(texture, target, levels, static_cast<GLenum>(internalformat), width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage2DMultisample(GLuint texture, GLsizei samples, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
		#if defined(glTextureStorage2DMultisample)
			return glTextureStorage2DMultisample(texture, samples, static_cast<GLenum>(internalformat), width, height, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage2DMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage2DMultisampleEXT(GLuint texture, enums::TextureTarget target, GLsizei samples, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
		#if defined(glTextureStorage2DMultisampleEXT)
			return glTextureStorage2DMultisampleEXT(texture, static_cast<GLenum>(target), samples, static_cast<GLenum>(internalformat), width, height, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage2DMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage3D(GLuint texture, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth) {
		#if defined(glTextureStorage3D)
			return glTextureStorage3D(texture, levels, static_cast<GLenum>(internalformat), width, height, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth) {
		#if defined(glTextureStorage3DEXT)
			return glTextureStorage3DEXT(texture, target, levels, static_cast<GLenum>(internalformat), width, height, depth);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage3DMultisample(GLuint texture, GLsizei samples, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
		#if defined(glTextureStorage3DMultisample)
			return glTextureStorage3DMultisample(texture, samples, static_cast<GLenum>(internalformat), width, height, depth, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage3DMultisample" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, enums::SizedInternalFormat internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
		#if defined(glTextureStorage3DMultisampleEXT)
			return glTextureStorage3DMultisampleEXT(texture, target, samples, static_cast<GLenum>(internalformat), width, height, depth, fixedsamplelocations);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorage3DMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorageMem1DEXT(GLuint texture, GLsizei levels, enums::SizedInternalFormat internalFormat, GLsizei width, GLuint memory, GLuint64 offset) {
		#if defined(glTextureStorageMem1DEXT)
			return glTextureStorageMem1DEXT(texture, levels, static_cast<GLenum>(internalFormat), width, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorageMem1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorageMem2DEXT(GLuint texture, GLsizei levels, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset) {
		#if defined(glTextureStorageMem2DEXT)
			return glTextureStorageMem2DEXT(texture, levels, static_cast<GLenum>(internalFormat), width, height, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorageMem2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorageMem2DMultisampleEXT(GLuint texture, GLsizei samples, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset) {
		#if defined(glTextureStorageMem2DMultisampleEXT)
			return glTextureStorageMem2DMultisampleEXT(texture, samples, static_cast<GLenum>(internalFormat), width, height, fixedSampleLocations, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorageMem2DMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorageMem3DEXT(GLuint texture, GLsizei levels, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset) {
		#if defined(glTextureStorageMem3DEXT)
			return glTextureStorageMem3DEXT(texture, levels, static_cast<GLenum>(internalFormat), width, height, depth, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorageMem3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorageMem3DMultisampleEXT(GLuint texture, GLsizei samples, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset) {
		#if defined(glTextureStorageMem3DMultisampleEXT)
			return glTextureStorageMem3DMultisampleEXT(texture, samples, static_cast<GLenum>(internalFormat), width, height, depth, fixedSampleLocations, memory, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorageMem3DMultisampleEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureStorageSparseAMD(GLuint texture, GLenum target, enums::SizedInternalFormat internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags) {
		#if defined(glTextureStorageSparseAMD)
			return glTextureStorageSparseAMD(texture, target, static_cast<GLenum>(internalFormat), width, height, depth, layers, flags);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureStorageSparseAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureSubImage1D)
			return glTextureSubImage1D(texture, level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureSubImage1D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureSubImage1DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLsizei width, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureSubImage1DEXT)
			return glTextureSubImage1DEXT(texture, static_cast<GLenum>(target), level, xoffset, width, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureSubImage1DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureSubImage2D)
			return glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureSubImage2D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureSubImage2DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureSubImage2DEXT)
			return glTextureSubImage2DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, width, height, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureSubImage2DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureSubImage3D)
			return glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureSubImage3D" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureSubImage3DEXT(GLuint texture, enums::TextureTarget target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, enums::PixelFormat format, enums::PixelType type, const void * pixels) {
		#if defined(glTextureSubImage3DEXT)
			return glTextureSubImage3DEXT(texture, static_cast<GLenum>(target), level, xoffset, yoffset, zoffset, width, height, depth, static_cast<GLenum>(format), static_cast<GLenum>(type), pixels);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureSubImage3DEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureView(GLuint texture, enums::TextureTarget target, GLuint origtexture, enums::SizedInternalFormat internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
		#if defined(glTextureView)
			return glTextureView(texture, static_cast<GLenum>(target), origtexture, static_cast<GLenum>(internalformat), minlevel, numlevels, minlayer, numlayers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureView" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureViewEXT(GLuint texture, enums::TextureTarget target, GLuint origtexture, enums::SizedInternalFormat internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
		#if defined(glTextureViewEXT)
			return glTextureViewEXT(texture, static_cast<GLenum>(target), origtexture, static_cast<GLenum>(internalformat), minlevel, numlevels, minlayer, numlayers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureViewEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void textureViewOES(GLuint texture, enums::TextureTarget target, GLuint origtexture, enums::SizedInternalFormat internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
		#if defined(glTextureViewOES)
			return glTextureViewOES(texture, static_cast<GLenum>(target), origtexture, static_cast<GLenum>(internalformat), minlevel, numlevels, minlayer, numlayers);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTextureViewOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void trackMatrixNV(enums::VertexAttribEnumNV target, GLuint address, enums::VertexAttribEnumNV matrix, enums::VertexAttribEnumNV transform) {
		#if defined(glTrackMatrixNV)
			return glTrackMatrixNV(static_cast<GLenum>(target), address, static_cast<GLenum>(matrix), static_cast<GLenum>(transform));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTrackMatrixNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformFeedbackAttribsNV(GLsizei count, const GLint* attribs, GLenum bufferMode) {
		#if defined(glTransformFeedbackAttribsNV)
			return glTransformFeedbackAttribsNV(count, attribs, bufferMode);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformFeedbackAttribsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer) {
		#if defined(glTransformFeedbackBufferBase)
			return glTransformFeedbackBufferBase(xfb, index, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformFeedbackBufferBase" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
		#if defined(glTransformFeedbackBufferRange)
			return glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformFeedbackBufferRange" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformFeedbackStreamAttribsNV(GLsizei count, const GLint* attribs, GLsizei nbuffers, const GLint* bufstreams, GLenum bufferMode) {
		#if defined(glTransformFeedbackStreamAttribsNV)
			return glTransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformFeedbackStreamAttribsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformFeedbackVaryings(GLuint program, GLsizei count, const GLchar*const* varyings, enums::TransformFeedbackBufferMode bufferMode) {
		#if defined(glTransformFeedbackVaryings)
			return glTransformFeedbackVaryings(program, count, varyings, static_cast<GLenum>(bufferMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformFeedbackVaryings" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar*const* varyings, enums::TransformFeedbackBufferMode bufferMode) {
		#if defined(glTransformFeedbackVaryingsEXT)
			return glTransformFeedbackVaryingsEXT(program, count, varyings, static_cast<GLenum>(bufferMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformFeedbackVaryingsEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint* locations, enums::TransformFeedbackBufferMode bufferMode) {
		#if defined(glTransformFeedbackVaryingsNV)
			return glTransformFeedbackVaryingsNV(program, count, locations, static_cast<GLenum>(bufferMode));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformFeedbackVaryingsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void transformPathNV(GLuint resultPath, GLuint srcPath, enums::PathTransformType transformType, const GLfloat* transformValues) {
		#if defined(glTransformPathNV)
			return glTransformPathNV(resultPath, srcPath, static_cast<GLenum>(transformType), transformValues);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTransformPathNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void translated(GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glTranslated)
			return glTranslated(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTranslated" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void translatef(GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glTranslatef)
			return glTranslatef(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTranslatef" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void translatex(GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glTranslatex)
			return glTranslatex(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTranslatex" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void translatexOES(GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glTranslatexOES)
			return glTranslatexOES(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glTranslatexOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1d(GLint location, GLdouble x) {
		#if defined(glUniform1d)
			return glUniform1d(location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1dv(GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glUniform1dv)
			return glUniform1dv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1f(GLint location, GLfloat v0) {
		#if defined(glUniform1f)
			return glUniform1f(location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1fARB(GLint location, GLfloat v0) {
		#if defined(glUniform1fARB)
			return glUniform1fARB(location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1fv(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform1fv)
			return glUniform1fv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1fvARB(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform1fvARB)
			return glUniform1fvARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1i(GLint location, GLint v0) {
		#if defined(glUniform1i)
			return glUniform1i(location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1i64ARB(GLint location, GLint64 x) {
		#if defined(glUniform1i64ARB)
			return glUniform1i64ARB(location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1i64NV(GLint location, GLint64EXT x) {
		#if defined(glUniform1i64NV)
			return glUniform1i64NV(location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1i64vARB(GLint location, GLsizei count, const GLint64* value) {
		#if defined(glUniform1i64vARB)
			return glUniform1i64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1i64vNV(GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glUniform1i64vNV)
			return glUniform1i64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1iARB(GLint location, GLint v0) {
		#if defined(glUniform1iARB)
			return glUniform1iARB(location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1iv(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform1iv)
			return glUniform1iv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1ivARB(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform1ivARB)
			return glUniform1ivARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1ui(GLint location, GLuint v0) {
		#if defined(glUniform1ui)
			return glUniform1ui(location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1ui64ARB(GLint location, GLuint64 x) {
		#if defined(glUniform1ui64ARB)
			return glUniform1ui64ARB(location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1ui64NV(GLint location, GLuint64EXT x) {
		#if defined(glUniform1ui64NV)
			return glUniform1ui64NV(location, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1ui64vARB(GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glUniform1ui64vARB)
			return glUniform1ui64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glUniform1ui64vNV)
			return glUniform1ui64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1uiEXT(GLint location, GLuint v0) {
		#if defined(glUniform1uiEXT)
			return glUniform1uiEXT(location, v0);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1uiv(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform1uiv)
			return glUniform1uiv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform1uivEXT(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform1uivEXT)
			return glUniform1uivEXT(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform1uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2d(GLint location, GLdouble x, GLdouble y) {
		#if defined(glUniform2d)
			return glUniform2d(location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2dv(GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glUniform2dv)
			return glUniform2dv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2f(GLint location, GLfloat v0, GLfloat v1) {
		#if defined(glUniform2f)
			return glUniform2f(location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2fARB(GLint location, GLfloat v0, GLfloat v1) {
		#if defined(glUniform2fARB)
			return glUniform2fARB(location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2fv(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform2fv)
			return glUniform2fv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2fvARB(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform2fvARB)
			return glUniform2fvARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2i(GLint location, GLint v0, GLint v1) {
		#if defined(glUniform2i)
			return glUniform2i(location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2i64ARB(GLint location, GLint64 x, GLint64 y) {
		#if defined(glUniform2i64ARB)
			return glUniform2i64ARB(location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y) {
		#if defined(glUniform2i64NV)
			return glUniform2i64NV(location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2i64vARB(GLint location, GLsizei count, const GLint64* value) {
		#if defined(glUniform2i64vARB)
			return glUniform2i64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2i64vNV(GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glUniform2i64vNV)
			return glUniform2i64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2iARB(GLint location, GLint v0, GLint v1) {
		#if defined(glUniform2iARB)
			return glUniform2iARB(location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2iv(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform2iv)
			return glUniform2iv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2ivARB(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform2ivARB)
			return glUniform2ivARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2ui(GLint location, GLuint v0, GLuint v1) {
		#if defined(glUniform2ui)
			return glUniform2ui(location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2ui64ARB(GLint location, GLuint64 x, GLuint64 y) {
		#if defined(glUniform2ui64ARB)
			return glUniform2ui64ARB(location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y) {
		#if defined(glUniform2ui64NV)
			return glUniform2ui64NV(location, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2ui64vARB(GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glUniform2ui64vARB)
			return glUniform2ui64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glUniform2ui64vNV)
			return glUniform2ui64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2uiEXT(GLint location, GLuint v0, GLuint v1) {
		#if defined(glUniform2uiEXT)
			return glUniform2uiEXT(location, v0, v1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2uiv(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform2uiv)
			return glUniform2uiv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform2uivEXT(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform2uivEXT)
			return glUniform2uivEXT(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform2uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glUniform3d)
			return glUniform3d(location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3dv(GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glUniform3dv)
			return glUniform3dv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
		#if defined(glUniform3f)
			return glUniform3f(location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
		#if defined(glUniform3fARB)
			return glUniform3fARB(location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3fv(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform3fv)
			return glUniform3fv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3fvARB(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform3fvARB)
			return glUniform3fvARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3i(GLint location, GLint v0, GLint v1, GLint v2) {
		#if defined(glUniform3i)
			return glUniform3i(location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z) {
		#if defined(glUniform3i64ARB)
			return glUniform3i64ARB(location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
		#if defined(glUniform3i64NV)
			return glUniform3i64NV(location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3i64vARB(GLint location, GLsizei count, const GLint64* value) {
		#if defined(glUniform3i64vARB)
			return glUniform3i64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3i64vNV(GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glUniform3i64vNV)
			return glUniform3i64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3iARB(GLint location, GLint v0, GLint v1, GLint v2) {
		#if defined(glUniform3iARB)
			return glUniform3iARB(location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3iv(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform3iv)
			return glUniform3iv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3ivARB(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform3ivARB)
			return glUniform3ivARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2) {
		#if defined(glUniform3ui)
			return glUniform3ui(location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z) {
		#if defined(glUniform3ui64ARB)
			return glUniform3ui64ARB(location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
		#if defined(glUniform3ui64NV)
			return glUniform3ui64NV(location, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3ui64vARB(GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glUniform3ui64vARB)
			return glUniform3ui64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glUniform3ui64vNV)
			return glUniform3ui64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2) {
		#if defined(glUniform3uiEXT)
			return glUniform3uiEXT(location, v0, v1, v2);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3uiv(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform3uiv)
			return glUniform3uiv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform3uivEXT(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform3uivEXT)
			return glUniform3uivEXT(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform3uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glUniform4d)
			return glUniform4d(location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4dv(GLint location, GLsizei count, const GLdouble* value) {
		#if defined(glUniform4dv)
			return glUniform4dv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
		#if defined(glUniform4f)
			return glUniform4f(location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
		#if defined(glUniform4fARB)
			return glUniform4fARB(location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4fv(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform4fv)
			return glUniform4fv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4fvARB(GLint location, GLsizei count, const GLfloat* value) {
		#if defined(glUniform4fvARB)
			return glUniform4fvARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
		#if defined(glUniform4i)
			return glUniform4i(location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4i64ARB(GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w) {
		#if defined(glUniform4i64ARB)
			return glUniform4i64ARB(location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4i64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
		#if defined(glUniform4i64NV)
			return glUniform4i64NV(location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4i64vARB(GLint location, GLsizei count, const GLint64* value) {
		#if defined(glUniform4i64vARB)
			return glUniform4i64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4i64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4i64vNV(GLint location, GLsizei count, const GLint64EXT* value) {
		#if defined(glUniform4i64vNV)
			return glUniform4i64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
		#if defined(glUniform4iARB)
			return glUniform4iARB(location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4iv(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform4iv)
			return glUniform4iv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4ivARB(GLint location, GLsizei count, const GLint* value) {
		#if defined(glUniform4ivARB)
			return glUniform4ivARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
		#if defined(glUniform4ui)
			return glUniform4ui(location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4ui64ARB(GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w) {
		#if defined(glUniform4ui64ARB)
			return glUniform4ui64ARB(location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
		#if defined(glUniform4ui64NV)
			return glUniform4ui64NV(location, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4ui64vARB(GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glUniform4ui64vARB)
			return glUniform4ui64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glUniform4ui64vNV)
			return glUniform4ui64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
		#if defined(glUniform4uiEXT)
			return glUniform4uiEXT(location, v0, v1, v2, v3);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4uiv(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform4uiv)
			return glUniform4uiv(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniform4uivEXT(GLint location, GLsizei count, const GLuint* value) {
		#if defined(glUniform4uivEXT)
			return glUniform4uivEXT(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniform4uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) {
		#if defined(glUniformBlockBinding)
			return glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformBlockBinding" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformBufferEXT(GLuint program, GLint location, GLuint buffer) {
		#if defined(glUniformBufferEXT)
			return glUniformBufferEXT(program, location, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformHandleui64ARB(GLint location, GLuint64 value) {
		#if defined(glUniformHandleui64ARB)
			return glUniformHandleui64ARB(location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformHandleui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformHandleui64IMG(GLint location, GLuint64 value) {
		#if defined(glUniformHandleui64IMG)
			return glUniformHandleui64IMG(location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformHandleui64IMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformHandleui64NV(GLint location, GLuint64 value) {
		#if defined(glUniformHandleui64NV)
			return glUniformHandleui64NV(location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformHandleui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformHandleui64vARB(GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glUniformHandleui64vARB)
			return glUniformHandleui64vARB(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformHandleui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformHandleui64vIMG(GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glUniformHandleui64vIMG)
			return glUniformHandleui64vIMG(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformHandleui64vIMG" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformHandleui64vNV(GLint location, GLsizei count, const GLuint64* value) {
		#if defined(glUniformHandleui64vNV)
			return glUniformHandleui64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformHandleui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix2dv)
			return glUniformMatrix2dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix2fv)
			return glUniformMatrix2fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix2fvARB)
			return glUniformMatrix2fvARB(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix2x3dv)
			return glUniformMatrix2x3dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2x3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix2x3fv)
			return glUniformMatrix2x3fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2x3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix2x3fvNV)
			return glUniformMatrix2x3fvNV(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2x3fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix2x4dv)
			return glUniformMatrix2x4dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2x4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix2x4fv)
			return glUniformMatrix2x4fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2x4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix2x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix2x4fvNV)
			return glUniformMatrix2x4fvNV(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix2x4fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix3dv)
			return glUniformMatrix3dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix3fv)
			return glUniformMatrix3fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix3fvARB)
			return glUniformMatrix3fvARB(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix3x2dv)
			return glUniformMatrix3x2dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3x2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix3x2fv)
			return glUniformMatrix3x2fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3x2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix3x2fvNV)
			return glUniformMatrix3x2fvNV(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3x2fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix3x4dv)
			return glUniformMatrix3x4dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3x4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix3x4fv)
			return glUniformMatrix3x4fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3x4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix3x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix3x4fvNV)
			return glUniformMatrix3x4fvNV(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix3x4fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix4dv)
			return glUniformMatrix4dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix4fv)
			return glUniformMatrix4fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix4fvARB)
			return glUniformMatrix4fvARB(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix4x2dv)
			return glUniformMatrix4x2dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4x2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix4x2fv)
			return glUniformMatrix4x2fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4x2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix4x2fvNV)
			return glUniformMatrix4x2fvNV(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4x2fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble* value) {
		#if defined(glUniformMatrix4x3dv)
			return glUniformMatrix4x3dv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4x3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix4x3fv)
			return glUniformMatrix4x3fv(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4x3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformMatrix4x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
		#if defined(glUniformMatrix4x3fvNV)
			return glUniformMatrix4x3fvNV(location, count, transpose, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformMatrix4x3fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformSubroutinesuiv(enums::ShaderType shadertype, GLsizei count, const GLuint* indices) {
		#if defined(glUniformSubroutinesuiv)
			return glUniformSubroutinesuiv(static_cast<GLenum>(shadertype), count, indices);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformSubroutinesuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformui64NV(GLint location, GLuint64EXT value) {
		#if defined(glUniformui64NV)
			return glUniformui64NV(location, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uniformui64vNV(GLint location, GLsizei count, const GLuint64EXT* value) {
		#if defined(glUniformui64vNV)
			return glUniformui64vNV(location, count, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUniformui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void unlockArraysEXT() {
		#if defined(glUnlockArraysEXT)
			return glUnlockArraysEXT();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnlockArraysEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean unmapBuffer(enums::BufferTargetARB target) {
		#if defined(glUnmapBuffer)
			return glUnmapBuffer(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnmapBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean unmapBufferARB(enums::BufferTargetARB target) {
		#if defined(glUnmapBufferARB)
			return glUnmapBufferARB(static_cast<GLenum>(target));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnmapBufferARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean unmapBufferOES(GLenum target) {
		#if defined(glUnmapBufferOES)
			return glUnmapBufferOES(target);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnmapBufferOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean unmapNamedBuffer(GLuint buffer) {
		#if defined(glUnmapNamedBuffer)
			return glUnmapNamedBuffer(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnmapNamedBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLboolean unmapNamedBufferEXT(GLuint buffer) {
		#if defined(glUnmapNamedBufferEXT)
			return glUnmapNamedBufferEXT(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnmapNamedBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void unmapObjectBufferATI(GLuint buffer) {
		#if defined(glUnmapObjectBufferATI)
			return glUnmapObjectBufferATI(buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnmapObjectBufferATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void unmapTexture2DINTEL(GLuint texture, GLint level) {
		#if defined(glUnmapTexture2DINTEL)
			return glUnmapTexture2DINTEL(texture, level);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUnmapTexture2DINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void updateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const void * pointer, enums::PreserveModeATI preserve) {
		#if defined(glUpdateObjectBufferATI)
			return glUpdateObjectBufferATI(buffer, offset, size, pointer, static_cast<GLenum>(preserve));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUpdateObjectBufferATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void uploadGpuMaskNVX(GLbitfield mask) {
		#if defined(glUploadGpuMaskNVX)
			return glUploadGpuMaskNVX(mask);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUploadGpuMaskNVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void useProgram(GLuint program) {
		#if defined(glUseProgram)
			return glUseProgram(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUseProgram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void useProgramObjectARB(GLhandleARB programObj) {
		#if defined(glUseProgramObjectARB)
			return glUseProgramObjectARB(programObj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUseProgramObjectARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void useProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) {
		#if defined(glUseProgramStages)
			return glUseProgramStages(pipeline, stages, program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUseProgramStages" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void useProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program) {
		#if defined(glUseProgramStagesEXT)
			return glUseProgramStagesEXT(pipeline, stages, program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUseProgramStagesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void useShaderProgramEXT(GLenum type, GLuint program) {
		#if defined(glUseShaderProgramEXT)
			return glUseShaderProgramEXT(type, program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glUseShaderProgramEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vDPAUFiniNV() {
		#if defined(glVDPAUFiniNV)
			return glVDPAUFiniNV();
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUFiniNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei count, GLsizei* length, GLint* values) {
		#if defined(glVDPAUGetSurfaceivNV)
			return glVDPAUGetSurfaceivNV(surface, pname, count, length, values);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUGetSurfaceivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vDPAUInitNV(const void * vdpDevice, const void * getProcAddress) {
		#if defined(glVDPAUInitNV)
			return glVDPAUInitNV(vdpDevice, getProcAddress);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUInitNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLboolean vDPAUIsSurfaceNV(GLvdpauSurfaceNV surface) {
		#if defined(glVDPAUIsSurfaceNV)
			return glVDPAUIsSurfaceNV(surface);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUIsSurfaceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void vDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces) {
		#if defined(glVDPAUMapSurfacesNV)
			return glVDPAUMapSurfacesNV(numSurfaces, surfaces);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUMapSurfacesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLvdpauSurfaceNV vDPAURegisterOutputSurfaceNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames) {
		#if defined(glVDPAURegisterOutputSurfaceNV)
			return glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAURegisterOutputSurfaceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLvdpauSurfaceNV vDPAURegisterVideoSurfaceNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames) {
		#if defined(glVDPAURegisterVideoSurfaceNV)
			return glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAURegisterVideoSurfaceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline GLvdpauSurfaceNV vDPAURegisterVideoSurfaceWithPictureStructureNV(const void * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint* textureNames, GLboolean isFrameStructure) {
		#if defined(glVDPAURegisterVideoSurfaceWithPictureStructureNV)
			return glVDPAURegisterVideoSurfaceWithPictureStructureNV(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAURegisterVideoSurfaceWithPictureStructureNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void vDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access) {
		#if defined(glVDPAUSurfaceAccessNV)
			return glVDPAUSurfaceAccessNV(surface, access);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUSurfaceAccessNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vDPAUUnmapSurfacesNV(GLsizei numSurface, const GLvdpauSurfaceNV* surfaces) {
		#if defined(glVDPAUUnmapSurfacesNV)
			return glVDPAUUnmapSurfacesNV(numSurface, surfaces);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUUnmapSurfacesNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface) {
		#if defined(glVDPAUUnregisterSurfaceNV)
			return glVDPAUUnregisterSurfaceNV(surface);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVDPAUUnregisterSurfaceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void validateProgram(GLuint program) {
		#if defined(glValidateProgram)
			return glValidateProgram(program);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glValidateProgram" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void validateProgramARB(GLhandleARB programObj) {
		#if defined(glValidateProgramARB)
			return glValidateProgramARB(programObj);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glValidateProgramARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void validateProgramPipeline(GLuint pipeline) {
		#if defined(glValidateProgramPipeline)
			return glValidateProgramPipeline(pipeline);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glValidateProgramPipeline" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void validateProgramPipelineEXT(GLuint pipeline) {
		#if defined(glValidateProgramPipelineEXT)
			return glValidateProgramPipelineEXT(pipeline);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glValidateProgramPipelineEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantArrayObjectATI(GLuint id, enums::ScalarType type, GLsizei stride, GLuint buffer, GLuint offset) {
		#if defined(glVariantArrayObjectATI)
			return glVariantArrayObjectATI(id, static_cast<GLenum>(type), stride, buffer, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantArrayObjectATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantPointerEXT(GLuint id, enums::ScalarType type, GLuint stride, const void * addr) {
		#if defined(glVariantPointerEXT)
			return glVariantPointerEXT(id, static_cast<GLenum>(type), stride, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantbvEXT(GLuint id, const GLbyte* addr) {
		#if defined(glVariantbvEXT)
			return glVariantbvEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantbvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantdvEXT(GLuint id, const GLdouble* addr) {
		#if defined(glVariantdvEXT)
			return glVariantdvEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantdvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantfvEXT(GLuint id, const GLfloat* addr) {
		#if defined(glVariantfvEXT)
			return glVariantfvEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantivEXT(GLuint id, const GLint* addr) {
		#if defined(glVariantivEXT)
			return glVariantivEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantsvEXT(GLuint id, const GLshort* addr) {
		#if defined(glVariantsvEXT)
			return glVariantsvEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantsvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantubvEXT(GLuint id, const GLubyte* addr) {
		#if defined(glVariantubvEXT)
			return glVariantubvEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantubvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantuivEXT(GLuint id, const GLuint* addr) {
		#if defined(glVariantuivEXT)
			return glVariantuivEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantuivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void variantusvEXT(GLuint id, const GLushort* addr) {
		#if defined(glVariantusvEXT)
			return glVariantusvEXT(id, addr);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVariantusvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2bOES(GLbyte x, GLbyte y) {
		#if defined(glVertex2bOES)
			return glVertex2bOES(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2bvOES(const GLbyte* coords) {
		#if defined(glVertex2bvOES)
			return glVertex2bvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2d(GLdouble x, GLdouble y) {
		#if defined(glVertex2d)
			return glVertex2d(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2dv(const GLdouble* v) {
		#if defined(glVertex2dv)
			return glVertex2dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2f(GLfloat x, GLfloat y) {
		#if defined(glVertex2f)
			return glVertex2f(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2fv(const GLfloat* v) {
		#if defined(glVertex2fv)
			return glVertex2fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2hNV(GLhalfNV x, GLhalfNV y) {
		#if defined(glVertex2hNV)
			return glVertex2hNV(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2hvNV(const GLhalfNV* v) {
		#if defined(glVertex2hvNV)
			return glVertex2hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2i(GLint x, GLint y) {
		#if defined(glVertex2i)
			return glVertex2i(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2iv(const GLint* v) {
		#if defined(glVertex2iv)
			return glVertex2iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2s(GLshort x, GLshort y) {
		#if defined(glVertex2s)
			return glVertex2s(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2sv(const GLshort* v) {
		#if defined(glVertex2sv)
			return glVertex2sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2xOES(GLfixed x) {
		#if defined(glVertex2xOES)
			return glVertex2xOES(x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex2xvOES(const GLfixed* coords) {
		#if defined(glVertex2xvOES)
			return glVertex2xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex2xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3bOES(GLbyte x, GLbyte y, GLbyte z) {
		#if defined(glVertex3bOES)
			return glVertex3bOES(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3bvOES(const GLbyte* coords) {
		#if defined(glVertex3bvOES)
			return glVertex3bvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3d(GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glVertex3d)
			return glVertex3d(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3dv(const GLdouble* v) {
		#if defined(glVertex3dv)
			return glVertex3dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3f(GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glVertex3f)
			return glVertex3f(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3fv(const GLfloat* v) {
		#if defined(glVertex3fv)
			return glVertex3fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z) {
		#if defined(glVertex3hNV)
			return glVertex3hNV(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3hvNV(const GLhalfNV* v) {
		#if defined(glVertex3hvNV)
			return glVertex3hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3i(GLint x, GLint y, GLint z) {
		#if defined(glVertex3i)
			return glVertex3i(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3iv(const GLint* v) {
		#if defined(glVertex3iv)
			return glVertex3iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3s(GLshort x, GLshort y, GLshort z) {
		#if defined(glVertex3s)
			return glVertex3s(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3sv(const GLshort* v) {
		#if defined(glVertex3sv)
			return glVertex3sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3xOES(GLfixed x, GLfixed y) {
		#if defined(glVertex3xOES)
			return glVertex3xOES(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex3xvOES(const GLfixed* coords) {
		#if defined(glVertex3xvOES)
			return glVertex3xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex3xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4bOES(GLbyte x, GLbyte y, GLbyte z, GLbyte w) {
		#if defined(glVertex4bOES)
			return glVertex4bOES(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4bOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4bvOES(const GLbyte* coords) {
		#if defined(glVertex4bvOES)
			return glVertex4bvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4bvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glVertex4d)
			return glVertex4d(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4dv(const GLdouble* v) {
		#if defined(glVertex4dv)
			return glVertex4dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glVertex4f)
			return glVertex4f(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4fv(const GLfloat* v) {
		#if defined(glVertex4fv)
			return glVertex4fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
		#if defined(glVertex4hNV)
			return glVertex4hNV(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4hvNV(const GLhalfNV* v) {
		#if defined(glVertex4hvNV)
			return glVertex4hvNV(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4i(GLint x, GLint y, GLint z, GLint w) {
		#if defined(glVertex4i)
			return glVertex4i(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4iv(const GLint* v) {
		#if defined(glVertex4iv)
			return glVertex4iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4s(GLshort x, GLshort y, GLshort z, GLshort w) {
		#if defined(glVertex4s)
			return glVertex4s(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4sv(const GLshort* v) {
		#if defined(glVertex4sv)
			return glVertex4sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4xOES(GLfixed x, GLfixed y, GLfixed z) {
		#if defined(glVertex4xOES)
			return glVertex4xOES(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4xOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertex4xvOES(const GLfixed* coords) {
		#if defined(glVertex4xvOES)
			return glVertex4xvOES(coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertex4xvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
		#if defined(glVertexArrayAttribBinding)
			return glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayAttribBinding" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, enums::VertexAttribType type, GLboolean normalized, GLuint relativeoffset) {
		#if defined(glVertexArrayAttribFormat)
			return glVertexArrayAttribFormat(vaobj, attribindex, size, static_cast<GLenum>(type), normalized, relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayAttribFormat" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, enums::VertexAttribIType type, GLuint relativeoffset) {
		#if defined(glVertexArrayAttribIFormat)
			return glVertexArrayAttribIFormat(vaobj, attribindex, size, static_cast<GLenum>(type), relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayAttribIFormat" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, enums::VertexAttribLType type, GLuint relativeoffset) {
		#if defined(glVertexArrayAttribLFormat)
			return glVertexArrayAttribLFormat(vaobj, attribindex, size, static_cast<GLenum>(type), relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayAttribLFormat" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
		#if defined(glVertexArrayBindVertexBufferEXT)
			return glVertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayBindVertexBufferEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
		#if defined(glVertexArrayBindingDivisor)
			return glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayBindingDivisor" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, enums::ColorPointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayColorOffsetEXT)
			return glVertexArrayColorOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayColorOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayEdgeFlagOffsetEXT)
			return glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayEdgeFlagOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayElementBuffer(GLuint vaobj, GLuint buffer) {
		#if defined(glVertexArrayElementBuffer)
			return glVertexArrayElementBuffer(vaobj, buffer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayElementBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, enums::FogCoordinatePointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayFogCoordOffsetEXT)
			return glVertexArrayFogCoordOffsetEXT(vaobj, buffer, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayFogCoordOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, enums::IndexPointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayIndexOffsetEXT)
			return glVertexArrayIndexOffsetEXT(vaobj, buffer, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayIndexOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, enums::TexCoordPointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayMultiTexCoordOffsetEXT)
			return glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayMultiTexCoordOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, enums::NormalPointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayNormalOffsetEXT)
			return glVertexArrayNormalOffsetEXT(vaobj, buffer, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayNormalOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayParameteriAPPLE(enums::VertexArrayPNameAPPLE pname, GLint param) {
		#if defined(glVertexArrayParameteriAPPLE)
			return glVertexArrayParameteriAPPLE(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayParameteriAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayRangeAPPLE(GLsizei length, void * pointer) {
		#if defined(glVertexArrayRangeAPPLE)
			return glVertexArrayRangeAPPLE(length, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayRangeAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayRangeNV(GLsizei length, const void * pointer) {
		#if defined(glVertexArrayRangeNV)
			return glVertexArrayRangeNV(length, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayRangeNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, enums::ColorPointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArraySecondaryColorOffsetEXT)
			return glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArraySecondaryColorOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, enums::TexCoordPointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayTexCoordOffsetEXT)
			return glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayTexCoordOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
		#if defined(glVertexArrayVertexAttribBindingEXT)
			return glVertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribBindingEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribDivisorEXT(GLuint vaobj, GLuint index, GLuint divisor) {
		#if defined(glVertexArrayVertexAttribDivisorEXT)
			return glVertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribDivisorEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, enums::VertexAttribType type, GLboolean normalized, GLuint relativeoffset) {
		#if defined(glVertexArrayVertexAttribFormatEXT)
			return glVertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, static_cast<GLenum>(type), normalized, relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribFormatEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, enums::VertexAttribIType type, GLuint relativeoffset) {
		#if defined(glVertexArrayVertexAttribIFormatEXT)
			return glVertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, static_cast<GLenum>(type), relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribIFormatEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, enums::VertexAttribType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayVertexAttribIOffsetEXT)
			return glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribIOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, enums::VertexAttribLType type, GLuint relativeoffset) {
		#if defined(glVertexArrayVertexAttribLFormatEXT)
			return glVertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, static_cast<GLenum>(type), relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribLFormatEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, enums::VertexAttribLType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayVertexAttribLOffsetEXT)
			return glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribLOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, enums::VertexAttribPointerType type, GLboolean normalized, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayVertexAttribOffsetEXT)
			return glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, static_cast<GLenum>(type), normalized, stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexAttribOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
		#if defined(glVertexArrayVertexBindingDivisorEXT)
			return glVertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexBindingDivisorEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
		#if defined(glVertexArrayVertexBuffer)
			return glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexBuffer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr* offsets, const GLsizei* strides) {
		#if defined(glVertexArrayVertexBuffers)
			return glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexBuffers" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, enums::VertexPointerType type, GLsizei stride, GLintptr offset) {
		#if defined(glVertexArrayVertexOffsetEXT)
			return glVertexArrayVertexOffsetEXT(vaobj, buffer, size, static_cast<GLenum>(type), stride, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexArrayVertexOffsetEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1d(GLuint index, GLdouble x) {
		#if defined(glVertexAttrib1d)
			return glVertexAttrib1d(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1dARB(GLuint index, GLdouble x) {
		#if defined(glVertexAttrib1dARB)
			return glVertexAttrib1dARB(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1dNV(GLuint index, GLdouble x) {
		#if defined(glVertexAttrib1dNV)
			return glVertexAttrib1dNV(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1dNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib1dv)
			return glVertexAttrib1dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1dvARB(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib1dvARB)
			return glVertexAttrib1dvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1dvNV(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib1dvNV)
			return glVertexAttrib1dvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1f(GLuint index, GLfloat x) {
		#if defined(glVertexAttrib1f)
			return glVertexAttrib1f(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1fARB(GLuint index, GLfloat x) {
		#if defined(glVertexAttrib1fARB)
			return glVertexAttrib1fARB(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1fNV(GLuint index, GLfloat x) {
		#if defined(glVertexAttrib1fNV)
			return glVertexAttrib1fNV(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1fv(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib1fv)
			return glVertexAttrib1fv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1fvARB(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib1fvARB)
			return glVertexAttrib1fvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1fvNV(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib1fvNV)
			return glVertexAttrib1fvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1hNV(GLuint index, GLhalfNV x) {
		#if defined(glVertexAttrib1hNV)
			return glVertexAttrib1hNV(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1hvNV(GLuint index, const GLhalfNV* v) {
		#if defined(glVertexAttrib1hvNV)
			return glVertexAttrib1hvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1s(GLuint index, GLshort x) {
		#if defined(glVertexAttrib1s)
			return glVertexAttrib1s(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1sARB(GLuint index, GLshort x) {
		#if defined(glVertexAttrib1sARB)
			return glVertexAttrib1sARB(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1sNV(GLuint index, GLshort x) {
		#if defined(glVertexAttrib1sNV)
			return glVertexAttrib1sNV(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1sNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1sv(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib1sv)
			return glVertexAttrib1sv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1svARB(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib1svARB)
			return glVertexAttrib1svARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib1svNV(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib1svNV)
			return glVertexAttrib1svNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib1svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2d(GLuint index, GLdouble x, GLdouble y) {
		#if defined(glVertexAttrib2d)
			return glVertexAttrib2d(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y) {
		#if defined(glVertexAttrib2dARB)
			return glVertexAttrib2dARB(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y) {
		#if defined(glVertexAttrib2dNV)
			return glVertexAttrib2dNV(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2dNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib2dv)
			return glVertexAttrib2dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2dvARB(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib2dvARB)
			return glVertexAttrib2dvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2dvNV(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib2dvNV)
			return glVertexAttrib2dvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2f(GLuint index, GLfloat x, GLfloat y) {
		#if defined(glVertexAttrib2f)
			return glVertexAttrib2f(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y) {
		#if defined(glVertexAttrib2fARB)
			return glVertexAttrib2fARB(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y) {
		#if defined(glVertexAttrib2fNV)
			return glVertexAttrib2fNV(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2fv(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib2fv)
			return glVertexAttrib2fv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2fvARB(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib2fvARB)
			return glVertexAttrib2fvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2fvNV(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib2fvNV)
			return glVertexAttrib2fvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y) {
		#if defined(glVertexAttrib2hNV)
			return glVertexAttrib2hNV(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2hvNV(GLuint index, const GLhalfNV* v) {
		#if defined(glVertexAttrib2hvNV)
			return glVertexAttrib2hvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2s(GLuint index, GLshort x, GLshort y) {
		#if defined(glVertexAttrib2s)
			return glVertexAttrib2s(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2sARB(GLuint index, GLshort x, GLshort y) {
		#if defined(glVertexAttrib2sARB)
			return glVertexAttrib2sARB(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2sNV(GLuint index, GLshort x, GLshort y) {
		#if defined(glVertexAttrib2sNV)
			return glVertexAttrib2sNV(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2sNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2sv(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib2sv)
			return glVertexAttrib2sv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2svARB(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib2svARB)
			return glVertexAttrib2svARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib2svNV(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib2svNV)
			return glVertexAttrib2svNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib2svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glVertexAttrib3d)
			return glVertexAttrib3d(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glVertexAttrib3dARB)
			return glVertexAttrib3dARB(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glVertexAttrib3dNV)
			return glVertexAttrib3dNV(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3dNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib3dv)
			return glVertexAttrib3dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3dvARB(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib3dvARB)
			return glVertexAttrib3dvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3dvNV(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib3dvNV)
			return glVertexAttrib3dvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glVertexAttrib3f)
			return glVertexAttrib3f(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glVertexAttrib3fARB)
			return glVertexAttrib3fARB(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glVertexAttrib3fNV)
			return glVertexAttrib3fNV(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3fv(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib3fv)
			return glVertexAttrib3fv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3fvARB(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib3fvARB)
			return glVertexAttrib3fvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3fvNV(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib3fvNV)
			return glVertexAttrib3fvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z) {
		#if defined(glVertexAttrib3hNV)
			return glVertexAttrib3hNV(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3hvNV(GLuint index, const GLhalfNV* v) {
		#if defined(glVertexAttrib3hvNV)
			return glVertexAttrib3hvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z) {
		#if defined(glVertexAttrib3s)
			return glVertexAttrib3s(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z) {
		#if defined(glVertexAttrib3sARB)
			return glVertexAttrib3sARB(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z) {
		#if defined(glVertexAttrib3sNV)
			return glVertexAttrib3sNV(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3sNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3sv(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib3sv)
			return glVertexAttrib3sv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3svARB(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib3svARB)
			return glVertexAttrib3svARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib3svNV(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib3svNV)
			return glVertexAttrib3svNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib3svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4Nbv(GLuint index, const GLbyte* v) {
		#if defined(glVertexAttrib4Nbv)
			return glVertexAttrib4Nbv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4Nbv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4NbvARB(GLuint index, const GLbyte* v) {
		#if defined(glVertexAttrib4NbvARB)
			return glVertexAttrib4NbvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4NbvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4Niv(GLuint index, const GLint* v) {
		#if defined(glVertexAttrib4Niv)
			return glVertexAttrib4Niv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4Niv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4NivARB(GLuint index, const GLint* v) {
		#if defined(glVertexAttrib4NivARB)
			return glVertexAttrib4NivARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4NivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4Nsv(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib4Nsv)
			return glVertexAttrib4Nsv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4Nsv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4NsvARB(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib4NsvARB)
			return glVertexAttrib4NsvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4NsvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
		#if defined(glVertexAttrib4Nub)
			return glVertexAttrib4Nub(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4Nub" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
		#if defined(glVertexAttrib4NubARB)
			return glVertexAttrib4NubARB(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4NubARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4Nubv(GLuint index, const GLubyte* v) {
		#if defined(glVertexAttrib4Nubv)
			return glVertexAttrib4Nubv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4Nubv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4NubvARB(GLuint index, const GLubyte* v) {
		#if defined(glVertexAttrib4NubvARB)
			return glVertexAttrib4NubvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4NubvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4Nuiv(GLuint index, const GLuint* v) {
		#if defined(glVertexAttrib4Nuiv)
			return glVertexAttrib4Nuiv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4Nuiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4NuivARB(GLuint index, const GLuint* v) {
		#if defined(glVertexAttrib4NuivARB)
			return glVertexAttrib4NuivARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4NuivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4Nusv(GLuint index, const GLushort* v) {
		#if defined(glVertexAttrib4Nusv)
			return glVertexAttrib4Nusv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4Nusv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4NusvARB(GLuint index, const GLushort* v) {
		#if defined(glVertexAttrib4NusvARB)
			return glVertexAttrib4NusvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4NusvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4bv(GLuint index, const GLbyte* v) {
		#if defined(glVertexAttrib4bv)
			return glVertexAttrib4bv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4bv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4bvARB(GLuint index, const GLbyte* v) {
		#if defined(glVertexAttrib4bvARB)
			return glVertexAttrib4bvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4bvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glVertexAttrib4d)
			return glVertexAttrib4d(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glVertexAttrib4dARB)
			return glVertexAttrib4dARB(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glVertexAttrib4dNV)
			return glVertexAttrib4dNV(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4dNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib4dv)
			return glVertexAttrib4dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4dvARB(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib4dvARB)
			return glVertexAttrib4dvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4dvNV(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttrib4dvNV)
			return glVertexAttrib4dvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glVertexAttrib4f)
			return glVertexAttrib4f(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glVertexAttrib4fARB)
			return glVertexAttrib4fARB(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glVertexAttrib4fNV)
			return glVertexAttrib4fNV(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4fNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4fv(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib4fv)
			return glVertexAttrib4fv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4fvARB(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib4fvARB)
			return glVertexAttrib4fvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4fvNV(GLuint index, const GLfloat* v) {
		#if defined(glVertexAttrib4fvNV)
			return glVertexAttrib4fvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w) {
		#if defined(glVertexAttrib4hNV)
			return glVertexAttrib4hNV(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4hNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4hvNV(GLuint index, const GLhalfNV* v) {
		#if defined(glVertexAttrib4hvNV)
			return glVertexAttrib4hvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4iv(GLuint index, const GLint* v) {
		#if defined(glVertexAttrib4iv)
			return glVertexAttrib4iv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4ivARB(GLuint index, const GLint* v) {
		#if defined(glVertexAttrib4ivARB)
			return glVertexAttrib4ivARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
		#if defined(glVertexAttrib4s)
			return glVertexAttrib4s(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
		#if defined(glVertexAttrib4sARB)
			return glVertexAttrib4sARB(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
		#if defined(glVertexAttrib4sNV)
			return glVertexAttrib4sNV(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4sNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4sv(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib4sv)
			return glVertexAttrib4sv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4svARB(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib4svARB)
			return glVertexAttrib4svARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4svNV(GLuint index, const GLshort* v) {
		#if defined(glVertexAttrib4svNV)
			return glVertexAttrib4svNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
		#if defined(glVertexAttrib4ubNV)
			return glVertexAttrib4ubNV(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4ubNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4ubv(GLuint index, const GLubyte* v) {
		#if defined(glVertexAttrib4ubv)
			return glVertexAttrib4ubv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4ubv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4ubvARB(GLuint index, const GLubyte* v) {
		#if defined(glVertexAttrib4ubvARB)
			return glVertexAttrib4ubvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4ubvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4ubvNV(GLuint index, const GLubyte* v) {
		#if defined(glVertexAttrib4ubvNV)
			return glVertexAttrib4ubvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4ubvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4uiv(GLuint index, const GLuint* v) {
		#if defined(glVertexAttrib4uiv)
			return glVertexAttrib4uiv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4uivARB(GLuint index, const GLuint* v) {
		#if defined(glVertexAttrib4uivARB)
			return glVertexAttrib4uivARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4uivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4usv(GLuint index, const GLushort* v) {
		#if defined(glVertexAttrib4usv)
			return glVertexAttrib4usv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4usv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttrib4usvARB(GLuint index, const GLushort* v) {
		#if defined(glVertexAttrib4usvARB)
			return glVertexAttrib4usvARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttrib4usvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribArrayObjectATI(GLuint index, GLint size, enums::VertexAttribPointerType type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset) {
		#if defined(glVertexAttribArrayObjectATI)
			return glVertexAttribArrayObjectATI(index, size, static_cast<GLenum>(type), normalized, stride, buffer, offset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribArrayObjectATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribBinding(GLuint attribindex, GLuint bindingindex) {
		#if defined(glVertexAttribBinding)
			return glVertexAttribBinding(attribindex, bindingindex);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribBinding" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribDivisor(GLuint index, GLuint divisor) {
		#if defined(glVertexAttribDivisor)
			return glVertexAttribDivisor(index, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribDivisor" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribDivisorANGLE(GLuint index, GLuint divisor) {
		#if defined(glVertexAttribDivisorANGLE)
			return glVertexAttribDivisorANGLE(index, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribDivisorANGLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribDivisorARB(GLuint index, GLuint divisor) {
		#if defined(glVertexAttribDivisorARB)
			return glVertexAttribDivisorARB(index, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribDivisorARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribDivisorEXT(GLuint index, GLuint divisor) {
		#if defined(glVertexAttribDivisorEXT)
			return glVertexAttribDivisorEXT(index, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribDivisorEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribDivisorNV(GLuint index, GLuint divisor) {
		#if defined(glVertexAttribDivisorNV)
			return glVertexAttribDivisorNV(index, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribDivisorNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribFormat(GLuint attribindex, GLint size, enums::VertexAttribType type, GLboolean normalized, GLuint relativeoffset) {
		#if defined(glVertexAttribFormat)
			return glVertexAttribFormat(attribindex, size, static_cast<GLenum>(type), normalized, relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribFormat" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribFormatNV(GLuint index, GLint size, enums::VertexAttribType type, GLboolean normalized, GLsizei stride) {
		#if defined(glVertexAttribFormatNV)
			return glVertexAttribFormatNV(index, size, static_cast<GLenum>(type), normalized, stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1i(GLuint index, GLint x) {
		#if defined(glVertexAttribI1i)
			return glVertexAttribI1i(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1iEXT(GLuint index, GLint x) {
		#if defined(glVertexAttribI1iEXT)
			return glVertexAttribI1iEXT(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1iv(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI1iv)
			return glVertexAttribI1iv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1ivEXT(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI1ivEXT)
			return glVertexAttribI1ivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1ui(GLuint index, GLuint x) {
		#if defined(glVertexAttribI1ui)
			return glVertexAttribI1ui(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1uiEXT(GLuint index, GLuint x) {
		#if defined(glVertexAttribI1uiEXT)
			return glVertexAttribI1uiEXT(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1uiv(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI1uiv)
			return glVertexAttribI1uiv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI1uivEXT(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI1uivEXT)
			return glVertexAttribI1uivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI1uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2i(GLuint index, GLint x, GLint y) {
		#if defined(glVertexAttribI2i)
			return glVertexAttribI2i(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2iEXT(GLuint index, GLint x, GLint y) {
		#if defined(glVertexAttribI2iEXT)
			return glVertexAttribI2iEXT(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2iv(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI2iv)
			return glVertexAttribI2iv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2ivEXT(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI2ivEXT)
			return glVertexAttribI2ivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2ui(GLuint index, GLuint x, GLuint y) {
		#if defined(glVertexAttribI2ui)
			return glVertexAttribI2ui(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y) {
		#if defined(glVertexAttribI2uiEXT)
			return glVertexAttribI2uiEXT(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2uiv(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI2uiv)
			return glVertexAttribI2uiv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI2uivEXT(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI2uivEXT)
			return glVertexAttribI2uivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI2uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3i(GLuint index, GLint x, GLint y, GLint z) {
		#if defined(glVertexAttribI3i)
			return glVertexAttribI3i(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z) {
		#if defined(glVertexAttribI3iEXT)
			return glVertexAttribI3iEXT(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3iv(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI3iv)
			return glVertexAttribI3iv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3ivEXT(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI3ivEXT)
			return glVertexAttribI3ivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z) {
		#if defined(glVertexAttribI3ui)
			return glVertexAttribI3ui(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z) {
		#if defined(glVertexAttribI3uiEXT)
			return glVertexAttribI3uiEXT(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3uiv(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI3uiv)
			return glVertexAttribI3uiv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI3uivEXT(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI3uivEXT)
			return glVertexAttribI3uivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI3uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4bv(GLuint index, const GLbyte* v) {
		#if defined(glVertexAttribI4bv)
			return glVertexAttribI4bv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4bv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4bvEXT(GLuint index, const GLbyte* v) {
		#if defined(glVertexAttribI4bvEXT)
			return glVertexAttribI4bvEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4bvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w) {
		#if defined(glVertexAttribI4i)
			return glVertexAttribI4i(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w) {
		#if defined(glVertexAttribI4iEXT)
			return glVertexAttribI4iEXT(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4iEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4iv(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI4iv)
			return glVertexAttribI4iv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4ivEXT(GLuint index, const GLint* v) {
		#if defined(glVertexAttribI4ivEXT)
			return glVertexAttribI4ivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4ivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4sv(GLuint index, const GLshort* v) {
		#if defined(glVertexAttribI4sv)
			return glVertexAttribI4sv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4svEXT(GLuint index, const GLshort* v) {
		#if defined(glVertexAttribI4svEXT)
			return glVertexAttribI4svEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4svEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4ubv(GLuint index, const GLubyte* v) {
		#if defined(glVertexAttribI4ubv)
			return glVertexAttribI4ubv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4ubv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4ubvEXT(GLuint index, const GLubyte* v) {
		#if defined(glVertexAttribI4ubvEXT)
			return glVertexAttribI4ubvEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4ubvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
		#if defined(glVertexAttribI4ui)
			return glVertexAttribI4ui(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
		#if defined(glVertexAttribI4uiEXT)
			return glVertexAttribI4uiEXT(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4uiEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4uiv(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI4uiv)
			return glVertexAttribI4uiv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4uivEXT(GLuint index, const GLuint* v) {
		#if defined(glVertexAttribI4uivEXT)
			return glVertexAttribI4uivEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4uivEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4usv(GLuint index, const GLushort* v) {
		#if defined(glVertexAttribI4usv)
			return glVertexAttribI4usv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4usv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribI4usvEXT(GLuint index, const GLushort* v) {
		#if defined(glVertexAttribI4usvEXT)
			return glVertexAttribI4usvEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribI4usvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribIFormat(GLuint attribindex, GLint size, enums::VertexAttribIType type, GLuint relativeoffset) {
		#if defined(glVertexAttribIFormat)
			return glVertexAttribIFormat(attribindex, size, static_cast<GLenum>(type), relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribIFormat" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribIFormatNV(GLuint index, GLint size, enums::VertexAttribIType type, GLsizei stride) {
		#if defined(glVertexAttribIFormatNV)
			return glVertexAttribIFormatNV(index, size, static_cast<GLenum>(type), stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribIFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribIPointer(GLuint index, GLint size, enums::VertexAttribIType type, GLsizei stride, const void * pointer) {
		#if defined(glVertexAttribIPointer)
			return glVertexAttribIPointer(index, size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribIPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribIPointerEXT(GLuint index, GLint size, enums::VertexAttribIType type, GLsizei stride, const void * pointer) {
		#if defined(glVertexAttribIPointerEXT)
			return glVertexAttribIPointerEXT(index, size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribIPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1d(GLuint index, GLdouble x) {
		#if defined(glVertexAttribL1d)
			return glVertexAttribL1d(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1dEXT(GLuint index, GLdouble x) {
		#if defined(glVertexAttribL1dEXT)
			return glVertexAttribL1dEXT(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL1dv)
			return glVertexAttribL1dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1dvEXT(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL1dvEXT)
			return glVertexAttribL1dvEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1i64NV(GLuint index, GLint64EXT x) {
		#if defined(glVertexAttribL1i64NV)
			return glVertexAttribL1i64NV(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1i64vNV(GLuint index, const GLint64EXT* v) {
		#if defined(glVertexAttribL1i64vNV)
			return glVertexAttribL1i64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1ui64ARB(GLuint index, GLuint64EXT x) {
		#if defined(glVertexAttribL1ui64ARB)
			return glVertexAttribL1ui64ARB(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1ui64ARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1ui64NV(GLuint index, GLuint64EXT x) {
		#if defined(glVertexAttribL1ui64NV)
			return glVertexAttribL1ui64NV(index, x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1ui64vARB(GLuint index, const GLuint64EXT* v) {
		#if defined(glVertexAttribL1ui64vARB)
			return glVertexAttribL1ui64vARB(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1ui64vARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL1ui64vNV(GLuint index, const GLuint64EXT* v) {
		#if defined(glVertexAttribL1ui64vNV)
			return glVertexAttribL1ui64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL1ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2d(GLuint index, GLdouble x, GLdouble y) {
		#if defined(glVertexAttribL2d)
			return glVertexAttribL2d(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y) {
		#if defined(glVertexAttribL2dEXT)
			return glVertexAttribL2dEXT(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL2dv)
			return glVertexAttribL2dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2dvEXT(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL2dvEXT)
			return glVertexAttribL2dvEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y) {
		#if defined(glVertexAttribL2i64NV)
			return glVertexAttribL2i64NV(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2i64vNV(GLuint index, const GLint64EXT* v) {
		#if defined(glVertexAttribL2i64vNV)
			return glVertexAttribL2i64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y) {
		#if defined(glVertexAttribL2ui64NV)
			return glVertexAttribL2ui64NV(index, x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL2ui64vNV(GLuint index, const GLuint64EXT* v) {
		#if defined(glVertexAttribL2ui64vNV)
			return glVertexAttribL2ui64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL2ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glVertexAttribL3d)
			return glVertexAttribL3d(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glVertexAttribL3dEXT)
			return glVertexAttribL3dEXT(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL3dv)
			return glVertexAttribL3dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3dvEXT(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL3dvEXT)
			return glVertexAttribL3dvEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z) {
		#if defined(glVertexAttribL3i64NV)
			return glVertexAttribL3i64NV(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3i64vNV(GLuint index, const GLint64EXT* v) {
		#if defined(glVertexAttribL3i64vNV)
			return glVertexAttribL3i64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z) {
		#if defined(glVertexAttribL3ui64NV)
			return glVertexAttribL3ui64NV(index, x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL3ui64vNV(GLuint index, const GLuint64EXT* v) {
		#if defined(glVertexAttribL3ui64vNV)
			return glVertexAttribL3ui64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL3ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glVertexAttribL4d)
			return glVertexAttribL4d(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glVertexAttribL4dEXT)
			return glVertexAttribL4dEXT(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4dEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4dv(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL4dv)
			return glVertexAttribL4dv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4dvEXT(GLuint index, const GLdouble* v) {
		#if defined(glVertexAttribL4dvEXT)
			return glVertexAttribL4dvEXT(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4dvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w) {
		#if defined(glVertexAttribL4i64NV)
			return glVertexAttribL4i64NV(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4i64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4i64vNV(GLuint index, const GLint64EXT* v) {
		#if defined(glVertexAttribL4i64vNV)
			return glVertexAttribL4i64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4i64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w) {
		#if defined(glVertexAttribL4ui64NV)
			return glVertexAttribL4ui64NV(index, x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4ui64NV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribL4ui64vNV(GLuint index, const GLuint64EXT* v) {
		#if defined(glVertexAttribL4ui64vNV)
			return glVertexAttribL4ui64vNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribL4ui64vNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribLFormat(GLuint attribindex, GLint size, enums::VertexAttribLType type, GLuint relativeoffset) {
		#if defined(glVertexAttribLFormat)
			return glVertexAttribLFormat(attribindex, size, static_cast<GLenum>(type), relativeoffset);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribLFormat" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribLFormatNV(GLuint index, GLint size, enums::VertexAttribLType type, GLsizei stride) {
		#if defined(glVertexAttribLFormatNV)
			return glVertexAttribLFormatNV(index, size, static_cast<GLenum>(type), stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribLFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribLPointer(GLuint index, GLint size, enums::VertexAttribLType type, GLsizei stride, const void * pointer) {
		#if defined(glVertexAttribLPointer)
			return glVertexAttribLPointer(index, size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribLPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribLPointerEXT(GLuint index, GLint size, enums::VertexAttribLType type, GLsizei stride, const void * pointer) {
		#if defined(glVertexAttribLPointerEXT)
			return glVertexAttribLPointerEXT(index, size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribLPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP1ui(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, GLuint value) {
		#if defined(glVertexAttribP1ui)
			return glVertexAttribP1ui(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP1ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP1uiv(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, const GLuint* value) {
		#if defined(glVertexAttribP1uiv)
			return glVertexAttribP1uiv(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP1uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP2ui(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, GLuint value) {
		#if defined(glVertexAttribP2ui)
			return glVertexAttribP2ui(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP2ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP2uiv(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, const GLuint* value) {
		#if defined(glVertexAttribP2uiv)
			return glVertexAttribP2uiv(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP2uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP3ui(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, GLuint value) {
		#if defined(glVertexAttribP3ui)
			return glVertexAttribP3ui(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP3uiv(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, const GLuint* value) {
		#if defined(glVertexAttribP3uiv)
			return glVertexAttribP3uiv(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP4ui(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, GLuint value) {
		#if defined(glVertexAttribP4ui)
			return glVertexAttribP4ui(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribP4uiv(GLuint index, enums::VertexAttribPointerType type, GLboolean normalized, const GLuint* value) {
		#if defined(glVertexAttribP4uiv)
			return glVertexAttribP4uiv(index, static_cast<GLenum>(type), normalized, value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribP4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param) {
		#if defined(glVertexAttribParameteriAMD)
			return glVertexAttribParameteriAMD(index, pname, param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribParameteriAMD" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribPointer(GLuint index, GLint size, enums::VertexAttribPointerType type, GLboolean normalized, GLsizei stride, const void * pointer) {
		#if defined(glVertexAttribPointer)
			return glVertexAttribPointer(index, size, static_cast<GLenum>(type), normalized, stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribPointerARB(GLuint index, GLint size, enums::VertexAttribPointerType type, GLboolean normalized, GLsizei stride, const void * pointer) {
		#if defined(glVertexAttribPointerARB)
			return glVertexAttribPointerARB(index, size, static_cast<GLenum>(type), normalized, stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribPointerARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribPointerNV(GLuint index, GLint fsize, enums::VertexAttribEnumNV type, GLsizei stride, const void * pointer) {
		#if defined(glVertexAttribPointerNV)
			return glVertexAttribPointerNV(index, fsize, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribPointerNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs1dvNV(GLuint index, GLsizei count, const GLdouble* v) {
		#if defined(glVertexAttribs1dvNV)
			return glVertexAttribs1dvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs1dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs1fvNV(GLuint index, GLsizei count, const GLfloat* v) {
		#if defined(glVertexAttribs1fvNV)
			return glVertexAttribs1fvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs1fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs1hvNV(GLuint index, GLsizei n, const GLhalfNV* v) {
		#if defined(glVertexAttribs1hvNV)
			return glVertexAttribs1hvNV(index, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs1hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs1svNV(GLuint index, GLsizei count, const GLshort* v) {
		#if defined(glVertexAttribs1svNV)
			return glVertexAttribs1svNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs1svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs2dvNV(GLuint index, GLsizei count, const GLdouble* v) {
		#if defined(glVertexAttribs2dvNV)
			return glVertexAttribs2dvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs2dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs2fvNV(GLuint index, GLsizei count, const GLfloat* v) {
		#if defined(glVertexAttribs2fvNV)
			return glVertexAttribs2fvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs2fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs2hvNV(GLuint index, GLsizei n, const GLhalfNV* v) {
		#if defined(glVertexAttribs2hvNV)
			return glVertexAttribs2hvNV(index, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs2hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs2svNV(GLuint index, GLsizei count, const GLshort* v) {
		#if defined(glVertexAttribs2svNV)
			return glVertexAttribs2svNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs2svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs3dvNV(GLuint index, GLsizei count, const GLdouble* v) {
		#if defined(glVertexAttribs3dvNV)
			return glVertexAttribs3dvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs3dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs3fvNV(GLuint index, GLsizei count, const GLfloat* v) {
		#if defined(glVertexAttribs3fvNV)
			return glVertexAttribs3fvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs3fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs3hvNV(GLuint index, GLsizei n, const GLhalfNV* v) {
		#if defined(glVertexAttribs3hvNV)
			return glVertexAttribs3hvNV(index, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs3hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs3svNV(GLuint index, GLsizei count, const GLshort* v) {
		#if defined(glVertexAttribs3svNV)
			return glVertexAttribs3svNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs3svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs4dvNV(GLuint index, GLsizei count, const GLdouble* v) {
		#if defined(glVertexAttribs4dvNV)
			return glVertexAttribs4dvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs4dvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs4fvNV(GLuint index, GLsizei count, const GLfloat* v) {
		#if defined(glVertexAttribs4fvNV)
			return glVertexAttribs4fvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs4fvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs4hvNV(GLuint index, GLsizei n, const GLhalfNV* v) {
		#if defined(glVertexAttribs4hvNV)
			return glVertexAttribs4hvNV(index, n, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs4hvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs4svNV(GLuint index, GLsizei count, const GLshort* v) {
		#if defined(glVertexAttribs4svNV)
			return glVertexAttribs4svNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs4svNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexAttribs4ubvNV(GLuint index, GLsizei count, const GLubyte* v) {
		#if defined(glVertexAttribs4ubvNV)
			return glVertexAttribs4ubvNV(index, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexAttribs4ubvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexBindingDivisor(GLuint bindingindex, GLuint divisor) {
		#if defined(glVertexBindingDivisor)
			return glVertexBindingDivisor(bindingindex, divisor);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexBindingDivisor" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexBlendARB(GLint count) {
		#if defined(glVertexBlendARB)
			return glVertexBlendARB(count);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexBlendARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexBlendEnvfATI(enums::VertexStreamATI pname, GLfloat param) {
		#if defined(glVertexBlendEnvfATI)
			return glVertexBlendEnvfATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexBlendEnvfATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexBlendEnviATI(enums::VertexStreamATI pname, GLint param) {
		#if defined(glVertexBlendEnviATI)
			return glVertexBlendEnviATI(static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexBlendEnviATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexFormatNV(GLint size, enums::VertexPointerType type, GLsizei stride) {
		#if defined(glVertexFormatNV)
			return glVertexFormatNV(size, static_cast<GLenum>(type), stride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexFormatNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexP2ui(enums::VertexPointerType type, GLuint value) {
		#if defined(glVertexP2ui)
			return glVertexP2ui(static_cast<GLenum>(type), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexP2ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexP2uiv(enums::VertexPointerType type, const GLuint* value) {
		#if defined(glVertexP2uiv)
			return glVertexP2uiv(static_cast<GLenum>(type), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexP2uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexP3ui(enums::VertexPointerType type, GLuint value) {
		#if defined(glVertexP3ui)
			return glVertexP3ui(static_cast<GLenum>(type), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexP3ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexP3uiv(enums::VertexPointerType type, const GLuint* value) {
		#if defined(glVertexP3uiv)
			return glVertexP3uiv(static_cast<GLenum>(type), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexP3uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexP4ui(enums::VertexPointerType type, GLuint value) {
		#if defined(glVertexP4ui)
			return glVertexP4ui(static_cast<GLenum>(type), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexP4ui" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexP4uiv(enums::VertexPointerType type, const GLuint* value) {
		#if defined(glVertexP4uiv)
			return glVertexP4uiv(static_cast<GLenum>(type), value);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexP4uiv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexPointer(GLint size, enums::VertexPointerType type, GLsizei stride, const void * pointer) {
		#if defined(glVertexPointer)
			return glVertexPointer(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexPointer" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexPointerEXT(GLint size, enums::VertexPointerType type, GLsizei stride, GLsizei count, const void * pointer) {
		#if defined(glVertexPointerEXT)
			return glVertexPointerEXT(size, static_cast<GLenum>(type), stride, count, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexPointerListIBM(GLint size, enums::VertexPointerType type, GLint stride, const void ** pointer, GLint ptrstride) {
		#if defined(glVertexPointerListIBM)
			return glVertexPointerListIBM(size, static_cast<GLenum>(type), stride, pointer, ptrstride);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexPointerListIBM" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexPointervINTEL(GLint size, enums::VertexPointerType type, const void ** pointer) {
		#if defined(glVertexPointervINTEL)
			return glVertexPointervINTEL(size, static_cast<GLenum>(type), pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexPointervINTEL" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1dATI(enums::VertexStreamATI stream, GLdouble x) {
		#if defined(glVertexStream1dATI)
			return glVertexStream1dATI(static_cast<GLenum>(stream), x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1dATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1dvATI(enums::VertexStreamATI stream, const GLdouble* coords) {
		#if defined(glVertexStream1dvATI)
			return glVertexStream1dvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1dvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1fATI(enums::VertexStreamATI stream, GLfloat x) {
		#if defined(glVertexStream1fATI)
			return glVertexStream1fATI(static_cast<GLenum>(stream), x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1fATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1fvATI(enums::VertexStreamATI stream, const GLfloat* coords) {
		#if defined(glVertexStream1fvATI)
			return glVertexStream1fvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1fvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1iATI(enums::VertexStreamATI stream, GLint x) {
		#if defined(glVertexStream1iATI)
			return glVertexStream1iATI(static_cast<GLenum>(stream), x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1iATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1ivATI(enums::VertexStreamATI stream, const GLint* coords) {
		#if defined(glVertexStream1ivATI)
			return glVertexStream1ivATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1ivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1sATI(enums::VertexStreamATI stream, GLshort x) {
		#if defined(glVertexStream1sATI)
			return glVertexStream1sATI(static_cast<GLenum>(stream), x);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1sATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream1svATI(enums::VertexStreamATI stream, const GLshort* coords) {
		#if defined(glVertexStream1svATI)
			return glVertexStream1svATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream1svATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2dATI(enums::VertexStreamATI stream, GLdouble x, GLdouble y) {
		#if defined(glVertexStream2dATI)
			return glVertexStream2dATI(static_cast<GLenum>(stream), x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2dATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2dvATI(enums::VertexStreamATI stream, const GLdouble* coords) {
		#if defined(glVertexStream2dvATI)
			return glVertexStream2dvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2dvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2fATI(enums::VertexStreamATI stream, GLfloat x, GLfloat y) {
		#if defined(glVertexStream2fATI)
			return glVertexStream2fATI(static_cast<GLenum>(stream), x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2fATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2fvATI(enums::VertexStreamATI stream, const GLfloat* coords) {
		#if defined(glVertexStream2fvATI)
			return glVertexStream2fvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2fvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2iATI(enums::VertexStreamATI stream, GLint x, GLint y) {
		#if defined(glVertexStream2iATI)
			return glVertexStream2iATI(static_cast<GLenum>(stream), x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2iATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2ivATI(enums::VertexStreamATI stream, const GLint* coords) {
		#if defined(glVertexStream2ivATI)
			return glVertexStream2ivATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2ivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2sATI(enums::VertexStreamATI stream, GLshort x, GLshort y) {
		#if defined(glVertexStream2sATI)
			return glVertexStream2sATI(static_cast<GLenum>(stream), x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2sATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream2svATI(enums::VertexStreamATI stream, const GLshort* coords) {
		#if defined(glVertexStream2svATI)
			return glVertexStream2svATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream2svATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3dATI(enums::VertexStreamATI stream, GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glVertexStream3dATI)
			return glVertexStream3dATI(static_cast<GLenum>(stream), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3dATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3dvATI(enums::VertexStreamATI stream, const GLdouble* coords) {
		#if defined(glVertexStream3dvATI)
			return glVertexStream3dvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3dvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3fATI(enums::VertexStreamATI stream, GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glVertexStream3fATI)
			return glVertexStream3fATI(static_cast<GLenum>(stream), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3fATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3fvATI(enums::VertexStreamATI stream, const GLfloat* coords) {
		#if defined(glVertexStream3fvATI)
			return glVertexStream3fvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3fvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3iATI(enums::VertexStreamATI stream, GLint x, GLint y, GLint z) {
		#if defined(glVertexStream3iATI)
			return glVertexStream3iATI(static_cast<GLenum>(stream), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3iATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3ivATI(enums::VertexStreamATI stream, const GLint* coords) {
		#if defined(glVertexStream3ivATI)
			return glVertexStream3ivATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3ivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3sATI(enums::VertexStreamATI stream, GLshort x, GLshort y, GLshort z) {
		#if defined(glVertexStream3sATI)
			return glVertexStream3sATI(static_cast<GLenum>(stream), x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3sATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream3svATI(enums::VertexStreamATI stream, const GLshort* coords) {
		#if defined(glVertexStream3svATI)
			return glVertexStream3svATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream3svATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4dATI(enums::VertexStreamATI stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glVertexStream4dATI)
			return glVertexStream4dATI(static_cast<GLenum>(stream), x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4dATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4dvATI(enums::VertexStreamATI stream, const GLdouble* coords) {
		#if defined(glVertexStream4dvATI)
			return glVertexStream4dvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4dvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4fATI(enums::VertexStreamATI stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glVertexStream4fATI)
			return glVertexStream4fATI(static_cast<GLenum>(stream), x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4fATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4fvATI(enums::VertexStreamATI stream, const GLfloat* coords) {
		#if defined(glVertexStream4fvATI)
			return glVertexStream4fvATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4fvATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4iATI(enums::VertexStreamATI stream, GLint x, GLint y, GLint z, GLint w) {
		#if defined(glVertexStream4iATI)
			return glVertexStream4iATI(static_cast<GLenum>(stream), x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4iATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4ivATI(enums::VertexStreamATI stream, const GLint* coords) {
		#if defined(glVertexStream4ivATI)
			return glVertexStream4ivATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4ivATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4sATI(enums::VertexStreamATI stream, GLshort x, GLshort y, GLshort z, GLshort w) {
		#if defined(glVertexStream4sATI)
			return glVertexStream4sATI(static_cast<GLenum>(stream), x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4sATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexStream4svATI(enums::VertexStreamATI stream, const GLshort* coords) {
		#if defined(glVertexStream4svATI)
			return glVertexStream4svATI(static_cast<GLenum>(stream), coords);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexStream4svATI" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexWeightPointerEXT(GLint size, enums::VertexWeightPointerTypeEXT type, GLsizei stride, const void * pointer) {
		#if defined(glVertexWeightPointerEXT)
			return glVertexWeightPointerEXT(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexWeightPointerEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexWeightfEXT(GLfloat weight) {
		#if defined(glVertexWeightfEXT)
			return glVertexWeightfEXT(weight);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexWeightfEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexWeightfvEXT(const GLfloat* weight) {
		#if defined(glVertexWeightfvEXT)
			return glVertexWeightfvEXT(weight);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexWeightfvEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexWeighthNV(GLhalfNV weight) {
		#if defined(glVertexWeighthNV)
			return glVertexWeighthNV(weight);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexWeighthNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void vertexWeighthvNV(const GLhalfNV* weight) {
		#if defined(glVertexWeighthvNV)
			return glVertexWeighthvNV(weight);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVertexWeighthvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLenum videoCaptureNV(GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT* capture_time) {
		#if defined(glVideoCaptureNV)
			return glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVideoCaptureNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void videoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params) {
		#if defined(glVideoCaptureStreamParameterdvNV)
			return glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVideoCaptureStreamParameterdvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void videoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params) {
		#if defined(glVideoCaptureStreamParameterfvNV)
			return glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVideoCaptureStreamParameterfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void videoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params) {
		#if defined(glVideoCaptureStreamParameterivNV)
			return glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glVideoCaptureStreamParameterivNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewport(GLint x, GLint y, GLsizei width, GLsizei height) {
		#if defined(glViewport)
			return glViewport(x, y, width, height);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewport" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportArrayv(GLuint first, GLsizei count, const GLfloat* v) {
		#if defined(glViewportArrayv)
			return glViewportArrayv(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportArrayv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportArrayvNV(GLuint first, GLsizei count, const GLfloat* v) {
		#if defined(glViewportArrayvNV)
			return glViewportArrayvNV(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportArrayvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportArrayvOES(GLuint first, GLsizei count, const GLfloat* v) {
		#if defined(glViewportArrayvOES)
			return glViewportArrayvOES(first, count, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportArrayvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
		#if defined(glViewportIndexedf)
			return glViewportIndexedf(index, x, y, w, h);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportIndexedf" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportIndexedfOES(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
		#if defined(glViewportIndexedfOES)
			return glViewportIndexedfOES(index, x, y, w, h);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportIndexedfOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportIndexedfNV(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
		#if defined(glViewportIndexedfNV)
			return glViewportIndexedfNV(index, x, y, w, h);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportIndexedfNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportIndexedfv(GLuint index, const GLfloat* v) {
		#if defined(glViewportIndexedfv)
			return glViewportIndexedfv(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportIndexedfv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportIndexedfvOES(GLuint index, const GLfloat* v) {
		#if defined(glViewportIndexedfvOES)
			return glViewportIndexedfvOES(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportIndexedfvOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportIndexedfvNV(GLuint index, const GLfloat* v) {
		#if defined(glViewportIndexedfvNV)
			return glViewportIndexedfvNV(index, v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportIndexedfvNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportPositionWScaleNV(GLuint index, GLfloat xcoeff, GLfloat ycoeff) {
		#if defined(glViewportPositionWScaleNV)
			return glViewportPositionWScaleNV(index, xcoeff, ycoeff);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportPositionWScaleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void viewportSwizzleNV(GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew) {
		#if defined(glViewportSwizzleNV)
			return glViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glViewportSwizzleNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void waitSemaphoreEXT(GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint* textures, const GLenum* srcLayouts) {
		#if defined(glWaitSemaphoreEXT)
			return glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWaitSemaphoreEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void waitSemaphoreui64NVX(GLuint waitGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64* fenceValueArray) {
		#if defined(glWaitSemaphoreui64NVX)
			return glWaitSemaphoreui64NVX(waitGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWaitSemaphoreui64NVX" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void waitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
		#if defined(glWaitSync)
			return glWaitSync(sync, flags, timeout);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWaitSync" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void waitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout) {
		#if defined(glWaitSyncAPPLE)
			return glWaitSyncAPPLE(sync, flags, timeout);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWaitSyncAPPLE" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint* paths, const GLfloat* weights) {
		#if defined(glWeightPathsNV)
			return glWeightPathsNV(resultPath, numPaths, paths, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightPathsNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightPointerARB(GLint size, enums::WeightPointerTypeARB type, GLsizei stride, const void * pointer) {
		#if defined(glWeightPointerARB)
			return glWeightPointerARB(size, static_cast<GLenum>(type), stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightPointerARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightPointerOES(GLint size, GLenum type, GLsizei stride, const void * pointer) {
		#if defined(glWeightPointerOES)
			return glWeightPointerOES(size, type, stride, pointer);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightPointerOES" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightbvARB(GLint size, const GLbyte* weights) {
		#if defined(glWeightbvARB)
			return glWeightbvARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightbvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightdvARB(GLint size, const GLdouble* weights) {
		#if defined(glWeightdvARB)
			return glWeightdvARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightdvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightfvARB(GLint size, const GLfloat* weights) {
		#if defined(glWeightfvARB)
			return glWeightfvARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightfvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightivARB(GLint size, const GLint* weights) {
		#if defined(glWeightivARB)
			return glWeightivARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightsvARB(GLint size, const GLshort* weights) {
		#if defined(glWeightsvARB)
			return glWeightsvARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightsvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightubvARB(GLint size, const GLubyte* weights) {
		#if defined(glWeightubvARB)
			return glWeightubvARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightubvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightuivARB(GLint size, const GLuint* weights) {
		#if defined(glWeightuivARB)
			return glWeightuivARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightuivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void weightusvARB(GLint size, const GLushort* weights) {
		#if defined(glWeightusvARB)
			return glWeightusvARB(size, weights);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWeightusvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2d(GLdouble x, GLdouble y) {
		#if defined(glWindowPos2d)
			return glWindowPos2d(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2dARB(GLdouble x, GLdouble y) {
		#if defined(glWindowPos2dARB)
			return glWindowPos2dARB(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2dMESA(GLdouble x, GLdouble y) {
		#if defined(glWindowPos2dMESA)
			return glWindowPos2dMESA(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2dMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2dv(const GLdouble* v) {
		#if defined(glWindowPos2dv)
			return glWindowPos2dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2dvARB(const GLdouble* v) {
		#if defined(glWindowPos2dvARB)
			return glWindowPos2dvARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2dvMESA(const GLdouble* v) {
		#if defined(glWindowPos2dvMESA)
			return glWindowPos2dvMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2dvMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2f(GLfloat x, GLfloat y) {
		#if defined(glWindowPos2f)
			return glWindowPos2f(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2fARB(GLfloat x, GLfloat y) {
		#if defined(glWindowPos2fARB)
			return glWindowPos2fARB(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2fMESA(GLfloat x, GLfloat y) {
		#if defined(glWindowPos2fMESA)
			return glWindowPos2fMESA(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2fMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2fv(const GLfloat* v) {
		#if defined(glWindowPos2fv)
			return glWindowPos2fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2fvARB(const GLfloat* v) {
		#if defined(glWindowPos2fvARB)
			return glWindowPos2fvARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2fvMESA(const GLfloat* v) {
		#if defined(glWindowPos2fvMESA)
			return glWindowPos2fvMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2fvMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2i(GLint x, GLint y) {
		#if defined(glWindowPos2i)
			return glWindowPos2i(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2iARB(GLint x, GLint y) {
		#if defined(glWindowPos2iARB)
			return glWindowPos2iARB(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2iMESA(GLint x, GLint y) {
		#if defined(glWindowPos2iMESA)
			return glWindowPos2iMESA(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2iMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2iv(const GLint* v) {
		#if defined(glWindowPos2iv)
			return glWindowPos2iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2ivARB(const GLint* v) {
		#if defined(glWindowPos2ivARB)
			return glWindowPos2ivARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2ivMESA(const GLint* v) {
		#if defined(glWindowPos2ivMESA)
			return glWindowPos2ivMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2ivMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2s(GLshort x, GLshort y) {
		#if defined(glWindowPos2s)
			return glWindowPos2s(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2sARB(GLshort x, GLshort y) {
		#if defined(glWindowPos2sARB)
			return glWindowPos2sARB(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2sMESA(GLshort x, GLshort y) {
		#if defined(glWindowPos2sMESA)
			return glWindowPos2sMESA(x, y);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2sMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2sv(const GLshort* v) {
		#if defined(glWindowPos2sv)
			return glWindowPos2sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2svARB(const GLshort* v) {
		#if defined(glWindowPos2svARB)
			return glWindowPos2svARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos2svMESA(const GLshort* v) {
		#if defined(glWindowPos2svMESA)
			return glWindowPos2svMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos2svMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3d(GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glWindowPos3d)
			return glWindowPos3d(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3d" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3dARB(GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glWindowPos3dARB)
			return glWindowPos3dARB(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3dARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3dMESA(GLdouble x, GLdouble y, GLdouble z) {
		#if defined(glWindowPos3dMESA)
			return glWindowPos3dMESA(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3dMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3dv(const GLdouble* v) {
		#if defined(glWindowPos3dv)
			return glWindowPos3dv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3dv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3dvARB(const GLdouble* v) {
		#if defined(glWindowPos3dvARB)
			return glWindowPos3dvARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3dvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3dvMESA(const GLdouble* v) {
		#if defined(glWindowPos3dvMESA)
			return glWindowPos3dvMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3dvMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3f(GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glWindowPos3f)
			return glWindowPos3f(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3f" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3fARB(GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glWindowPos3fARB)
			return glWindowPos3fARB(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3fARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3fMESA(GLfloat x, GLfloat y, GLfloat z) {
		#if defined(glWindowPos3fMESA)
			return glWindowPos3fMESA(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3fMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3fv(const GLfloat* v) {
		#if defined(glWindowPos3fv)
			return glWindowPos3fv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3fv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3fvARB(const GLfloat* v) {
		#if defined(glWindowPos3fvARB)
			return glWindowPos3fvARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3fvARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3fvMESA(const GLfloat* v) {
		#if defined(glWindowPos3fvMESA)
			return glWindowPos3fvMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3fvMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3i(GLint x, GLint y, GLint z) {
		#if defined(glWindowPos3i)
			return glWindowPos3i(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3i" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3iARB(GLint x, GLint y, GLint z) {
		#if defined(glWindowPos3iARB)
			return glWindowPos3iARB(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3iARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3iMESA(GLint x, GLint y, GLint z) {
		#if defined(glWindowPos3iMESA)
			return glWindowPos3iMESA(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3iMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3iv(const GLint* v) {
		#if defined(glWindowPos3iv)
			return glWindowPos3iv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3iv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3ivARB(const GLint* v) {
		#if defined(glWindowPos3ivARB)
			return glWindowPos3ivARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3ivARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3ivMESA(const GLint* v) {
		#if defined(glWindowPos3ivMESA)
			return glWindowPos3ivMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3ivMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3s(GLshort x, GLshort y, GLshort z) {
		#if defined(glWindowPos3s)
			return glWindowPos3s(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3s" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3sARB(GLshort x, GLshort y, GLshort z) {
		#if defined(glWindowPos3sARB)
			return glWindowPos3sARB(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3sARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3sMESA(GLshort x, GLshort y, GLshort z) {
		#if defined(glWindowPos3sMESA)
			return glWindowPos3sMESA(x, y, z);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3sMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3sv(const GLshort* v) {
		#if defined(glWindowPos3sv)
			return glWindowPos3sv(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3sv" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3svARB(const GLshort* v) {
		#if defined(glWindowPos3svARB)
			return glWindowPos3svARB(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3svARB" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos3svMESA(const GLshort* v) {
		#if defined(glWindowPos3svMESA)
			return glWindowPos3svMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos3svMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
		#if defined(glWindowPos4dMESA)
			return glWindowPos4dMESA(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4dMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4dvMESA(const GLdouble* v) {
		#if defined(glWindowPos4dvMESA)
			return glWindowPos4dvMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4dvMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
		#if defined(glWindowPos4fMESA)
			return glWindowPos4fMESA(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4fMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4fvMESA(const GLfloat* v) {
		#if defined(glWindowPos4fvMESA)
			return glWindowPos4fvMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4fvMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4iMESA(GLint x, GLint y, GLint z, GLint w) {
		#if defined(glWindowPos4iMESA)
			return glWindowPos4iMESA(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4iMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4ivMESA(const GLint* v) {
		#if defined(glWindowPos4ivMESA)
			return glWindowPos4ivMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4ivMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w) {
		#if defined(glWindowPos4sMESA)
			return glWindowPos4sMESA(x, y, z, w);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4sMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowPos4svMESA(const GLshort* v) {
		#if defined(glWindowPos4svMESA)
			return glWindowPos4svMESA(v);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowPos4svMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void windowRectanglesEXT(GLenum mode, GLsizei count, const GLint* box) {
		#if defined(glWindowRectanglesEXT)
			return glWindowRectanglesEXT(mode, count, box);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWindowRectanglesEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void writeMaskEXT(GLuint res, GLuint in, enums::VertexShaderWriteMaskEXT outX, enums::VertexShaderWriteMaskEXT outY, enums::VertexShaderWriteMaskEXT outZ, enums::VertexShaderWriteMaskEXT outW) {
		#if defined(glWriteMaskEXT)
			return glWriteMaskEXT(res, in, static_cast<GLenum>(outX), static_cast<GLenum>(outY), static_cast<GLenum>(outZ), static_cast<GLenum>(outW));
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWriteMaskEXT" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void drawVkImageNV(GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1) {
		#if defined(glDrawVkImageNV)
			return glDrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glDrawVkImageNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline GLVULKANPROCNV getVkProcAddrNV(const GLchar* name) {
		#if defined(glGetVkProcAddrNV)
			return glGetVkProcAddrNV(name);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetVkProcAddrNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return 0;
		#endif
	}
	inline void waitVkSemaphoreNV(GLuint64 vkSemaphore) {
		#if defined(glWaitVkSemaphoreNV)
			return glWaitVkSemaphoreNV(vkSemaphore);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glWaitVkSemaphoreNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void signalVkSemaphoreNV(GLuint64 vkSemaphore) {
		#if defined(glSignalVkSemaphoreNV)
			return glSignalVkSemaphoreNV(vkSemaphore);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSignalVkSemaphoreNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void signalVkFenceNV(GLuint64 vkFence) {
		#if defined(glSignalVkFenceNV)
			return glSignalVkFenceNV(vkFence);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glSignalVkFenceNV" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void framebufferParameteriMESA(enums::FramebufferTarget target, enums::FramebufferParameterName pname, GLint param) {
		#if defined(glFramebufferParameteriMESA)
			return glFramebufferParameteriMESA(static_cast<GLenum>(target), static_cast<GLenum>(pname), param);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glFramebufferParameteriMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
	inline void getFramebufferParameterivMESA(enums::FramebufferTarget target, enums::FramebufferAttachmentParameterName pname, GLint* params) {
		#if defined(glGetFramebufferParameterivMESA)
			return glGetFramebufferParameterivMESA(static_cast<GLenum>(target), static_cast<GLenum>(pname), params);
		#else
			static bool warned = false;
			if (!warned) {
				std::cerr << "Warning: function " << "glGetFramebufferParameterivMESA" << " is not supported on this platform." << std::endl;
				warned = true;
			}
			return;
		#endif
	}
} // namespace funcs
} // namespace ogl
